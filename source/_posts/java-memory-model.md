---
title: 《java并发编程实战》之java内存模型
date: 2017-10-18 15:28:49
tags: java并发
---
> “如欲征服java并发，需先征服java内存模型，如欲征服java内存模型，需先征服计算机内存模型” -aworker.

![大佬讲话](https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java-memory-model/leader_speak.jpg)
咳！咳！，大家都记好笔记了吧。虽然我不是什么大佬，但是这句话说的还是没有毛病的。不了解java的内存模型，就不会从跟不上理解java并发的一些行为和机制，而java内存模型毕竟是jvm模拟出来的一部分，其底子还是建立在现代计算机的物理内存模型上来的，所以我们就按照现代计算机的物理内存模型、java内存模型的顺序来仔细介绍，为彻底了解java并发机制打下底子。
现代计算机的物理内存模型：
![现代计算机的物理内存模型](https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java-memory-model/memory_model_physical.png)
现在计算机最少的都是应该是两核心了，当然我们也经常在买个人电脑的时候听过四核四线程、四核八线程等，可以说现在个人电脑标配都是四核心了，为了方便上图只是列举了2个核心。现代计算机的内存在逻辑上还是一块。有人可能问不对啊，我电脑就插了两块内存，但是操作系统会把两块内存的地址统一抽象，比如每一块的内存是2048MB地址是000000000000-011111111111MB，两块就是0000000000000-0111111111111MB，操作系统会统一编址。所以整体上看还是一块内存。因为CPU的操作速度太快，如果让CPU直接操作内存，那么久是对CPU资源的一种巨大浪费，为了解决这个问题现在计算机都给CPU加上缓存，比如一级缓存，二级缓存，甚至三级缓存。缓存速度比内存快，但是是还是赶不上CPU的数据级别，所以在缓存和CPU之间又有了register,register的存储速度比缓存就快了好多了。
存储速度上有如下关系：
register > 一级缓存 > 二级缓存 > ... > n级缓存 > 内存
容量上一般有如下关系：
内存 > n级缓存 > ... > 二级缓存 > 一级缓存 > register
之所以可以用缓存和register来缓解CPU和内存之间巨大的速度差别是基于如下原理：

** CPU访问过的内存地址，很有可能在短时间内会被再次访问。 **  
所以，比如CPU访问了地址为0x001fffff的内存地址，如果没有缓存和register，那么CPU再下次访问这个内存地址的时候就还要去内存读，但是如果有缓存，缓存会把CPU访问过的数据先存储起来，等CPU待会再找地址为0x001fffff的内存地址时候，发现其在缓存中就存在了，那么好了，这就不用在访问内存了。速度自然就提升了。这就涉及到计算机组成原理的知识了，如果想了解可以google一下，这里就不在做更深的介绍了到这里就够用了。
了解现代计算机物理内存模型工作原理后，那么再理解多线程开发中最关系的三个概念就有的放矢了。先介绍下三个概念：

1. ** 操作原子性 **：一个操作要么全做，要么全不做，那么这个操作就符合原子性。比如你给你老婆银行卡转500块钱，就包括两个操作，自己账户先减500，你老婆账户加500。但是这个转账操作应该满足原子性。如果银行只执行了你自己账户的扣钱操作，没有执行给你老婆账户的加钱操作。丢了500块钱是小事，被老婆大人罚跪搓衣板可就不得了了。所以你自己账户减钱，老婆账户加钱，这两个操作要么都做了，要么都别做。例如如下操作：
 ``` 
 a = a + 1; 
 ```
 结合我们上述的现代计算机的内存模型，计算机执行a=a+1时候会分成三个原子性操作：
 1. 把a的值（比如4）从内存中取出放到CPU的缓存系统中
 2. 从缓存系统中取出a的值加1（4+1）得到新结果
 3. 把新结果存回到内存中

 一个“a=a+1”操作计算机中被拆分成三个原子性操作，那么完全可以出现CPU执行完1.操作后，去执行别的操作了。这就是并发操作原子性问题的根本来源。

2. ** 操作有序性 **：例如如下代码： 
```
public class A {
    private int a;
    private boolean b = false;

    public void methodA(){
        a = 3;
        b = true;
        a = a + 1;
    }
} 
```
代码先经过java编译器编译成字节码，然后字节码然后被操作系统解释成机器指令，在这个解释过程中，操作系统可能发现，咦？在给变量b赋值为true后又操作了a变量，干脆我操作系统自己改改执行顺序，把对a变量的两个操作都执行完，然后再执行对b的操作。这样就会节省操作时间,如下图所示对比：

