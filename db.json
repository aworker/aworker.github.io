{"meta":{"version":1,"warehouse":"3.0.1"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"themes/3-hexo/source/css/gitalk.css","path":"css/gitalk.css","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/mobile.styl","path":"css/mobile.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/img/alipay.jpg","path":"img/alipay.jpg","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/img/avatar.jpg","path":"img/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/img/school-book.png","path":"img/school-book.png","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/img/article-list-background.jpeg","path":"img/article-list-background.jpeg","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/img/brown-papersq.png","path":"img/brown-papersq.png","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/img/weixin.jpg","path":"img/weixin.jpg","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/js/jquery.autocomplete.min.js","path":"js/jquery.autocomplete.min.js","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/js/iconfont.js","path":"js/iconfont.js","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/js/jquery.pjax.js","path":"js/jquery.pjax.js","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.eot","path":"css/fonts/icomoon.eot","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.woff","path":"css/fonts/icomoon.woff","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.ttf","path":"css/fonts/icomoon.ttf","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/iconfont.eot","path":"css/fonts/iconfont.eot","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.svg","path":"css/fonts/icomoon.svg","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/iconfont.ttf","path":"css/fonts/iconfont.ttf","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/iconfont.woff","path":"css/fonts/iconfont.woff","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/iconfont.svg","path":"css/fonts/iconfont.svg","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/brown-paper.styl","path":"css/hl_theme/brown-paper.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/atom-light.styl","path":"css/hl_theme/atom-light.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/atom-dark.styl","path":"css/hl_theme/atom-dark.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/selection.json","path":"css/fonts/selection.json","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/github-gist.styl","path":"css/hl_theme/github-gist.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/darcula.styl","path":"css/hl_theme/darcula.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/github.styl","path":"css/hl_theme/github.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-dark.styl","path":"css/hl_theme/kimbie-dark.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-dark.styl","path":"css/hl_theme/gruvbox-dark.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-light.styl","path":"css/hl_theme/gruvbox-light.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-light.styl","path":"css/hl_theme/kimbie-light.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/school-book.styl","path":"css/hl_theme/school-book.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/railscasts.styl","path":"css/hl_theme/railscasts.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/rainbow.styl","path":"css/hl_theme/rainbow.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/sublime.styl","path":"css/hl_theme/sublime.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/sunburst.styl","path":"css/hl_theme/sunburst.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/zenbum.styl","path":"css/hl_theme/zenbum.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/js/gitment.js","path":"js/gitment.js","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/js/gitalk.js","path":"js/gitalk.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"f5367a984ed6b614412786e8434452fab61cf9e9","modified":1574254007926},{"_id":"themes/3-hexo/.gitignore","hash":"560a43fddfe4559ed1a17e7362874454519f189b","modified":1574254007940},{"_id":"themes/3-hexo/README.md","hash":"754d6f873d73f4a7faf5530fa4062e9a696a8fd4","modified":1574254007940},{"_id":"themes/3-hexo/_config.yml","hash":"55ae74e5614051cd470705d5efd50a03f9796dbd","modified":1574254007940},{"_id":"themes/3-hexo/layout/index.ejs","hash":"a5c464897e7dc9d45d03d8b61e742b1ac4173a95","modified":1574254007949},{"_id":"themes/3-hexo/layout/indexs.md","hash":"4dbd2094fff1e3146e67b33aa0326b193d0496c7","modified":1574254007949},{"_id":"themes/3-hexo/layout/post.ejs","hash":"aeda285031ba8d4e94225e82b364bcf5f79fce1d","modified":1574254007949},{"_id":"source/about/index.md","hash":"43b0945986d61f77c62ca7910a212989b5162b19","modified":1574254007939},{"_id":"source/categories/index.md","hash":"f8aea921bd9f768398e8fdbe9565830ce77da537","modified":1574254007939},{"_id":"themes/3-hexo/layout/_partial/article.ejs","hash":"d3c928954057bcebdf3fc294b2123885b08396d3","modified":1574254007942},{"_id":"themes/3-hexo/layout/_partial/article_copyright.ejs","hash":"05d3cddf5f3a53577452db4efa811bd361f7c0c4","modified":1574254007942},{"_id":"themes/3-hexo/layout/_partial/comment.ejs","hash":"d18f94e04ef0cf7abb432a8e707ccb3abc7fe435","modified":1574254007943},{"_id":"themes/3-hexo/layout/_partial/copyright.ejs","hash":"faffe25aec33936fa2ec9d8f0e34e16ef3d90c25","modified":1574254007944},{"_id":"themes/3-hexo/layout/_partial/full-toc.ejs","hash":"0e976208d79b0396eb51ca1af5016c963c6e4618","modified":1574254007946},{"_id":"themes/3-hexo/layout/_partial/friends.ejs","hash":"558a3d4bad578819fb07729fe1b50d9b81da8b93","modified":1574254007946},{"_id":"themes/3-hexo/layout/_partial/dashang.ejs","hash":"6eab1e5fae6bd60928325d026a1bed61c43d11a9","modified":1574254007945},{"_id":"themes/3-hexo/layout/_partial/header.ejs","hash":"915d5f10dd8f3dcd19cb75010e23689e8f385caf","modified":1574254007947},{"_id":"themes/3-hexo/layout/_partial/footer.ejs","hash":"311489fe2050ada8a0eaad3d0c57e5d5012f470e","modified":1574254007946},{"_id":"themes/3-hexo/layout/_partial/mathjax.ejs","hash":"e2be0e37f3d48e63e65a47d819bfb800b9aa3784","modified":1574254007947},{"_id":"themes/3-hexo/layout/_partial/tag.ejs","hash":"87e932476754f27424f9ec397ed66a4ab8a59ad8","modified":1574254007948},{"_id":"themes/3-hexo/layout/_partial/meta.ejs","hash":"ef387e80043b62e1925a068267f2377cac64adc7","modified":1574254007947},{"_id":"themes/3-hexo/layout/_partial/toc-ref.ejs","hash":"33f7a4bfca1bb9835ec8f0d1e73188d1f56cc8b9","modified":1574254007948},{"_id":"themes/3-hexo/layout/_partial/nav-left.ejs","hash":"c14bc1393f779dff7854089621804dceea236d82","modified":1574254007948},{"_id":"themes/3-hexo/layout/_partial/nav-right.ejs","hash":"98326675546fc6828a45e8b95250899b4ee2d821","modified":1574254007948},{"_id":"themes/3-hexo/source/css/gitalk.css","hash":"3dc58e9a3fd63a3144d5fe850eb55e3dc885c9fb","modified":1574254007958},{"_id":"themes/3-hexo/source/css/mobile.styl","hash":"d10bdd736aa343f38fe15cba4c81d45d3d259de4","modified":1574254007964},{"_id":"themes/3-hexo/source/css/style.styl","hash":"322abe325d5fe9ff37347bdd19e772315a8ebfed","modified":1574254007964},{"_id":"themes/3-hexo/source/img/alipay.jpg","hash":"c4a96cc935740fb2db5b5db401747401f90a74d1","modified":1574254007965},{"_id":"themes/3-hexo/source/img/avatar.jpg","hash":"a42360089bfa892d803cf5747eab359d90f337f1","modified":1574254007967},{"_id":"themes/3-hexo/source/img/school-book.png","hash":"711ec983c874e093bb89eb77afcbdf6741fa61ee","modified":1574254007967},{"_id":"themes/3-hexo/source/img/article-list-background.jpeg","hash":"4fdf8b3e53dd02d6ee6360aebfadb0cba1fb5633","modified":1574254007966},{"_id":"themes/3-hexo/source/img/brown-papersq.png","hash":"3a1332ede3a75a3d24f60b6ed69035b72da5e182","modified":1574254007967},{"_id":"themes/3-hexo/source/img/weixin.jpg","hash":"bb917845578c38ad291a18186225d566b58b0fcc","modified":1574254007968},{"_id":"themes/3-hexo/source/js/jquery.autocomplete.min.js","hash":"2462169ad7f4a8ae9f9f4063995cbe7fed45cd77","modified":1574254007972},{"_id":"themes/3-hexo/source/js/iconfont.js","hash":"3a0869ca1b09af07d82987e343a3bc4cb9558ecb","modified":1574254007972},{"_id":"themes/3-hexo/source/js/script.js","hash":"14772b08b9c3d5c99a4b54748be9666deaae2778","modified":1574254007973},{"_id":"themes/3-hexo/source/js/jquery.pjax.js","hash":"8c2a4f10a4da3d9615a3a81542494c6d21479b3d","modified":1574254007973},{"_id":"themes/3-hexo/source/js/search.js","hash":"788c610149a5f9361295f9f0207c8523f37ddb8b","modified":1574254007974},{"_id":"themes/3-hexo/layout/_partial/comments/click2show.ejs","hash":"8a3a175c2da956366ce91bfc4f4012a487f4bdfc","modified":1574254007943},{"_id":"themes/3-hexo/layout/_partial/comments/gentie.ejs","hash":"908d9046502612d24780ca354bd9392a009b4d7b","modified":1574254007944},{"_id":"themes/3-hexo/layout/_partial/comments/disqus.ejs","hash":"32ce7b48d366b9c888ff2ceb911a3cd82f864537","modified":1574254007943},{"_id":"themes/3-hexo/layout/_partial/comments/gitalk.ejs","hash":"01567e010cf4f2dd141fe2019490d3f0d5aa2529","modified":1574254007944},{"_id":"themes/3-hexo/layout/_partial/comments/gitment.ejs","hash":"eaf2b6f297282606b630ad55fb9e38af7e2829dc","modified":1574254007944},{"_id":"themes/3-hexo/source/css/_partial/autocomplete.styl","hash":"1ffe51e3b77afefcd94d386a718506d5b055ad94","modified":1574254007950},{"_id":"themes/3-hexo/source/css/_partial/comment.styl","hash":"fe00fb1269b4fe1f3d5ab917891926222ce47275","modified":1574254007950},{"_id":"themes/3-hexo/source/css/_partial/dashang.styl","hash":"f0eac1dc1f5dbed1769d032bb5fd5f002faaee26","modified":1574254007951},{"_id":"themes/3-hexo/source/css/_partial/fade.styl","hash":"02c7510a26f306e240f23ddbf772a69be2c890dd","modified":1574254007951},{"_id":"themes/3-hexo/source/css/_partial/nav-left.styl","hash":"bf29eab9ea75fa191d678b6eefec440505ddf6e3","modified":1574254007952},{"_id":"themes/3-hexo/source/css/_partial/font.styl","hash":"c200f3fabcfe83f3e45746e186b4bb111e73ad47","modified":1574254007952},{"_id":"themes/3-hexo/source/css/_partial/nprogress.styl","hash":"2620a02169a6aeb75137fd368eac2c36423d8498","modified":1574254007953},{"_id":"themes/3-hexo/source/css/_partial/full-toc.styl","hash":"4102753dad0cc1ee9ed673f7253ba097a960c3b7","modified":1574254007952},{"_id":"themes/3-hexo/source/css/_partial/nav-right.styl","hash":"1d01247f974b059d9ef6a2178a724b4f72acd659","modified":1574254007953},{"_id":"themes/3-hexo/source/css/_partial/num-load.styl","hash":"f7ef35459ece22e1da950b86126be1c2bfe97fcf","modified":1574254007953},{"_id":"themes/3-hexo/source/css/_partial/post.styl","hash":"8a462cf9b0b026e71eda9e704c0fbb952b4615c5","modified":1574254007954},{"_id":"themes/3-hexo/source/css/fonts/icomoon.eot","hash":"b6195bedc1cb2f9cfcb26cc27021f2e94be2ab0a","modified":1574254007954},{"_id":"themes/3-hexo/source/css/fonts/icomoon.woff","hash":"3985d29416bb9b19f50a2f20f2bbbce47f10af8d","modified":1574254007955},{"_id":"themes/3-hexo/source/css/fonts/icomoon.ttf","hash":"eb976d8b8559fcddfc2658a03a4350cb566fc06b","modified":1574254007955},{"_id":"themes/3-hexo/source/css/fonts/iconfont.eot","hash":"3dfe8e557d9dfaf39bca088a02b76deb82dbaa3d","modified":1574254007956},{"_id":"themes/3-hexo/source/css/fonts/icomoon.svg","hash":"b5e7562c8494b0ddb3a70ecc5545ef7340d8e971","modified":1574254007955},{"_id":"themes/3-hexo/source/css/fonts/iconfont.ttf","hash":"aa087561480fb9c2cfd541e33d1e99d5ac1a56bb","modified":1574254007957},{"_id":"themes/3-hexo/source/css/fonts/iconfont.woff","hash":"f8ed131ccf13f4bdd3ec11fc3e997339dd7b66ba","modified":1574254007957},{"_id":"themes/3-hexo/source/css/fonts/iconfont.svg","hash":"7e54ae44c02faa319c4fe128e1e6bda38eae5c9d","modified":1574254007956},{"_id":"themes/3-hexo/source/css/hl_theme/brown-paper.styl","hash":"03af387edcc1cf8c18d12e9c440fd51b6cf425b6","modified":1574254007960},{"_id":"themes/3-hexo/source/css/hl_theme/atom-light.styl","hash":"69d184a682bcaeba2b180b437dc4431bc3be38aa","modified":1574254007959},{"_id":"themes/3-hexo/source/css/hl_theme/atom-dark.styl","hash":"f3eb4e5feda9cbd6242ccf44ca064e2979b5d719","modified":1574254007959},{"_id":"themes/3-hexo/source/css/fonts/selection.json","hash":"b6456a4eabcffd95e822d1d7adce96da524d481a","modified":1574254007958},{"_id":"themes/3-hexo/source/css/hl_theme/github-gist.styl","hash":"5e05b19832c1099bd9d284bc3ed00dc8a3d7ee23","modified":1574254007960},{"_id":"themes/3-hexo/source/css/hl_theme/darcula.styl","hash":"2bfc14f27ccca108b4b3755782de8366e8bd001e","modified":1574254007960},{"_id":"themes/3-hexo/source/css/hl_theme/github.styl","hash":"53276ff1f224f691dfe811e82c0af7f4476abf5d","modified":1574254007960},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-dark.styl","hash":"e9c190f9ffc37a13cac430512e4e0c760205be4a","modified":1574254007961},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-dark.styl","hash":"315ad610d303caba9eac80a7d51002193a15478a","modified":1574254007961},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-light.styl","hash":"1bece084b1dbbbd4af064f05feffd8c332b96a48","modified":1574254007961},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-light.styl","hash":"0c3ccd0d64e7504c7061d246dc32737f502f64e4","modified":1574254007962},{"_id":"themes/3-hexo/source/css/hl_theme/school-book.styl","hash":"51659351b391a2be5c68728bb51b7ad467c5e0db","modified":1574254007962},{"_id":"themes/3-hexo/source/css/hl_theme/railscasts.styl","hash":"a6e8cfd2202afd7893f5268f3437421e35066e7b","modified":1574254007962},{"_id":"themes/3-hexo/source/css/hl_theme/rainbow.styl","hash":"e5c37646a9d9c1094f9aab7a7c65a4b242e8db00","modified":1574254007962},{"_id":"themes/3-hexo/source/css/hl_theme/sublime.styl","hash":"501d75ef0f4385bea24d9b9b4cc434ba68d4be27","modified":1574254007963},{"_id":"themes/3-hexo/source/css/hl_theme/sunburst.styl","hash":"2aa9817e68fb2ed216781ea04b733039ebe18214","modified":1574254007963},{"_id":"themes/3-hexo/source/css/hl_theme/zenbum.styl","hash":"92941a6ae73b74f44ad7c559c5548c44073c644a","modified":1574254007963},{"_id":"source/_posts/java/book/20200130.md","hash":"570806f2b8d6fc2ffc0bcf9c0280cf044d34297b","modified":1580458748616},{"_id":"source/_posts/java/book/readme.md","hash":"9e4a217537b67db47f9be3953b34d57c1b54d8f0","modified":1580701473604},{"_id":"themes/3-hexo/source/js/gitment.js","hash":"67984b83cd46ff4300d4fd959bf6c17dd66b4136","modified":1574254007971},{"_id":"source/_posts/java/concurrency/post2/after_instruction_reorder.png","hash":"464c11e884745ada1d49265c95509c6f62e7947e","modified":1589976494947},{"_id":"source/_posts/java/concurrency/post2/before_instruciton_reorder.png","hash":"95546506dca75fce7ca5eaafb808dede1c16547c","modified":1589976494950},{"_id":"source/_posts/java/concurrency/post2/jvm_memory_model.md","hash":"8cc0b1b8e2654549c4d77dd8dbd7a5d475db8c19","modified":1590026454443},{"_id":"source/_posts/java/concurrency/post2/leader_speak.jpg","hash":"07fac9515a28904bbefca66eba7da27a4c5473b8","modified":1589976494953},{"_id":"source/_posts/java/concurrency/post1/post1.md","hash":"a7ba7ea13da9fa3b9db23d20afccbf0ac7d8ad44","modified":1590025544849},{"_id":"source/_posts/java/concurrency/post0/post0.md","hash":"a41ee4206e3fe0b95f5ada2891ba9614cef4373a","modified":1589699635985},{"_id":"source/_posts/java/concurrency/post2/memory_model_physical.pos","hash":"9cdfeb7992d029b646082a8412d42f35a24f65ff","modified":1589976494959},{"_id":"source/_posts/java/spring/post0/post0.md","hash":"d890118bd4104e5830daf7115204e0a9bda924ea","modified":1589700384696},{"_id":"source/_posts/java/jvm/post1/ConstantsPool.java","hash":"7eea4b872f6c126fb69bef08e57c6ce13d938ec5","modified":1580375056376},{"_id":"source/_posts/java/spring/post1/spring_post1_code_struct.png","hash":"a9e2bed479fe692e74cb588a6239427b1b444d8a","modified":1588927699172},{"_id":"source/_posts/java/jvm/post1/HeapOOM.java","hash":"c20ca6a4b82843307743d44abdf0b79a873554b7","modified":1580375056376},{"_id":"source/_posts/java/spring/post1/post1.md","hash":"91243117ccd1d5f4a9a0e98e74d0ea730dd42c8e","modified":1589363047233},{"_id":"source/_posts/java/jvm/post1/HeapOOM1.java","hash":"2b607db8590bec16abdefaf81b7e0fb7e53af815","modified":1580375056377},{"_id":"source/_posts/java/jvm/post0/post0.md","hash":"209cc1ed95b15bd9688ef89f0cfb2547be26abe9","modified":1580375056375},{"_id":"source/_posts/java/jvm/post0/HotSpot-architecture.jpg","hash":"c6be406d9ede267e76ab3d34544313c7c677f9ab","modified":1580375056372},{"_id":"source/_posts/java/jvm/post1/MetaSpaceOOM.java","hash":"2f938b421196d473b33b96e7cef9243aef96cbe6","modified":1580375056381},{"_id":"source/_posts/java/jvm/post1/StackOverFlowOOM.java","hash":"5384e1e835fbe4b66ae4755a9776f3b09dc9ec31","modified":1580375056383},{"_id":"source/_posts/java/jvm/post1/StackAllocation.java","hash":"2d6f7c952abb176e7dd2fd433caa5540a438e9ba","modified":1580375056382},{"_id":"source/_posts/java/jvm/post1/jvm_memory_model_1.5.png","hash":"00f81e6613147b382d0f835214066541fd736f6b","modified":1580375056386},{"_id":"source/_posts/java/jvm/post1/jvm_memory_model.png","hash":"457d528d6e7085a77bc05c616e6d47600d926521","modified":1580375056385},{"_id":"source/_posts/java/jvm/post1/jvm_memory_model_1.7.png","hash":"9f029d55a0f81bb72c39070bd55ac7c85c0ea33f","modified":1580375056387},{"_id":"source/_posts/java/jvm/post1/jvm_memory_model_1.8.png","hash":"e5e0a2798a065b161ff3064687d3b516f86e051a","modified":1580375056388},{"_id":"source/_posts/java/jvm/post1/post1.md","hash":"6f48d02bd549eb82660c8de38a1e6d0982875f91","modified":1580375056389},{"_id":"source/_posts/java/jvm/post1/stack-model.jpg","hash":"a4ef01cc6abdcd5a1f546c780337e395dd744371","modified":1580375056390},{"_id":"themes/3-hexo/source/js/gitalk.js","hash":"536f28c4354a13582af826d9d9b2cb27cec07dc6","modified":1574254007970},{"_id":"source/_posts/java/concurrency/post2/after_instruction_reorder.pos","hash":"9d7d6622c2cf530df2b819f65ff7a82e17539d78","modified":1589976494949},{"_id":"source/_posts/java/concurrency/post2/before_instruciton_reorder.pos","hash":"5304435b6074de2c8ba0815744a12536527a2d55","modified":1589976494952},{"_id":"source/_posts/java/jvm/post0/HotSpot虚拟机组件结构.pos","hash":"6122612c9ac6a86ea4639c43bcd88771f15d661c","modified":1580375056374},{"_id":"source/_posts/java/jvm/post1/栈帧信息.pos","hash":"e2aa655f4634b88ddfac2be666433d30d7031f7d","modified":1580375056391},{"_id":"source/_posts/java/spring/post1/cache_process_of_CD.jpg","hash":"4af55ce47f21c24006809911ca4c7265e23a796f","modified":1589356398414},{"_id":"source/_posts/java/spring/post1/bean_create_process_of_CD.pos","hash":"930892a1377e64b8cd71e0f6fb808e767285eb8d","modified":1589356601458},{"_id":"source/_posts/java/spring/post1/bean_create_process_of_CD.jpg","hash":"5cead9c3300f82318f3245bcd4e2c5747858e499","modified":1589353565198},{"_id":"source/_posts/java/spring/post1/cache_process_of_CD.pos","hash":"c817947b0f0cfeb75172ebdb8e3329ec893aeb16","modified":1589358277454},{"_id":"source/_posts/java/jvm/post1/JAVA运行时数据划分.pos","hash":"5fa8983b220ed70b210eef04c5a83a5992b0aace","modified":1580375056380},{"_id":"source/_posts/java/concurrency/post2/memory_model_physical.png","hash":"b6861c5fce14de8dba5138dd7a26ae0e86bf5872","modified":1589976494957}],"Category":[{"name":"book","_id":"ckag4s7qc00043oieg0dhcyn0"},{"name":"java并发","_id":"ckag4s7qo000a3oieayw0fprl"},{"name":"spring","_id":"ckag4s7qz000h3oieauwube26"},{"name":"java并发原理及实践","parent":"ckag4s7qo000a3oieayw0fprl","_id":"ckag4s7qz000i3oieagzt4aeq"},{"name":"jvm","_id":"ckag4s7r0000k3oie4uh03wqf"},{"name":"spring源码剖析系列","parent":"ckag4s7qz000h3oieauwube26","_id":"ckag4s7r2000p3oief0wvhbtw"},{"name":"java虚拟机，说点不一样的","parent":"ckag4s7r0000k3oie4uh03wqf","_id":"ckag4s7r3000v3oieguba4hf4"}],"Data":[],"Page":[{"title":"关于作者","date":"2017-09-27T02:27:42.000Z","_content":"### 个人简介\naworker，\n\n毕业于[东北哪所大学](http://www.neu.edu.cn/)，目前在贝壳找房从事java后端开发工作。\n\n喜欢研究新兴技术和未来发展方向，有任何疑问都欢迎你留言，留言必回。\n\n### 最近\n最近在写java虚拟机方面的文章\n\n\n### 联系方式\n- 邮箱 : lmyuanwork@163.com\n\n","source":"about/index.md","raw":"---\ntitle: 关于作者\ndate: 2017-09-27 10:27:42\n---\n### 个人简介\naworker，\n\n毕业于[东北哪所大学](http://www.neu.edu.cn/)，目前在贝壳找房从事java后端开发工作。\n\n喜欢研究新兴技术和未来发展方向，有任何疑问都欢迎你留言，留言必回。\n\n### 最近\n最近在写java虚拟机方面的文章\n\n\n### 联系方式\n- 邮箱 : lmyuanwork@163.com\n\n","updated":"2019-11-20T12:46:47.939Z","path":"about/index.html","comments":1,"layout":"page","_id":"ckag4s7ot00003oie7aordgph","content":"<h3 id=\"个人简介\"><a href=\"#个人简介\" class=\"headerlink\" title=\"个人简介\"></a>个人简介</h3><p>aworker，</p>\n<p>毕业于<a href=\"http://www.neu.edu.cn/\" target=\"_blank\" rel=\"noopener\">东北哪所大学</a>，目前在贝壳找房从事java后端开发工作。</p>\n<p>喜欢研究新兴技术和未来发展方向，有任何疑问都欢迎你留言，留言必回。</p>\n<h3 id=\"最近\"><a href=\"#最近\" class=\"headerlink\" title=\"最近\"></a>最近</h3><p>最近在写java虚拟机方面的文章</p>\n<h3 id=\"联系方式\"><a href=\"#联系方式\" class=\"headerlink\" title=\"联系方式\"></a>联系方式</h3><ul>\n<li>邮箱 : <a href=\"mailto:lmyuanwork@163.com\" target=\"_blank\" rel=\"noopener\">lmyuanwork@163.com</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"个人简介\"><a href=\"#个人简介\" class=\"headerlink\" title=\"个人简介\"></a>个人简介</h3><p>aworker，</p>\n<p>毕业于<a href=\"http://www.neu.edu.cn/\" target=\"_blank\" rel=\"noopener\">东北哪所大学</a>，目前在贝壳找房从事java后端开发工作。</p>\n<p>喜欢研究新兴技术和未来发展方向，有任何疑问都欢迎你留言，留言必回。</p>\n<h3 id=\"最近\"><a href=\"#最近\" class=\"headerlink\" title=\"最近\"></a>最近</h3><p>最近在写java虚拟机方面的文章</p>\n<h3 id=\"联系方式\"><a href=\"#联系方式\" class=\"headerlink\" title=\"联系方式\"></a>联系方式</h3><ul>\n<li>邮箱 : <a href=\"mailto:lmyuanwork@163.com\" target=\"_blank\" rel=\"noopener\">lmyuanwork@163.com</a></li>\n</ul>\n"},{"title":"categories","date":"2019-11-04T09:43:11.000Z","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2019-11-04 17:43:11\n---\n","updated":"2019-11-20T12:46:47.939Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ckag4s7pl00013oie8dx0grnb","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"绑架游戏","date":"2020-01-30T09:36:13.000Z","_content":"\n《绑架游戏》是我读的东野圭吾的第一篇小说，在这之前我是很少有看小说的爱好的。印象中最早接触的小说是自己在上小学亦或是初中的时候读的一本叫《说岳飞通俗演义》的书，当时家里的住房翻新借宿在自己的一个叔叔家里，刚好叔叔家里有这本小说，因为住的地方发生了变化，和儿时的伙伴接触的机会不是太多了，加上当时比物质生活更加贫瘠的精神生活，导致自己放学，放假后没有什么娱乐活动。这让自己在折磨完地里的蚂蚁和蟋蟀后，开始在饭后有机会看这本书。自己本来就比较喜欢历史类的书籍，所以很快就把这本书读完了。再后来接触到小说就是在上高中的时候，我的同位特别喜欢小说，印象中常常在上自习时，或者上课时他抱着一本砖头厚（参考《think in java》）的大书看，偶尔在课间他也会和我聊小说中的内容，我也在那个时候了解到《星辰变》、《神墓》、《小兵传奇》这类玄幻类小说，加上高中时候都是一些学习上不太上进的学生看小说，小说给我的印象就不太好，这种印象从高中持续到大学，研究生（研究生阶段我读完了 路遥的《平凡的世界》），和工作以后，直到2020年1月份的某个一天，在通往火车站的地铁上，我无意间在阅读app扫到这本《绑架游戏》。早在2018年就曾听过东野圭吾，当时有个同事非常喜欢他的作品，然后简单百度了下知道其是日本的一位比较有名的推理小说作家。然而真正让我感兴趣并且开始有意读其作品，就始于这部《绑架游戏》。\n\n《绑架游戏》介绍的是一位叫佐久间俊介的广告公司资深策划，在其策划案被甲方的副社长葛城胜俊否定后，心意阑珊之下去葛城府邸溜达时而引发的一场“绑架游戏”。俊介和葛城家的千金葛城树理演义一场被绑架人和绑架人一起谋划的绑架游戏，俊介通过细致的计算和高超的演技成功的报复了葛城胜俊——赢得了赎金且全身而退。但在随后的日子里发现真相可能并不是想他想的那样简单：情妇生养的葛城树理因为琐事和正妻生养的葛城千春发生口角而离家出走，俊介恰巧偶遇逃跑的树理，树理因为在家受尽歧视想报复葛城家，和恰好想报复葛城胜俊的俊介不谋而合，于是二人导演了这出绑架游戏。真相是出逃的并不是葛城树理，而是冒名葛城树理的葛城千春，而千春出逃的真实原因是自己因为琐事意外杀害了葛城树理，俊介以为自己是这出绑架大戏的导演，没想到自己只不过是千春和胜俊为掩盖千春杀人真相的一个棋子。在绑架游戏的过程中有好多意外和可疑事情发生，但都因为俊介的盲目自信与好强而没有及时收手，来终结这场游戏。当然如果仅仅是这样，这顶多会是一场被警察识破的恶作剧，但是俊介在绑架过程中爱上了千春导致了致命性的结果——俊介被千春和胜俊有意刻画成一个索要赎金得逞后还强奸并杀害树理的凶手。但也正是因为自己爱上了千春后无意拍摄的一张照片让自己和葛城家保持着一种动态平衡，自己才免于遭人杀害...\n\n目前阅读过东野圭吾两部作品，其写作风格都是前期平淡无奇的叙述和后期真相的急剧翻转，作者通过前期看似无意的“无心插柳”般的伏笔到后期的“串线成林”让人不禁惊叹于作者精细秒的构思和强大的文字功力，希望2020年能有时间阅读其大作《白夜行》。武汉加油！天佑中华！\n\n\n","source":"_posts/java/book/20200130.md","raw":"---\ntitle: 绑架游戏\ndate: 2020-01-30 17:36:13\ncategories:\n    - book\ntags:\n---\n\n《绑架游戏》是我读的东野圭吾的第一篇小说，在这之前我是很少有看小说的爱好的。印象中最早接触的小说是自己在上小学亦或是初中的时候读的一本叫《说岳飞通俗演义》的书，当时家里的住房翻新借宿在自己的一个叔叔家里，刚好叔叔家里有这本小说，因为住的地方发生了变化，和儿时的伙伴接触的机会不是太多了，加上当时比物质生活更加贫瘠的精神生活，导致自己放学，放假后没有什么娱乐活动。这让自己在折磨完地里的蚂蚁和蟋蟀后，开始在饭后有机会看这本书。自己本来就比较喜欢历史类的书籍，所以很快就把这本书读完了。再后来接触到小说就是在上高中的时候，我的同位特别喜欢小说，印象中常常在上自习时，或者上课时他抱着一本砖头厚（参考《think in java》）的大书看，偶尔在课间他也会和我聊小说中的内容，我也在那个时候了解到《星辰变》、《神墓》、《小兵传奇》这类玄幻类小说，加上高中时候都是一些学习上不太上进的学生看小说，小说给我的印象就不太好，这种印象从高中持续到大学，研究生（研究生阶段我读完了 路遥的《平凡的世界》），和工作以后，直到2020年1月份的某个一天，在通往火车站的地铁上，我无意间在阅读app扫到这本《绑架游戏》。早在2018年就曾听过东野圭吾，当时有个同事非常喜欢他的作品，然后简单百度了下知道其是日本的一位比较有名的推理小说作家。然而真正让我感兴趣并且开始有意读其作品，就始于这部《绑架游戏》。\n\n《绑架游戏》介绍的是一位叫佐久间俊介的广告公司资深策划，在其策划案被甲方的副社长葛城胜俊否定后，心意阑珊之下去葛城府邸溜达时而引发的一场“绑架游戏”。俊介和葛城家的千金葛城树理演义一场被绑架人和绑架人一起谋划的绑架游戏，俊介通过细致的计算和高超的演技成功的报复了葛城胜俊——赢得了赎金且全身而退。但在随后的日子里发现真相可能并不是想他想的那样简单：情妇生养的葛城树理因为琐事和正妻生养的葛城千春发生口角而离家出走，俊介恰巧偶遇逃跑的树理，树理因为在家受尽歧视想报复葛城家，和恰好想报复葛城胜俊的俊介不谋而合，于是二人导演了这出绑架游戏。真相是出逃的并不是葛城树理，而是冒名葛城树理的葛城千春，而千春出逃的真实原因是自己因为琐事意外杀害了葛城树理，俊介以为自己是这出绑架大戏的导演，没想到自己只不过是千春和胜俊为掩盖千春杀人真相的一个棋子。在绑架游戏的过程中有好多意外和可疑事情发生，但都因为俊介的盲目自信与好强而没有及时收手，来终结这场游戏。当然如果仅仅是这样，这顶多会是一场被警察识破的恶作剧，但是俊介在绑架过程中爱上了千春导致了致命性的结果——俊介被千春和胜俊有意刻画成一个索要赎金得逞后还强奸并杀害树理的凶手。但也正是因为自己爱上了千春后无意拍摄的一张照片让自己和葛城家保持着一种动态平衡，自己才免于遭人杀害...\n\n目前阅读过东野圭吾两部作品，其写作风格都是前期平淡无奇的叙述和后期真相的急剧翻转，作者通过前期看似无意的“无心插柳”般的伏笔到后期的“串线成林”让人不禁惊叹于作者精细秒的构思和强大的文字功力，希望2020年能有时间阅读其大作《白夜行》。武汉加油！天佑中华！\n\n\n","slug":"java/book/20200130","published":1,"updated":"2020-01-31T08:19:08.616Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckag4s7q800023oiehzpy40qr","content":"<p>《绑架游戏》是我读的东野圭吾的第一篇小说，在这之前我是很少有看小说的爱好的。印象中最早接触的小说是自己在上小学亦或是初中的时候读的一本叫《说岳飞通俗演义》的书，当时家里的住房翻新借宿在自己的一个叔叔家里，刚好叔叔家里有这本小说，因为住的地方发生了变化，和儿时的伙伴接触的机会不是太多了，加上当时比物质生活更加贫瘠的精神生活，导致自己放学，放假后没有什么娱乐活动。这让自己在折磨完地里的蚂蚁和蟋蟀后，开始在饭后有机会看这本书。自己本来就比较喜欢历史类的书籍，所以很快就把这本书读完了。再后来接触到小说就是在上高中的时候，我的同位特别喜欢小说，印象中常常在上自习时，或者上课时他抱着一本砖头厚（参考《think in java》）的大书看，偶尔在课间他也会和我聊小说中的内容，我也在那个时候了解到《星辰变》、《神墓》、《小兵传奇》这类玄幻类小说，加上高中时候都是一些学习上不太上进的学生看小说，小说给我的印象就不太好，这种印象从高中持续到大学，研究生（研究生阶段我读完了 路遥的《平凡的世界》），和工作以后，直到2020年1月份的某个一天，在通往火车站的地铁上，我无意间在阅读app扫到这本《绑架游戏》。早在2018年就曾听过东野圭吾，当时有个同事非常喜欢他的作品，然后简单百度了下知道其是日本的一位比较有名的推理小说作家。然而真正让我感兴趣并且开始有意读其作品，就始于这部《绑架游戏》。</p>\n<p>《绑架游戏》介绍的是一位叫佐久间俊介的广告公司资深策划，在其策划案被甲方的副社长葛城胜俊否定后，心意阑珊之下去葛城府邸溜达时而引发的一场“绑架游戏”。俊介和葛城家的千金葛城树理演义一场被绑架人和绑架人一起谋划的绑架游戏，俊介通过细致的计算和高超的演技成功的报复了葛城胜俊——赢得了赎金且全身而退。但在随后的日子里发现真相可能并不是想他想的那样简单：情妇生养的葛城树理因为琐事和正妻生养的葛城千春发生口角而离家出走，俊介恰巧偶遇逃跑的树理，树理因为在家受尽歧视想报复葛城家，和恰好想报复葛城胜俊的俊介不谋而合，于是二人导演了这出绑架游戏。真相是出逃的并不是葛城树理，而是冒名葛城树理的葛城千春，而千春出逃的真实原因是自己因为琐事意外杀害了葛城树理，俊介以为自己是这出绑架大戏的导演，没想到自己只不过是千春和胜俊为掩盖千春杀人真相的一个棋子。在绑架游戏的过程中有好多意外和可疑事情发生，但都因为俊介的盲目自信与好强而没有及时收手，来终结这场游戏。当然如果仅仅是这样，这顶多会是一场被警察识破的恶作剧，但是俊介在绑架过程中爱上了千春导致了致命性的结果——俊介被千春和胜俊有意刻画成一个索要赎金得逞后还强奸并杀害树理的凶手。但也正是因为自己爱上了千春后无意拍摄的一张照片让自己和葛城家保持着一种动态平衡，自己才免于遭人杀害…</p>\n<p>目前阅读过东野圭吾两部作品，其写作风格都是前期平淡无奇的叙述和后期真相的急剧翻转，作者通过前期看似无意的“无心插柳”般的伏笔到后期的“串线成林”让人不禁惊叹于作者精细秒的构思和强大的文字功力，希望2020年能有时间阅读其大作《白夜行》。武汉加油！天佑中华！</p>\n","site":{"data":{}},"excerpt":"","more":"<p>《绑架游戏》是我读的东野圭吾的第一篇小说，在这之前我是很少有看小说的爱好的。印象中最早接触的小说是自己在上小学亦或是初中的时候读的一本叫《说岳飞通俗演义》的书，当时家里的住房翻新借宿在自己的一个叔叔家里，刚好叔叔家里有这本小说，因为住的地方发生了变化，和儿时的伙伴接触的机会不是太多了，加上当时比物质生活更加贫瘠的精神生活，导致自己放学，放假后没有什么娱乐活动。这让自己在折磨完地里的蚂蚁和蟋蟀后，开始在饭后有机会看这本书。自己本来就比较喜欢历史类的书籍，所以很快就把这本书读完了。再后来接触到小说就是在上高中的时候，我的同位特别喜欢小说，印象中常常在上自习时，或者上课时他抱着一本砖头厚（参考《think in java》）的大书看，偶尔在课间他也会和我聊小说中的内容，我也在那个时候了解到《星辰变》、《神墓》、《小兵传奇》这类玄幻类小说，加上高中时候都是一些学习上不太上进的学生看小说，小说给我的印象就不太好，这种印象从高中持续到大学，研究生（研究生阶段我读完了 路遥的《平凡的世界》），和工作以后，直到2020年1月份的某个一天，在通往火车站的地铁上，我无意间在阅读app扫到这本《绑架游戏》。早在2018年就曾听过东野圭吾，当时有个同事非常喜欢他的作品，然后简单百度了下知道其是日本的一位比较有名的推理小说作家。然而真正让我感兴趣并且开始有意读其作品，就始于这部《绑架游戏》。</p>\n<p>《绑架游戏》介绍的是一位叫佐久间俊介的广告公司资深策划，在其策划案被甲方的副社长葛城胜俊否定后，心意阑珊之下去葛城府邸溜达时而引发的一场“绑架游戏”。俊介和葛城家的千金葛城树理演义一场被绑架人和绑架人一起谋划的绑架游戏，俊介通过细致的计算和高超的演技成功的报复了葛城胜俊——赢得了赎金且全身而退。但在随后的日子里发现真相可能并不是想他想的那样简单：情妇生养的葛城树理因为琐事和正妻生养的葛城千春发生口角而离家出走，俊介恰巧偶遇逃跑的树理，树理因为在家受尽歧视想报复葛城家，和恰好想报复葛城胜俊的俊介不谋而合，于是二人导演了这出绑架游戏。真相是出逃的并不是葛城树理，而是冒名葛城树理的葛城千春，而千春出逃的真实原因是自己因为琐事意外杀害了葛城树理，俊介以为自己是这出绑架大戏的导演，没想到自己只不过是千春和胜俊为掩盖千春杀人真相的一个棋子。在绑架游戏的过程中有好多意外和可疑事情发生，但都因为俊介的盲目自信与好强而没有及时收手，来终结这场游戏。当然如果仅仅是这样，这顶多会是一场被警察识破的恶作剧，但是俊介在绑架过程中爱上了千春导致了致命性的结果——俊介被千春和胜俊有意刻画成一个索要赎金得逞后还强奸并杀害树理的凶手。但也正是因为自己爱上了千春后无意拍摄的一张照片让自己和葛城家保持着一种动态平衡，自己才免于遭人杀害…</p>\n<p>目前阅读过东野圭吾两部作品，其写作风格都是前期平淡无奇的叙述和后期真相的急剧翻转，作者通过前期看似无意的“无心插柳”般的伏笔到后期的“串线成林”让人不禁惊叹于作者精细秒的构思和强大的文字功力，希望2020年能有时间阅读其大作《白夜行》。武汉加油！天佑中华！</p>\n"},{"title":"我的读书清单","date":"2020-01-30T07:36:13.000Z","_content":"\n# 为什么要读书\n\n2019年，对我来说是一个有重大变革的一年。自己倒了三十而立的年龄，却没有“而立”的能力，回想起自己从2017年2月份开始工作到现在，竟然依旧过的浑浑噩噩，事业上没有多少进步，感情生活还是毫无起色，本以为自己就这样乐知天命的过下去，但是每每听到和自己一样的草根阶层在通过自己的努力实现阶层跨越时内心总有一些除去羡慕以外情愫；每每浏览别人的技术博客看到许多大牛在比自己厉害还比自己努力的时候心中也总有除惭愧以外的思绪。可是自己总是缺少一些来自心底的“呐喊”来唤醒自己，告诉我这到底是什么。直到有一天听到这样一条宣传标语：“人为什么要读书？读书代表着你对现实生活的不甘，代表着你对诗和远方的向往”。一种醍醐灌顶的感觉油然而生，我想自己那么飘忽不定的情愫和思绪就是 **不甘**。自己从小学的门门一百分，梦想成为科学家；到中学的年级名列前茅，立志做对生活有重大影响之人；在到大学时代的中等上游，奢望毕业能拿到12k的月薪...。《论语》里面有句话说的特别好“取乎其上，得乎其中；取乎其中，得乎其下；取乎其下，则无所得矣。”，说的就是人们在制定标准时一定要高于自己的需求，且努力实现高于需求的标准，而只有这样，才能得到自己本想得到需求。自己并不是愚笨到无可救药的程度，而是自己指定的目标并不高于自己的需求，也不严格执行自己的目标。“读书万卷书”就是自己从青年时，从心底就有的一个目标。但是从大学到工作以来，自己做的差强人意。倒不是说自己从毕业到现在没有读过书，只不过很少有计划的读书，也没能将自己读过的书罗列出来存底来填充自己的底气。而对于书籍中的知识这样的抽象慰藉，是缺少一种可以度量的标准的，这将导致自己在读书方面的付出没办法具化，难易形成正向激励，这对自己实现未来的读书标准显然是不利的，为此在自己的个人技术博客上列一个小小读书清单，希望能帮助自己养成有计划读书的好习惯，来抚平自己不甘的心。2020，必将自强。\n\n# 我的读书清单\n\n## 2020年书单\n\n1、[绑架游戏](http://aworker.cn/2020/01/30/java/book/20200130/)\n\n2、[恶意]()\n\n## 2019年书单\n\n1、[Java Concurrency In Practice]()","source":"_posts/java/book/readme.md","raw":"---\ntitle: 我的读书清单\ndate: 2020-01-30 15:36:13\ncategories:\n    - book\ntags:\n---\n\n# 为什么要读书\n\n2019年，对我来说是一个有重大变革的一年。自己倒了三十而立的年龄，却没有“而立”的能力，回想起自己从2017年2月份开始工作到现在，竟然依旧过的浑浑噩噩，事业上没有多少进步，感情生活还是毫无起色，本以为自己就这样乐知天命的过下去，但是每每听到和自己一样的草根阶层在通过自己的努力实现阶层跨越时内心总有一些除去羡慕以外情愫；每每浏览别人的技术博客看到许多大牛在比自己厉害还比自己努力的时候心中也总有除惭愧以外的思绪。可是自己总是缺少一些来自心底的“呐喊”来唤醒自己，告诉我这到底是什么。直到有一天听到这样一条宣传标语：“人为什么要读书？读书代表着你对现实生活的不甘，代表着你对诗和远方的向往”。一种醍醐灌顶的感觉油然而生，我想自己那么飘忽不定的情愫和思绪就是 **不甘**。自己从小学的门门一百分，梦想成为科学家；到中学的年级名列前茅，立志做对生活有重大影响之人；在到大学时代的中等上游，奢望毕业能拿到12k的月薪...。《论语》里面有句话说的特别好“取乎其上，得乎其中；取乎其中，得乎其下；取乎其下，则无所得矣。”，说的就是人们在制定标准时一定要高于自己的需求，且努力实现高于需求的标准，而只有这样，才能得到自己本想得到需求。自己并不是愚笨到无可救药的程度，而是自己指定的目标并不高于自己的需求，也不严格执行自己的目标。“读书万卷书”就是自己从青年时，从心底就有的一个目标。但是从大学到工作以来，自己做的差强人意。倒不是说自己从毕业到现在没有读过书，只不过很少有计划的读书，也没能将自己读过的书罗列出来存底来填充自己的底气。而对于书籍中的知识这样的抽象慰藉，是缺少一种可以度量的标准的，这将导致自己在读书方面的付出没办法具化，难易形成正向激励，这对自己实现未来的读书标准显然是不利的，为此在自己的个人技术博客上列一个小小读书清单，希望能帮助自己养成有计划读书的好习惯，来抚平自己不甘的心。2020，必将自强。\n\n# 我的读书清单\n\n## 2020年书单\n\n1、[绑架游戏](http://aworker.cn/2020/01/30/java/book/20200130/)\n\n2、[恶意]()\n\n## 2019年书单\n\n1、[Java Concurrency In Practice]()","slug":"java/book/readme","published":1,"updated":"2020-02-03T03:44:33.604Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckag4s7qb00033oie0fq099vx","content":"<h1 id=\"为什么要读书\"><a href=\"#为什么要读书\" class=\"headerlink\" title=\"为什么要读书\"></a>为什么要读书</h1><p>2019年，对我来说是一个有重大变革的一年。自己倒了三十而立的年龄，却没有“而立”的能力，回想起自己从2017年2月份开始工作到现在，竟然依旧过的浑浑噩噩，事业上没有多少进步，感情生活还是毫无起色，本以为自己就这样乐知天命的过下去，但是每每听到和自己一样的草根阶层在通过自己的努力实现阶层跨越时内心总有一些除去羡慕以外情愫；每每浏览别人的技术博客看到许多大牛在比自己厉害还比自己努力的时候心中也总有除惭愧以外的思绪。可是自己总是缺少一些来自心底的“呐喊”来唤醒自己，告诉我这到底是什么。直到有一天听到这样一条宣传标语：“人为什么要读书？读书代表着你对现实生活的不甘，代表着你对诗和远方的向往”。一种醍醐灌顶的感觉油然而生，我想自己那么飘忽不定的情愫和思绪就是 <strong>不甘</strong>。自己从小学的门门一百分，梦想成为科学家；到中学的年级名列前茅，立志做对生活有重大影响之人；在到大学时代的中等上游，奢望毕业能拿到12k的月薪…。《论语》里面有句话说的特别好“取乎其上，得乎其中；取乎其中，得乎其下；取乎其下，则无所得矣。”，说的就是人们在制定标准时一定要高于自己的需求，且努力实现高于需求的标准，而只有这样，才能得到自己本想得到需求。自己并不是愚笨到无可救药的程度，而是自己指定的目标并不高于自己的需求，也不严格执行自己的目标。“读书万卷书”就是自己从青年时，从心底就有的一个目标。但是从大学到工作以来，自己做的差强人意。倒不是说自己从毕业到现在没有读过书，只不过很少有计划的读书，也没能将自己读过的书罗列出来存底来填充自己的底气。而对于书籍中的知识这样的抽象慰藉，是缺少一种可以度量的标准的，这将导致自己在读书方面的付出没办法具化，难易形成正向激励，这对自己实现未来的读书标准显然是不利的，为此在自己的个人技术博客上列一个小小读书清单，希望能帮助自己养成有计划读书的好习惯，来抚平自己不甘的心。2020，必将自强。</p>\n<h1 id=\"我的读书清单\"><a href=\"#我的读书清单\" class=\"headerlink\" title=\"我的读书清单\"></a>我的读书清单</h1><h2 id=\"2020年书单\"><a href=\"#2020年书单\" class=\"headerlink\" title=\"2020年书单\"></a>2020年书单</h2><p>1、<a href=\"http://aworker.cn/2020/01/30/java/book/20200130/\">绑架游戏</a></p>\n<p>2、<a href=\"\">恶意</a></p>\n<h2 id=\"2019年书单\"><a href=\"#2019年书单\" class=\"headerlink\" title=\"2019年书单\"></a>2019年书单</h2><p>1、<a href=\"\">Java Concurrency In Practice</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"为什么要读书\"><a href=\"#为什么要读书\" class=\"headerlink\" title=\"为什么要读书\"></a>为什么要读书</h1><p>2019年，对我来说是一个有重大变革的一年。自己倒了三十而立的年龄，却没有“而立”的能力，回想起自己从2017年2月份开始工作到现在，竟然依旧过的浑浑噩噩，事业上没有多少进步，感情生活还是毫无起色，本以为自己就这样乐知天命的过下去，但是每每听到和自己一样的草根阶层在通过自己的努力实现阶层跨越时内心总有一些除去羡慕以外情愫；每每浏览别人的技术博客看到许多大牛在比自己厉害还比自己努力的时候心中也总有除惭愧以外的思绪。可是自己总是缺少一些来自心底的“呐喊”来唤醒自己，告诉我这到底是什么。直到有一天听到这样一条宣传标语：“人为什么要读书？读书代表着你对现实生活的不甘，代表着你对诗和远方的向往”。一种醍醐灌顶的感觉油然而生，我想自己那么飘忽不定的情愫和思绪就是 <strong>不甘</strong>。自己从小学的门门一百分，梦想成为科学家；到中学的年级名列前茅，立志做对生活有重大影响之人；在到大学时代的中等上游，奢望毕业能拿到12k的月薪…。《论语》里面有句话说的特别好“取乎其上，得乎其中；取乎其中，得乎其下；取乎其下，则无所得矣。”，说的就是人们在制定标准时一定要高于自己的需求，且努力实现高于需求的标准，而只有这样，才能得到自己本想得到需求。自己并不是愚笨到无可救药的程度，而是自己指定的目标并不高于自己的需求，也不严格执行自己的目标。“读书万卷书”就是自己从青年时，从心底就有的一个目标。但是从大学到工作以来，自己做的差强人意。倒不是说自己从毕业到现在没有读过书，只不过很少有计划的读书，也没能将自己读过的书罗列出来存底来填充自己的底气。而对于书籍中的知识这样的抽象慰藉，是缺少一种可以度量的标准的，这将导致自己在读书方面的付出没办法具化，难易形成正向激励，这对自己实现未来的读书标准显然是不利的，为此在自己的个人技术博客上列一个小小读书清单，希望能帮助自己养成有计划读书的好习惯，来抚平自己不甘的心。2020，必将自强。</p>\n<h1 id=\"我的读书清单\"><a href=\"#我的读书清单\" class=\"headerlink\" title=\"我的读书清单\"></a>我的读书清单</h1><h2 id=\"2020年书单\"><a href=\"#2020年书单\" class=\"headerlink\" title=\"2020年书单\"></a>2020年书单</h2><p>1、<a href=\"http://aworker.cn/2020/01/30/java/book/20200130/\">绑架游戏</a></p>\n<p>2、<a href=\"\">恶意</a></p>\n<h2 id=\"2019年书单\"><a href=\"#2019年书单\" class=\"headerlink\" title=\"2019年书单\"></a>2019年书单</h2><p>1、<a href=\"\">Java Concurrency In Practice</a></p>\n"},{"title":"02 java并发编程正确性问题","date":"2020-05-20T12:06:13.000Z","_content":"\n> “如欲征服java并发，需先征服java内存模型，如欲征服java内存模型，需先征服计算机内存模型” -糖炒甜板栗.\n\n![大佬讲话](https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/concurrency/post2/leader_speak.jpg)\n\n咳！咳！，大家都记做笔记了吧。虽然栗子不是什么大佬，但是这句话说的还是没有毛病的。不了解java的内存模型，就不会从根上理解java并发的一些行为和机制，而java内存模型毕竟是jvm模拟出来的一部分，其底子还是建立在现代计算机的物理内存模型上来的，所以我们就按照现代计算机的物理内存模型、java内存模型的顺序来仔细介绍，为彻底了解java并发机制打下底子。\n<!-- more -->\n现代计算机的物理内存模型：\n![现代计算机的物理内存模型](https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/concurrency/post2/memory_model_physical.png)\n现在计算机最少的都是应该是两核心了，当然我们也经常在买个人电脑的时候听过四核四线程、四核八线程等，可以说现在个人电脑标配都是四核心了，为了方便上图只是列举了2个核心。现代计算机的内存在逻辑上还是一块。有人可能问不对啊，我电脑就插了两块内存，但是操作系统会把两块内存的地址统一抽象，比如每一块的内存是2048MB地址是000000000000-011111111111MB，两块就是0000000000000-0111111111111MB，操作系统会统一编址。所以整体上看还是一块内存。因为CPU的操作速度太快，如果让CPU直接操作内存，那么久是对CPU资源的一种巨大浪费，为了解决这个问题现在计算机都给CPU加上缓存，比如一级缓存，二级缓存，甚至三级缓存。缓存速度比内存快，但是是还是赶不上CPU的数据级别，所以在缓存和CPU之间又有了register,register的存储速度比缓存就快了好多了。\n存储速度上有如下关系：\nregister > 一级缓存 > 二级缓存 > ... > n级缓存 > 内存\n容量上一般有如下关系：\n内存 > n级缓存 > ... > 二级缓存 > 一级缓存 > register\n之所以可以用缓存和register来缓解CPU和内存之间巨大的速度差别是基于如下原理：\n\n** CPU访问过的内存地址，很有可能在短时间内会被再次访问。 **  \n所以，比如CPU访问了地址为0x001fffff的内存地址，如果没有缓存和register，那么CPU再下次访问这个内存地址的时候就还要去内存读，但是如果有缓存，缓存会把CPU访问过的数据先存储起来，等CPU待会再找地址为0x001fffff的内存地址时候，发现其在缓存中就存在了，那么好了，这就不用在访问内存了。速度自然就提升了。这就涉及到计算机组成原理的知识了，如果想了解可以google一下，这里就不在做更深的介绍了到这里就够用了。\n了解现代计算机物理内存模型工作原理后，那么再理解多线程开发中最关系的三个概念就有的放矢了。先介绍下三个概念：\n\n1. ** 操作原子性 **：一个操作要么全做，要么全不做，那么这个操作就符合原子性。比如你给你老婆银行卡转500块钱，就包括两个操作，自己账户先减500，你老婆账户加500。但是这个转账操作应该满足原子性。如果银行只执行了你自己账户的扣钱操作，没有执行给你老婆账户的加钱操作。丢了500块钱是小事，被老婆大人罚跪搓衣板可就不得了了。所以你自己账户减钱，老婆账户加钱，这两个操作要么都做了，要么都别做。例如如下操作：\n ``` \n a = a + 1; \n ```\n 结合我们上述的现代计算机的内存模型，计算机执行a=a+1时候会分成三个原子性操作：\n 1. 把a的值（比如4）从内存中取出放到CPU的缓存系统中\n 2. 从缓存系统中取出a的值加1（4+1）得到新结果\n 3. 把新结果存回到内存中\n\n 一个“a=a+1”操作计算机中被拆分成三个原子性操作，那么完全可以出现CPU执行完1.操作后，去执行别的操作了。这就是并发操作原子性问题的根本来源。\n\n2. ** 操作有序性 **：例如如下代码： \n ```\n public class A {\n    public int a;\n    public boolean b = false;\n\n    public void methodA(){\n        a = 3;\n        b = true;\n        a = a + 1;\n    }\n\n    public void methodB(){\n        a = 3;\n        b = (a == 4);\n        a = a + 1;\n    }\n } \n ```\n methodA方法代码先经过java编译器编译成字节码，然后字节码然后被操作系统解释成机器指令，在这个解释过程中，操作系统可能发现，咦？在给变量b赋值为true后又操作了a变量，干脆我操作系统自己改改执行顺序，把对a变量的两个操作都执行完，然后再执行对b的操作,这就叫**指令重排序**。这样就会节省操作时间,如下图没有进行指令重排序时：\n ![没有指令重排序](https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java-memory-model/before_instruciton_reorder.png)\n 图中CPU和缓存系统要进行9次通信，缓存系统和内存要通信7次，假设cpu和缓存系统通信一次用时1ms，缓存系统和内存通信一次用时10ms，那么总用时 9乘1 + 7乘10 = 79ms。经过指令重排序后，总共用时  6乘1 + 6乘10 = 66ms 如下图所示：\n ![有指令重排序](https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java-memory-model/after_instruction_reorder.png)\n 经过指令重排序的确可以提程序运行效率，所以现代计算机都会对指令进行重排序，但是这种重排序也不是无脑重排序，重排序的基础是前后语句不存在依赖关系时，才有可能发生指令重排序。所以A类的methodB方法不会发生指令重排序。指令重排序在单线程环境里面这不会有什么问题，但是多线程中就可能发生意外。比如线程1中执行如下代码：\n ```\n instance.methodA();\n ```\n 另一个线程2执行如下代码：\n ```\n while(instance.a != 4){ //a只要不等4，线程就让出CPU，等待调度器再次执行此线程\n \tThread.yield(); //让出CPU，线程进入就绪态\n }\n System.out.print(instance.b);\n ```\n 其中instance是A类的一个实例。如果线程1 发生了指令重排序， 那么这线程2的打印结果很有可能是false,这就和我们对代码的直观观察结果出处很大。如果线上产品出错的原因是指令重排序导致的，几乎不能可能排查出来。\n\n3. **操作可见性 ** :\n 在“操作有序性” 中的线程线程2 ，还有可能会没有任何输出结果。因为线程2  要想有输出必须要满足instance.a =4,但这是在线程1中调用methodA 方法后instance.a 的值才为4 。而要想让线程2 看到这个新值，必须要把线程1的修改及时写回内存， 同时通知线程2 存在缓存系统中的instance.a值已经过期，需要去内存中获取最新值。如果我们的类A和线程1、线程2调用的代码没有特殊的声明，那么操作系统不能保证上述过程一定发生。即可能发生线程1对instance.a的修改对线程2不一定可见,这就是操作的可见性问题。\n\n### java多线程的所有问题都植根于“操作原子性”、“操作有序性”、“操作可见性”而引发的。\n上面介绍了现代计算机的内存模型以及其引起的在并发编程的三个问题，下面来介绍下java的内存模型。java为了实现其夸平台的特性，使用了一种虚拟机技术，java程序运行在这虚拟机上，那么不管你是windows系统，linux系统，unix系统，只要我java虚拟机屏蔽一切操作系统带来的差异，向java程序提供专用的、各系统无差别的虚拟机，那么java程序员就不需要关心底层到底是什么操作系统了。对于int类型的变量其取值范围永远是 -2^31 -1 至 2^31，即4个字节。但是对C\\C++,这个操作系统的int可能是4字节，那个可能是8字节。C++程序员跨平台写代码，痛苦异常。这个给我们编程带来极大方便的虚拟机就是大名鼎鼎的JVM(Java Virtual Machine)。既然是虚拟机那么就需要模拟真正物理机的所有设备，像CPU，网络，存储等。和我们程序员最密切的就是JVM的存储，这就是java内存模型(Java Memory Model 简称JMM)。有别于我们真实的物理存储模型，JMM把存储分为线程栈区和堆区。在JVM中的每个线程都有自己独立的线程栈，而堆区用来存储java的对象实例。java中各种变量的存储有一下规则：\n 1. 成员变量一定存储在堆区。\n 2. 局部变量如果是基本数据类型存储在线程栈中，如果是非基本数据类型存储，其引用存储在线程栈中，但具体的对象实例还是存储在栈中。\n \n因为java内存模型是在具体的物理内存模型的基础上实现的，并且为了运行效率，java也支持指令重排序。所以java并发编程也有“原子性”、“有序性”、“可见性”三个问题。但是，我们的JMM也不是白吃干饭什么也做的，最起码运行在JVM上的代码就具备8个内存特性，来使得java代码有一定的“有序性”和“可见性”。这些特性也被称为 **happen-before原则**。下面先列举这个八个内存特性，详细介绍请看[<font color=green> java happen-before原则最全最易懂介绍</font>](www.baidu.com)。\n八大happen-before 特性：\n* 单线程happen-before原则：在同一个线程中，书写在前面的操作happen-before后面的操作。\n* 锁的happen-before原则：**同一个锁**的unlock操作happen-before此锁的lock操作。\n* volatile的happen-before原则：对一个volatile变量的写操作happen-before对此变量的任意操作(当然也包括写操作了)。\n* happen-before的传递性原则：如果A操作 happen-before B操作，B操作happen-before C操作，那么A操作happen-before B操作。\n* 线程启动的happen-before原则：同一个线程的start方法happen-before此线程的其它方法。\n* 线程中断的happen-before原则：对线程interrupt方法的调用happen-before被中断线程的检测到中断发送的代码。\n* 线程终结的happen-before原则：线程中的所有操作都happen-before线程的终止检测。\n* 对象创建的happen-before原则：一个对象的初始化完成先于他的finalize方法调用。","source":"_posts/java/concurrency/post2/jvm_memory_model.md","raw":"---\ntitle: 02 java并发编程正确性问题\ndate: 2020-05-20 20:06:13\ncategories:\n    - java并发\n    - java并发原理及实践\ntags:\n---\n\n> “如欲征服java并发，需先征服java内存模型，如欲征服java内存模型，需先征服计算机内存模型” -糖炒甜板栗.\n\n![大佬讲话](https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/concurrency/post2/leader_speak.jpg)\n\n咳！咳！，大家都记做笔记了吧。虽然栗子不是什么大佬，但是这句话说的还是没有毛病的。不了解java的内存模型，就不会从根上理解java并发的一些行为和机制，而java内存模型毕竟是jvm模拟出来的一部分，其底子还是建立在现代计算机的物理内存模型上来的，所以我们就按照现代计算机的物理内存模型、java内存模型的顺序来仔细介绍，为彻底了解java并发机制打下底子。\n<!-- more -->\n现代计算机的物理内存模型：\n![现代计算机的物理内存模型](https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/concurrency/post2/memory_model_physical.png)\n现在计算机最少的都是应该是两核心了，当然我们也经常在买个人电脑的时候听过四核四线程、四核八线程等，可以说现在个人电脑标配都是四核心了，为了方便上图只是列举了2个核心。现代计算机的内存在逻辑上还是一块。有人可能问不对啊，我电脑就插了两块内存，但是操作系统会把两块内存的地址统一抽象，比如每一块的内存是2048MB地址是000000000000-011111111111MB，两块就是0000000000000-0111111111111MB，操作系统会统一编址。所以整体上看还是一块内存。因为CPU的操作速度太快，如果让CPU直接操作内存，那么久是对CPU资源的一种巨大浪费，为了解决这个问题现在计算机都给CPU加上缓存，比如一级缓存，二级缓存，甚至三级缓存。缓存速度比内存快，但是是还是赶不上CPU的数据级别，所以在缓存和CPU之间又有了register,register的存储速度比缓存就快了好多了。\n存储速度上有如下关系：\nregister > 一级缓存 > 二级缓存 > ... > n级缓存 > 内存\n容量上一般有如下关系：\n内存 > n级缓存 > ... > 二级缓存 > 一级缓存 > register\n之所以可以用缓存和register来缓解CPU和内存之间巨大的速度差别是基于如下原理：\n\n** CPU访问过的内存地址，很有可能在短时间内会被再次访问。 **  \n所以，比如CPU访问了地址为0x001fffff的内存地址，如果没有缓存和register，那么CPU再下次访问这个内存地址的时候就还要去内存读，但是如果有缓存，缓存会把CPU访问过的数据先存储起来，等CPU待会再找地址为0x001fffff的内存地址时候，发现其在缓存中就存在了，那么好了，这就不用在访问内存了。速度自然就提升了。这就涉及到计算机组成原理的知识了，如果想了解可以google一下，这里就不在做更深的介绍了到这里就够用了。\n了解现代计算机物理内存模型工作原理后，那么再理解多线程开发中最关系的三个概念就有的放矢了。先介绍下三个概念：\n\n1. ** 操作原子性 **：一个操作要么全做，要么全不做，那么这个操作就符合原子性。比如你给你老婆银行卡转500块钱，就包括两个操作，自己账户先减500，你老婆账户加500。但是这个转账操作应该满足原子性。如果银行只执行了你自己账户的扣钱操作，没有执行给你老婆账户的加钱操作。丢了500块钱是小事，被老婆大人罚跪搓衣板可就不得了了。所以你自己账户减钱，老婆账户加钱，这两个操作要么都做了，要么都别做。例如如下操作：\n ``` \n a = a + 1; \n ```\n 结合我们上述的现代计算机的内存模型，计算机执行a=a+1时候会分成三个原子性操作：\n 1. 把a的值（比如4）从内存中取出放到CPU的缓存系统中\n 2. 从缓存系统中取出a的值加1（4+1）得到新结果\n 3. 把新结果存回到内存中\n\n 一个“a=a+1”操作计算机中被拆分成三个原子性操作，那么完全可以出现CPU执行完1.操作后，去执行别的操作了。这就是并发操作原子性问题的根本来源。\n\n2. ** 操作有序性 **：例如如下代码： \n ```\n public class A {\n    public int a;\n    public boolean b = false;\n\n    public void methodA(){\n        a = 3;\n        b = true;\n        a = a + 1;\n    }\n\n    public void methodB(){\n        a = 3;\n        b = (a == 4);\n        a = a + 1;\n    }\n } \n ```\n methodA方法代码先经过java编译器编译成字节码，然后字节码然后被操作系统解释成机器指令，在这个解释过程中，操作系统可能发现，咦？在给变量b赋值为true后又操作了a变量，干脆我操作系统自己改改执行顺序，把对a变量的两个操作都执行完，然后再执行对b的操作,这就叫**指令重排序**。这样就会节省操作时间,如下图没有进行指令重排序时：\n ![没有指令重排序](https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java-memory-model/before_instruciton_reorder.png)\n 图中CPU和缓存系统要进行9次通信，缓存系统和内存要通信7次，假设cpu和缓存系统通信一次用时1ms，缓存系统和内存通信一次用时10ms，那么总用时 9乘1 + 7乘10 = 79ms。经过指令重排序后，总共用时  6乘1 + 6乘10 = 66ms 如下图所示：\n ![有指令重排序](https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java-memory-model/after_instruction_reorder.png)\n 经过指令重排序的确可以提程序运行效率，所以现代计算机都会对指令进行重排序，但是这种重排序也不是无脑重排序，重排序的基础是前后语句不存在依赖关系时，才有可能发生指令重排序。所以A类的methodB方法不会发生指令重排序。指令重排序在单线程环境里面这不会有什么问题，但是多线程中就可能发生意外。比如线程1中执行如下代码：\n ```\n instance.methodA();\n ```\n 另一个线程2执行如下代码：\n ```\n while(instance.a != 4){ //a只要不等4，线程就让出CPU，等待调度器再次执行此线程\n \tThread.yield(); //让出CPU，线程进入就绪态\n }\n System.out.print(instance.b);\n ```\n 其中instance是A类的一个实例。如果线程1 发生了指令重排序， 那么这线程2的打印结果很有可能是false,这就和我们对代码的直观观察结果出处很大。如果线上产品出错的原因是指令重排序导致的，几乎不能可能排查出来。\n\n3. **操作可见性 ** :\n 在“操作有序性” 中的线程线程2 ，还有可能会没有任何输出结果。因为线程2  要想有输出必须要满足instance.a =4,但这是在线程1中调用methodA 方法后instance.a 的值才为4 。而要想让线程2 看到这个新值，必须要把线程1的修改及时写回内存， 同时通知线程2 存在缓存系统中的instance.a值已经过期，需要去内存中获取最新值。如果我们的类A和线程1、线程2调用的代码没有特殊的声明，那么操作系统不能保证上述过程一定发生。即可能发生线程1对instance.a的修改对线程2不一定可见,这就是操作的可见性问题。\n\n### java多线程的所有问题都植根于“操作原子性”、“操作有序性”、“操作可见性”而引发的。\n上面介绍了现代计算机的内存模型以及其引起的在并发编程的三个问题，下面来介绍下java的内存模型。java为了实现其夸平台的特性，使用了一种虚拟机技术，java程序运行在这虚拟机上，那么不管你是windows系统，linux系统，unix系统，只要我java虚拟机屏蔽一切操作系统带来的差异，向java程序提供专用的、各系统无差别的虚拟机，那么java程序员就不需要关心底层到底是什么操作系统了。对于int类型的变量其取值范围永远是 -2^31 -1 至 2^31，即4个字节。但是对C\\C++,这个操作系统的int可能是4字节，那个可能是8字节。C++程序员跨平台写代码，痛苦异常。这个给我们编程带来极大方便的虚拟机就是大名鼎鼎的JVM(Java Virtual Machine)。既然是虚拟机那么就需要模拟真正物理机的所有设备，像CPU，网络，存储等。和我们程序员最密切的就是JVM的存储，这就是java内存模型(Java Memory Model 简称JMM)。有别于我们真实的物理存储模型，JMM把存储分为线程栈区和堆区。在JVM中的每个线程都有自己独立的线程栈，而堆区用来存储java的对象实例。java中各种变量的存储有一下规则：\n 1. 成员变量一定存储在堆区。\n 2. 局部变量如果是基本数据类型存储在线程栈中，如果是非基本数据类型存储，其引用存储在线程栈中，但具体的对象实例还是存储在栈中。\n \n因为java内存模型是在具体的物理内存模型的基础上实现的，并且为了运行效率，java也支持指令重排序。所以java并发编程也有“原子性”、“有序性”、“可见性”三个问题。但是，我们的JMM也不是白吃干饭什么也做的，最起码运行在JVM上的代码就具备8个内存特性，来使得java代码有一定的“有序性”和“可见性”。这些特性也被称为 **happen-before原则**。下面先列举这个八个内存特性，详细介绍请看[<font color=green> java happen-before原则最全最易懂介绍</font>](www.baidu.com)。\n八大happen-before 特性：\n* 单线程happen-before原则：在同一个线程中，书写在前面的操作happen-before后面的操作。\n* 锁的happen-before原则：**同一个锁**的unlock操作happen-before此锁的lock操作。\n* volatile的happen-before原则：对一个volatile变量的写操作happen-before对此变量的任意操作(当然也包括写操作了)。\n* happen-before的传递性原则：如果A操作 happen-before B操作，B操作happen-before C操作，那么A操作happen-before B操作。\n* 线程启动的happen-before原则：同一个线程的start方法happen-before此线程的其它方法。\n* 线程中断的happen-before原则：对线程interrupt方法的调用happen-before被中断线程的检测到中断发送的代码。\n* 线程终结的happen-before原则：线程中的所有操作都happen-before线程的终止检测。\n* 对象创建的happen-before原则：一个对象的初始化完成先于他的finalize方法调用。","slug":"java/concurrency/post2/jvm_memory_model","published":1,"updated":"2020-05-21T02:00:54.443Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckag4s7qm00083oiefh259h4x","content":"<blockquote>\n<p>“如欲征服java并发，需先征服java内存模型，如欲征服java内存模型，需先征服计算机内存模型” -糖炒甜板栗.</p>\n</blockquote>\n<p><img src=\"https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/concurrency/post2/leader_speak.jpg\" alt=\"大佬讲话\"></p>\n<p>咳！咳！，大家都记做笔记了吧。虽然栗子不是什么大佬，但是这句话说的还是没有毛病的。不了解java的内存模型，就不会从根上理解java并发的一些行为和机制，而java内存模型毕竟是jvm模拟出来的一部分，其底子还是建立在现代计算机的物理内存模型上来的，所以我们就按照现代计算机的物理内存模型、java内存模型的顺序来仔细介绍，为彻底了解java并发机制打下底子。</p>\n<a id=\"more\"></a>\n<p>现代计算机的物理内存模型：<br><img src=\"https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/concurrency/post2/memory_model_physical.png\" alt=\"现代计算机的物理内存模型\"><br>现在计算机最少的都是应该是两核心了，当然我们也经常在买个人电脑的时候听过四核四线程、四核八线程等，可以说现在个人电脑标配都是四核心了，为了方便上图只是列举了2个核心。现代计算机的内存在逻辑上还是一块。有人可能问不对啊，我电脑就插了两块内存，但是操作系统会把两块内存的地址统一抽象，比如每一块的内存是2048MB地址是000000000000-011111111111MB，两块就是0000000000000-0111111111111MB，操作系统会统一编址。所以整体上看还是一块内存。因为CPU的操作速度太快，如果让CPU直接操作内存，那么久是对CPU资源的一种巨大浪费，为了解决这个问题现在计算机都给CPU加上缓存，比如一级缓存，二级缓存，甚至三级缓存。缓存速度比内存快，但是是还是赶不上CPU的数据级别，所以在缓存和CPU之间又有了register,register的存储速度比缓存就快了好多了。<br>存储速度上有如下关系：<br>register &gt; 一级缓存 &gt; 二级缓存 &gt; … &gt; n级缓存 &gt; 内存<br>容量上一般有如下关系：<br>内存 &gt; n级缓存 &gt; … &gt; 二级缓存 &gt; 一级缓存 &gt; register<br>之所以可以用缓存和register来缓解CPU和内存之间巨大的速度差别是基于如下原理：</p>\n<p>** CPU访问过的内存地址，很有可能在短时间内会被再次访问。 **<br>所以，比如CPU访问了地址为0x001fffff的内存地址，如果没有缓存和register，那么CPU再下次访问这个内存地址的时候就还要去内存读，但是如果有缓存，缓存会把CPU访问过的数据先存储起来，等CPU待会再找地址为0x001fffff的内存地址时候，发现其在缓存中就存在了，那么好了，这就不用在访问内存了。速度自然就提升了。这就涉及到计算机组成原理的知识了，如果想了解可以google一下，这里就不在做更深的介绍了到这里就够用了。<br>了解现代计算机物理内存模型工作原理后，那么再理解多线程开发中最关系的三个概念就有的放矢了。先介绍下三个概念：</p>\n<ol>\n<li><p>** 操作原子性 **：一个操作要么全做，要么全不做，那么这个操作就符合原子性。比如你给你老婆银行卡转500块钱，就包括两个操作，自己账户先减500，你老婆账户加500。但是这个转账操作应该满足原子性。如果银行只执行了你自己账户的扣钱操作，没有执行给你老婆账户的加钱操作。丢了500块钱是小事，被老婆大人罚跪搓衣板可就不得了了。所以你自己账户减钱，老婆账户加钱，这两个操作要么都做了，要么都别做。例如如下操作：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = a + 1;</span><br></pre></td></tr></table></figure>\n<p>结合我们上述的现代计算机的内存模型，计算机执行a=a+1时候会分成三个原子性操作：</p>\n<ol>\n<li>把a的值（比如4）从内存中取出放到CPU的缓存系统中</li>\n<li>从缓存系统中取出a的值加1（4+1）得到新结果</li>\n<li>把新结果存回到内存中</li>\n</ol>\n<p>一个“a=a+1”操作计算机中被拆分成三个原子性操作，那么完全可以出现CPU执行完1.操作后，去执行别的操作了。这就是并发操作原子性问题的根本来源。</p>\n</li>\n<li><p>** 操作有序性 **：例如如下代码： </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class A &#123;</span><br><span class=\"line\">   public int a;</span><br><span class=\"line\">   public boolean b = false;</span><br><span class=\"line\"></span><br><span class=\"line\">   public void methodA()&#123;</span><br><span class=\"line\">       a = 3;</span><br><span class=\"line\">       b = true;</span><br><span class=\"line\">       a = a + 1;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   public void methodB()&#123;</span><br><span class=\"line\">       a = 3;</span><br><span class=\"line\">       b = (a == 4);</span><br><span class=\"line\">       a = a + 1;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>methodA方法代码先经过java编译器编译成字节码，然后字节码然后被操作系统解释成机器指令，在这个解释过程中，操作系统可能发现，咦？在给变量b赋值为true后又操作了a变量，干脆我操作系统自己改改执行顺序，把对a变量的两个操作都执行完，然后再执行对b的操作,这就叫<strong>指令重排序</strong>。这样就会节省操作时间,如下图没有进行指令重排序时：<br><img src=\"https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java-memory-model/before_instruciton_reorder.png\" alt=\"没有指令重排序\"><br>图中CPU和缓存系统要进行9次通信，缓存系统和内存要通信7次，假设cpu和缓存系统通信一次用时1ms，缓存系统和内存通信一次用时10ms，那么总用时 9乘1 + 7乘10 = 79ms。经过指令重排序后，总共用时  6乘1 + 6乘10 = 66ms 如下图所示：<br><img src=\"https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java-memory-model/after_instruction_reorder.png\" alt=\"有指令重排序\"><br>经过指令重排序的确可以提程序运行效率，所以现代计算机都会对指令进行重排序，但是这种重排序也不是无脑重排序，重排序的基础是前后语句不存在依赖关系时，才有可能发生指令重排序。所以A类的methodB方法不会发生指令重排序。指令重排序在单线程环境里面这不会有什么问题，但是多线程中就可能发生意外。比如线程1中执行如下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">instance.methodA();</span><br></pre></td></tr></table></figure>\n<p>另一个线程2执行如下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">while(instance.a != 4)&#123; //a只要不等4，线程就让出CPU，等待调度器再次执行此线程</span><br><span class=\"line\">\tThread.yield(); //让出CPU，线程进入就绪态</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">System.out.print(instance.b);</span><br></pre></td></tr></table></figure>\n<p>其中instance是A类的一个实例。如果线程1 发生了指令重排序， 那么这线程2的打印结果很有可能是false,这就和我们对代码的直观观察结果出处很大。如果线上产品出错的原因是指令重排序导致的，几乎不能可能排查出来。</p>\n</li>\n<li><p>*<em>操作可见性 *</em> :<br>在“操作有序性” 中的线程线程2 ，还有可能会没有任何输出结果。因为线程2  要想有输出必须要满足instance.a =4,但这是在线程1中调用methodA 方法后instance.a 的值才为4 。而要想让线程2 看到这个新值，必须要把线程1的修改及时写回内存， 同时通知线程2 存在缓存系统中的instance.a值已经过期，需要去内存中获取最新值。如果我们的类A和线程1、线程2调用的代码没有特殊的声明，那么操作系统不能保证上述过程一定发生。即可能发生线程1对instance.a的修改对线程2不一定可见,这就是操作的可见性问题。</p>\n</li>\n</ol>\n<h3 id=\"java多线程的所有问题都植根于“操作原子性”、“操作有序性”、“操作可见性”而引发的。\"><a href=\"#java多线程的所有问题都植根于“操作原子性”、“操作有序性”、“操作可见性”而引发的。\" class=\"headerlink\" title=\"java多线程的所有问题都植根于“操作原子性”、“操作有序性”、“操作可见性”而引发的。\"></a>java多线程的所有问题都植根于“操作原子性”、“操作有序性”、“操作可见性”而引发的。</h3><p>上面介绍了现代计算机的内存模型以及其引起的在并发编程的三个问题，下面来介绍下java的内存模型。java为了实现其夸平台的特性，使用了一种虚拟机技术，java程序运行在这虚拟机上，那么不管你是windows系统，linux系统，unix系统，只要我java虚拟机屏蔽一切操作系统带来的差异，向java程序提供专用的、各系统无差别的虚拟机，那么java程序员就不需要关心底层到底是什么操作系统了。对于int类型的变量其取值范围永远是 -2^31 -1 至 2^31，即4个字节。但是对C\\C++,这个操作系统的int可能是4字节，那个可能是8字节。C++程序员跨平台写代码，痛苦异常。这个给我们编程带来极大方便的虚拟机就是大名鼎鼎的JVM(Java Virtual Machine)。既然是虚拟机那么就需要模拟真正物理机的所有设备，像CPU，网络，存储等。和我们程序员最密切的就是JVM的存储，这就是java内存模型(Java Memory Model 简称JMM)。有别于我们真实的物理存储模型，JMM把存储分为线程栈区和堆区。在JVM中的每个线程都有自己独立的线程栈，而堆区用来存储java的对象实例。java中各种变量的存储有一下规则：</p>\n<ol>\n<li>成员变量一定存储在堆区。</li>\n<li>局部变量如果是基本数据类型存储在线程栈中，如果是非基本数据类型存储，其引用存储在线程栈中，但具体的对象实例还是存储在栈中。</li>\n</ol>\n<p>因为java内存模型是在具体的物理内存模型的基础上实现的，并且为了运行效率，java也支持指令重排序。所以java并发编程也有“原子性”、“有序性”、“可见性”三个问题。但是，我们的JMM也不是白吃干饭什么也做的，最起码运行在JVM上的代码就具备8个内存特性，来使得java代码有一定的“有序性”和“可见性”。这些特性也被称为 <strong>happen-before原则</strong>。下面先列举这个八个内存特性，详细介绍请看<a href=\"www.baidu.com\"><font color=green> java happen-before原则最全最易懂介绍</font></a>。<br>八大happen-before 特性：</p>\n<ul>\n<li>单线程happen-before原则：在同一个线程中，书写在前面的操作happen-before后面的操作。</li>\n<li>锁的happen-before原则：<strong>同一个锁</strong>的unlock操作happen-before此锁的lock操作。</li>\n<li>volatile的happen-before原则：对一个volatile变量的写操作happen-before对此变量的任意操作(当然也包括写操作了)。</li>\n<li>happen-before的传递性原则：如果A操作 happen-before B操作，B操作happen-before C操作，那么A操作happen-before B操作。</li>\n<li>线程启动的happen-before原则：同一个线程的start方法happen-before此线程的其它方法。</li>\n<li>线程中断的happen-before原则：对线程interrupt方法的调用happen-before被中断线程的检测到中断发送的代码。</li>\n<li>线程终结的happen-before原则：线程中的所有操作都happen-before线程的终止检测。</li>\n<li>对象创建的happen-before原则：一个对象的初始化完成先于他的finalize方法调用。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>“如欲征服java并发，需先征服java内存模型，如欲征服java内存模型，需先征服计算机内存模型” -糖炒甜板栗.</p>\n</blockquote>\n<p><img src=\"https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/concurrency/post2/leader_speak.jpg\" alt=\"大佬讲话\"></p>\n<p>咳！咳！，大家都记做笔记了吧。虽然栗子不是什么大佬，但是这句话说的还是没有毛病的。不了解java的内存模型，就不会从根上理解java并发的一些行为和机制，而java内存模型毕竟是jvm模拟出来的一部分，其底子还是建立在现代计算机的物理内存模型上来的，所以我们就按照现代计算机的物理内存模型、java内存模型的顺序来仔细介绍，为彻底了解java并发机制打下底子。</p>","more":"<p>现代计算机的物理内存模型：<br><img src=\"https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/concurrency/post2/memory_model_physical.png\" alt=\"现代计算机的物理内存模型\"><br>现在计算机最少的都是应该是两核心了，当然我们也经常在买个人电脑的时候听过四核四线程、四核八线程等，可以说现在个人电脑标配都是四核心了，为了方便上图只是列举了2个核心。现代计算机的内存在逻辑上还是一块。有人可能问不对啊，我电脑就插了两块内存，但是操作系统会把两块内存的地址统一抽象，比如每一块的内存是2048MB地址是000000000000-011111111111MB，两块就是0000000000000-0111111111111MB，操作系统会统一编址。所以整体上看还是一块内存。因为CPU的操作速度太快，如果让CPU直接操作内存，那么久是对CPU资源的一种巨大浪费，为了解决这个问题现在计算机都给CPU加上缓存，比如一级缓存，二级缓存，甚至三级缓存。缓存速度比内存快，但是是还是赶不上CPU的数据级别，所以在缓存和CPU之间又有了register,register的存储速度比缓存就快了好多了。<br>存储速度上有如下关系：<br>register &gt; 一级缓存 &gt; 二级缓存 &gt; … &gt; n级缓存 &gt; 内存<br>容量上一般有如下关系：<br>内存 &gt; n级缓存 &gt; … &gt; 二级缓存 &gt; 一级缓存 &gt; register<br>之所以可以用缓存和register来缓解CPU和内存之间巨大的速度差别是基于如下原理：</p>\n<p>** CPU访问过的内存地址，很有可能在短时间内会被再次访问。 **<br>所以，比如CPU访问了地址为0x001fffff的内存地址，如果没有缓存和register，那么CPU再下次访问这个内存地址的时候就还要去内存读，但是如果有缓存，缓存会把CPU访问过的数据先存储起来，等CPU待会再找地址为0x001fffff的内存地址时候，发现其在缓存中就存在了，那么好了，这就不用在访问内存了。速度自然就提升了。这就涉及到计算机组成原理的知识了，如果想了解可以google一下，这里就不在做更深的介绍了到这里就够用了。<br>了解现代计算机物理内存模型工作原理后，那么再理解多线程开发中最关系的三个概念就有的放矢了。先介绍下三个概念：</p>\n<ol>\n<li><p>** 操作原子性 **：一个操作要么全做，要么全不做，那么这个操作就符合原子性。比如你给你老婆银行卡转500块钱，就包括两个操作，自己账户先减500，你老婆账户加500。但是这个转账操作应该满足原子性。如果银行只执行了你自己账户的扣钱操作，没有执行给你老婆账户的加钱操作。丢了500块钱是小事，被老婆大人罚跪搓衣板可就不得了了。所以你自己账户减钱，老婆账户加钱，这两个操作要么都做了，要么都别做。例如如下操作：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = a + 1;</span><br></pre></td></tr></table></figure>\n<p>结合我们上述的现代计算机的内存模型，计算机执行a=a+1时候会分成三个原子性操作：</p>\n<ol>\n<li>把a的值（比如4）从内存中取出放到CPU的缓存系统中</li>\n<li>从缓存系统中取出a的值加1（4+1）得到新结果</li>\n<li>把新结果存回到内存中</li>\n</ol>\n<p>一个“a=a+1”操作计算机中被拆分成三个原子性操作，那么完全可以出现CPU执行完1.操作后，去执行别的操作了。这就是并发操作原子性问题的根本来源。</p>\n</li>\n<li><p>** 操作有序性 **：例如如下代码： </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class A &#123;</span><br><span class=\"line\">   public int a;</span><br><span class=\"line\">   public boolean b = false;</span><br><span class=\"line\"></span><br><span class=\"line\">   public void methodA()&#123;</span><br><span class=\"line\">       a = 3;</span><br><span class=\"line\">       b = true;</span><br><span class=\"line\">       a = a + 1;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   public void methodB()&#123;</span><br><span class=\"line\">       a = 3;</span><br><span class=\"line\">       b = (a == 4);</span><br><span class=\"line\">       a = a + 1;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>methodA方法代码先经过java编译器编译成字节码，然后字节码然后被操作系统解释成机器指令，在这个解释过程中，操作系统可能发现，咦？在给变量b赋值为true后又操作了a变量，干脆我操作系统自己改改执行顺序，把对a变量的两个操作都执行完，然后再执行对b的操作,这就叫<strong>指令重排序</strong>。这样就会节省操作时间,如下图没有进行指令重排序时：<br><img src=\"https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java-memory-model/before_instruciton_reorder.png\" alt=\"没有指令重排序\"><br>图中CPU和缓存系统要进行9次通信，缓存系统和内存要通信7次，假设cpu和缓存系统通信一次用时1ms，缓存系统和内存通信一次用时10ms，那么总用时 9乘1 + 7乘10 = 79ms。经过指令重排序后，总共用时  6乘1 + 6乘10 = 66ms 如下图所示：<br><img src=\"https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java-memory-model/after_instruction_reorder.png\" alt=\"有指令重排序\"><br>经过指令重排序的确可以提程序运行效率，所以现代计算机都会对指令进行重排序，但是这种重排序也不是无脑重排序，重排序的基础是前后语句不存在依赖关系时，才有可能发生指令重排序。所以A类的methodB方法不会发生指令重排序。指令重排序在单线程环境里面这不会有什么问题，但是多线程中就可能发生意外。比如线程1中执行如下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">instance.methodA();</span><br></pre></td></tr></table></figure>\n<p>另一个线程2执行如下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">while(instance.a != 4)&#123; //a只要不等4，线程就让出CPU，等待调度器再次执行此线程</span><br><span class=\"line\">\tThread.yield(); //让出CPU，线程进入就绪态</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">System.out.print(instance.b);</span><br></pre></td></tr></table></figure>\n<p>其中instance是A类的一个实例。如果线程1 发生了指令重排序， 那么这线程2的打印结果很有可能是false,这就和我们对代码的直观观察结果出处很大。如果线上产品出错的原因是指令重排序导致的，几乎不能可能排查出来。</p>\n</li>\n<li><p>*<em>操作可见性 *</em> :<br>在“操作有序性” 中的线程线程2 ，还有可能会没有任何输出结果。因为线程2  要想有输出必须要满足instance.a =4,但这是在线程1中调用methodA 方法后instance.a 的值才为4 。而要想让线程2 看到这个新值，必须要把线程1的修改及时写回内存， 同时通知线程2 存在缓存系统中的instance.a值已经过期，需要去内存中获取最新值。如果我们的类A和线程1、线程2调用的代码没有特殊的声明，那么操作系统不能保证上述过程一定发生。即可能发生线程1对instance.a的修改对线程2不一定可见,这就是操作的可见性问题。</p>\n</li>\n</ol>\n<h3 id=\"java多线程的所有问题都植根于“操作原子性”、“操作有序性”、“操作可见性”而引发的。\"><a href=\"#java多线程的所有问题都植根于“操作原子性”、“操作有序性”、“操作可见性”而引发的。\" class=\"headerlink\" title=\"java多线程的所有问题都植根于“操作原子性”、“操作有序性”、“操作可见性”而引发的。\"></a>java多线程的所有问题都植根于“操作原子性”、“操作有序性”、“操作可见性”而引发的。</h3><p>上面介绍了现代计算机的内存模型以及其引起的在并发编程的三个问题，下面来介绍下java的内存模型。java为了实现其夸平台的特性，使用了一种虚拟机技术，java程序运行在这虚拟机上，那么不管你是windows系统，linux系统，unix系统，只要我java虚拟机屏蔽一切操作系统带来的差异，向java程序提供专用的、各系统无差别的虚拟机，那么java程序员就不需要关心底层到底是什么操作系统了。对于int类型的变量其取值范围永远是 -2^31 -1 至 2^31，即4个字节。但是对C\\C++,这个操作系统的int可能是4字节，那个可能是8字节。C++程序员跨平台写代码，痛苦异常。这个给我们编程带来极大方便的虚拟机就是大名鼎鼎的JVM(Java Virtual Machine)。既然是虚拟机那么就需要模拟真正物理机的所有设备，像CPU，网络，存储等。和我们程序员最密切的就是JVM的存储，这就是java内存模型(Java Memory Model 简称JMM)。有别于我们真实的物理存储模型，JMM把存储分为线程栈区和堆区。在JVM中的每个线程都有自己独立的线程栈，而堆区用来存储java的对象实例。java中各种变量的存储有一下规则：</p>\n<ol>\n<li>成员变量一定存储在堆区。</li>\n<li>局部变量如果是基本数据类型存储在线程栈中，如果是非基本数据类型存储，其引用存储在线程栈中，但具体的对象实例还是存储在栈中。</li>\n</ol>\n<p>因为java内存模型是在具体的物理内存模型的基础上实现的，并且为了运行效率，java也支持指令重排序。所以java并发编程也有“原子性”、“有序性”、“可见性”三个问题。但是，我们的JMM也不是白吃干饭什么也做的，最起码运行在JVM上的代码就具备8个内存特性，来使得java代码有一定的“有序性”和“可见性”。这些特性也被称为 <strong>happen-before原则</strong>。下面先列举这个八个内存特性，详细介绍请看<a href=\"www.baidu.com\"><font color=green> java happen-before原则最全最易懂介绍</font></a>。<br>八大happen-before 特性：</p>\n<ul>\n<li>单线程happen-before原则：在同一个线程中，书写在前面的操作happen-before后面的操作。</li>\n<li>锁的happen-before原则：<strong>同一个锁</strong>的unlock操作happen-before此锁的lock操作。</li>\n<li>volatile的happen-before原则：对一个volatile变量的写操作happen-before对此变量的任意操作(当然也包括写操作了)。</li>\n<li>happen-before的传递性原则：如果A操作 happen-before B操作，B操作happen-before C操作，那么A操作happen-before B操作。</li>\n<li>线程启动的happen-before原则：同一个线程的start方法happen-before此线程的其它方法。</li>\n<li>线程中断的happen-before原则：对线程interrupt方法的调用happen-before被中断线程的检测到中断发送的代码。</li>\n<li>线程终结的happen-before原则：线程中的所有操作都happen-before线程的终止检测。</li>\n<li>对象创建的happen-before原则：一个对象的初始化完成先于他的finalize方法调用。</li>\n</ul>"},{"title":"00开篇","date":"2020-05-17T05:28:13.000Z","_content":"\n并发编程是每一个java程序员都绕不开的关卡，不论你是要阅读业内成熟的开源框架如spring、kafka、dubbo；还是你要对你的项目进行性能调优，都离不开对java并发相关知识的理解和掌握。java并发编程相关知识是java程序员向高阶跃进的必须要迈过的一座山。圈子里上java并发编程的基础和高级应用相关的知识并不少，但读者却很难从中涉取到完整的java并发编程技术体系：\n+ 培训课程中与并发编程相关的知识大多数只是介绍基本的概念后就开始教synchronized关键字和java并发包(java.util.concurrent)的使用，你只学会用几个关键字和几个类，就以为自己学会java并发编程。\n\n+ 网上的博文大多数是千篇一律，不成体系。往往是今天张三遇到了个问题在网上百度一下看到了李四写的类似问题，反手就在自己的博客上一个三连（复制，粘贴，发布)，这让互联网上的java并发编程知识同质化和碎片化严重，很难成系统成体系的学习到相关知识的根子上去。\n\n+ 并发编程相关的书籍要么写的和培训课程一样粘贴几个并发类的源代码，简单写几个使用的小例子敷衍了事；要么把枯燥无味的知识点从头到尾讲一遍，读者味同嚼蜡对java并发编程相关的知识不但没有学会多少，反而感觉这方面的知识深邃难懂，以后遇到相关问题就缴械投降。\n\n\n## 特点\n\n1、知识成体系\n2、侧重实战\n3、化繁入简，形象生动不枯燥。\n4、互动\n5、及时更新\n\n","source":"_posts/java/concurrency/post0/post0.md","raw":"---\ntitle: 00开篇\ndate: 2020-05-17 13:28:13\ncategories:\n    - java并发\n    - java并发原理及实践\ntags:\n---\n\n并发编程是每一个java程序员都绕不开的关卡，不论你是要阅读业内成熟的开源框架如spring、kafka、dubbo；还是你要对你的项目进行性能调优，都离不开对java并发相关知识的理解和掌握。java并发编程相关知识是java程序员向高阶跃进的必须要迈过的一座山。圈子里上java并发编程的基础和高级应用相关的知识并不少，但读者却很难从中涉取到完整的java并发编程技术体系：\n+ 培训课程中与并发编程相关的知识大多数只是介绍基本的概念后就开始教synchronized关键字和java并发包(java.util.concurrent)的使用，你只学会用几个关键字和几个类，就以为自己学会java并发编程。\n\n+ 网上的博文大多数是千篇一律，不成体系。往往是今天张三遇到了个问题在网上百度一下看到了李四写的类似问题，反手就在自己的博客上一个三连（复制，粘贴，发布)，这让互联网上的java并发编程知识同质化和碎片化严重，很难成系统成体系的学习到相关知识的根子上去。\n\n+ 并发编程相关的书籍要么写的和培训课程一样粘贴几个并发类的源代码，简单写几个使用的小例子敷衍了事；要么把枯燥无味的知识点从头到尾讲一遍，读者味同嚼蜡对java并发编程相关的知识不但没有学会多少，反而感觉这方面的知识深邃难懂，以后遇到相关问题就缴械投降。\n\n\n## 特点\n\n1、知识成体系\n2、侧重实战\n3、化繁入简，形象生动不枯燥。\n4、互动\n5、及时更新\n\n","slug":"java/concurrency/post0/post0","published":1,"updated":"2020-05-17T07:13:55.985Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckag4s7qn00093oie0v9e1mgo","content":"<p>并发编程是每一个java程序员都绕不开的关卡，不论你是要阅读业内成熟的开源框架如spring、kafka、dubbo；还是你要对你的项目进行性能调优，都离不开对java并发相关知识的理解和掌握。java并发编程相关知识是java程序员向高阶跃进的必须要迈过的一座山。圈子里上java并发编程的基础和高级应用相关的知识并不少，但读者却很难从中涉取到完整的java并发编程技术体系：</p>\n<ul>\n<li><p>培训课程中与并发编程相关的知识大多数只是介绍基本的概念后就开始教synchronized关键字和java并发包(java.util.concurrent)的使用，你只学会用几个关键字和几个类，就以为自己学会java并发编程。</p>\n</li>\n<li><p>网上的博文大多数是千篇一律，不成体系。往往是今天张三遇到了个问题在网上百度一下看到了李四写的类似问题，反手就在自己的博客上一个三连（复制，粘贴，发布)，这让互联网上的java并发编程知识同质化和碎片化严重，很难成系统成体系的学习到相关知识的根子上去。</p>\n</li>\n<li><p>并发编程相关的书籍要么写的和培训课程一样粘贴几个并发类的源代码，简单写几个使用的小例子敷衍了事；要么把枯燥无味的知识点从头到尾讲一遍，读者味同嚼蜡对java并发编程相关的知识不但没有学会多少，反而感觉这方面的知识深邃难懂，以后遇到相关问题就缴械投降。</p>\n</li>\n</ul>\n<h2 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h2><p>1、知识成体系<br>2、侧重实战<br>3、化繁入简，形象生动不枯燥。<br>4、互动<br>5、及时更新</p>\n","site":{"data":{}},"excerpt":"","more":"<p>并发编程是每一个java程序员都绕不开的关卡，不论你是要阅读业内成熟的开源框架如spring、kafka、dubbo；还是你要对你的项目进行性能调优，都离不开对java并发相关知识的理解和掌握。java并发编程相关知识是java程序员向高阶跃进的必须要迈过的一座山。圈子里上java并发编程的基础和高级应用相关的知识并不少，但读者却很难从中涉取到完整的java并发编程技术体系：</p>\n<ul>\n<li><p>培训课程中与并发编程相关的知识大多数只是介绍基本的概念后就开始教synchronized关键字和java并发包(java.util.concurrent)的使用，你只学会用几个关键字和几个类，就以为自己学会java并发编程。</p>\n</li>\n<li><p>网上的博文大多数是千篇一律，不成体系。往往是今天张三遇到了个问题在网上百度一下看到了李四写的类似问题，反手就在自己的博客上一个三连（复制，粘贴，发布)，这让互联网上的java并发编程知识同质化和碎片化严重，很难成系统成体系的学习到相关知识的根子上去。</p>\n</li>\n<li><p>并发编程相关的书籍要么写的和培训课程一样粘贴几个并发类的源代码，简单写几个使用的小例子敷衍了事；要么把枯燥无味的知识点从头到尾讲一遍，读者味同嚼蜡对java并发编程相关的知识不但没有学会多少，反而感觉这方面的知识深邃难懂，以后遇到相关问题就缴械投降。</p>\n</li>\n</ul>\n<h2 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h2><p>1、知识成体系<br>2、侧重实战<br>3、化繁入简，形象生动不枯燥。<br>4、互动<br>5、及时更新</p>\n"},{"title":"01 java并发知识入门","date":"2020-05-17T05:28:13.000Z","_content":"\n\n# 1 并发简史\n\n在计算机发明早期，一台计算机在同一时间只能运行一个程序。如果将人比作一台计算机的话，就是一个人在同一时间内只能做一件事情不能三心二意。就拿博主我给老婆做最爱吃的皮蛋瘦肉粥来说，要经历洗米、把米放锅中煮、切肉和皮蛋、找准火候放入肉和皮蛋、电饭煲闷煮、电饭煲提示灯亮后给老婆大人盛饭，我们要按照顺序执行每一步，在得到结果后再执行下一步，最后得到最终的结果。同样对于早期的计算机来说，交给它一个任务如计算1+2的结果并打印，其要先分别拿到1和2放到寄存器中、然后执行加法运算得出结果3、然后把3回写到内存中、最后把结果通过打印机输出到纸上。大略一看，这个观点似乎没什么问题，但是效率上其实还可以提升下，不管是在人做饭还是计算机执行算数任务这件事上。\n\n不管是人还是机器，都需要提高自身资源的使用效率。人在做饭时最主要使用的是眼睛、双手、和大脑，我们另外一个主要器官耳朵在做饭过程中的使用率并不是太高，这样我们就可以变做饭边听早间新闻提高我们自身器官的使用率，那么效率自然也就提升了。对于计算机来说道理也是相同，在计算机执行计算任务时主要使用的是CPU，在计算机回写计算结果时使用的主要是I/O设备，如果我们能让计算机在执行1+2任务的计算部分时，能让闲置的I/O设备忙起来搞其它任务的输入或者输出部分的工作；亦或在计算机通过I/O设备将1+2的计算结果打印到纸上时，让闲置的CPU来执行其它任务的计算部分。那么假设本来需要两个小时完成的类似1+2这种计算结果并打印的大量任务，现在提升效率后大体只需要一个小时就能完成了。\n\n人们为了提升计算机各种设备的使用效率，引入了操作系统来统一管理计算机中的各种设备。所有的任务只需要和操作系统打交道，由操作系统统一调度计算机中的各种设备，尽最大可能保证各种设备在同一时间没有被闲置。操作系统除了保证各种设备没有被闲置外，还要保证各种任务在使用计算机设备时尽可能的公平，当我们用计算机的CPU解码mp3文件听歌时，不能因要执行1+2的计算任务把CPU抢占过去后不能听歌曲了，操作系统会把任务对CPU的使用时间切成无数小的几毫秒的时间片段，每个任务交替的获取使用CPU的时间片段来保证各个任务在执行顺序上的公平。不同任务对CPU按照时间片来交替使用，这个叫做并发。\n\n# 2 java中的并发编程\n\n上节我们知道计算系统分配CPU时间片的最小单位是一个个具体的任务，操作系统提供线程的概念给各种各样的程序，程序把一个大任务按照不同的性质分隔成小任务，每个小任务被封装在一个线程中交给操作系统来调度执行。同一个程序中的线程有如下特点：\n\n+ 资源共享，操作系统分配给程序的各种资源对于线程来说都是共享的，如内存，CPU等。\n\n+ 线程之间是交替执行的，一个程序中的线程一般是不会少于机器的CPU数量的，这势必导致同一时间点，并不是所有的程序线程都在运行。\n\njava中的并发编程问题也就是对线程和线程能访问到的资源的管理问题，即怎样管理线程和资源才能让程序的执行效率更高同时不出差错。具体来说就是解决以下三大问题：\n\n1. 正确性问题。由于线程可以共享程序中的各种资源，这有可能导致多个线程对同一个资源的竞争使用，使原来单线程顺序执行时正确的程序，在多线程下出现问题。\n\n2. 可行性问题。由于对锁的管理不当，导致发生死锁问题，而程序中的死锁可能导致程序“僵死”，没办法完成指定的任务。当然多线程的可行性问题不全是死锁导致的，还有线程饥饿，活锁等多种可能。\n\n3. 高效性问题。引入多线程后原本一个线程用来执行任务现在交给多个线程一起执行了，效率一定会更高吗？其实并不是绝对的，为了保证多线程程序的正确性和可行性，势必会引入管理成本，同时线程在切换时间片的时候也会有成本。如果平衡不好这些成本，多线程的引入可能带来的是效率的倒退。\n\n\n这里栗子给大家举个例子,多线程程序就好比是一个交通系统，一辆汽车就好比是一个线程，其中的道路就好比是线程运行时所需要的各种公共资源。如果交通管理系统没能正确的调度其上运行的车辆，让南北行驶的汽车（线程1）和东西行驶的汽车（线程2）同时经过（操作）了交通路口（公共资源）而出了车祸（出现脏数据），这就是没解决好正确性问题；如果因为交通系统调度不合理导致很多车辆相互“顶牛”（A线程拿着B线程要用的资源1，B线程拿着A线程要用的资源2，大家都不释放），互不让路，这就会出现可行性问题；一个调度良好的交通系统能让车辆的吞吐率大幅度提升，这就是高效性问题。\n\n这三大问题正确性是基本，不管是不是并发编程，首先你要保证执行结果是正确的；其次是可行性，程序如果引入了java并发编程先不说效率能提升多少，最起码程序能够顺利执行完成；最后是高效性问题，在满足正确性和可行性时，我们希望我们的程序能在java并发的加持下，相较于单线程顺序执行的程序能更快地完成任务。栗子本系列文章就是围绕这三大问题展开的，而深入了解这三大问题，相信大家会对java多线程有一个更加深刻的认识。\n\n\n\n\n\n\n\n","source":"_posts/java/concurrency/post1/post1.md","raw":"---\ntitle: 01 java并发知识入门\ndate: 2020-05-17 13:28:13\ncategories:\n    - java并发\n    - java并发原理及实践\ntags:\n---\n\n\n# 1 并发简史\n\n在计算机发明早期，一台计算机在同一时间只能运行一个程序。如果将人比作一台计算机的话，就是一个人在同一时间内只能做一件事情不能三心二意。就拿博主我给老婆做最爱吃的皮蛋瘦肉粥来说，要经历洗米、把米放锅中煮、切肉和皮蛋、找准火候放入肉和皮蛋、电饭煲闷煮、电饭煲提示灯亮后给老婆大人盛饭，我们要按照顺序执行每一步，在得到结果后再执行下一步，最后得到最终的结果。同样对于早期的计算机来说，交给它一个任务如计算1+2的结果并打印，其要先分别拿到1和2放到寄存器中、然后执行加法运算得出结果3、然后把3回写到内存中、最后把结果通过打印机输出到纸上。大略一看，这个观点似乎没什么问题，但是效率上其实还可以提升下，不管是在人做饭还是计算机执行算数任务这件事上。\n\n不管是人还是机器，都需要提高自身资源的使用效率。人在做饭时最主要使用的是眼睛、双手、和大脑，我们另外一个主要器官耳朵在做饭过程中的使用率并不是太高，这样我们就可以变做饭边听早间新闻提高我们自身器官的使用率，那么效率自然也就提升了。对于计算机来说道理也是相同，在计算机执行计算任务时主要使用的是CPU，在计算机回写计算结果时使用的主要是I/O设备，如果我们能让计算机在执行1+2任务的计算部分时，能让闲置的I/O设备忙起来搞其它任务的输入或者输出部分的工作；亦或在计算机通过I/O设备将1+2的计算结果打印到纸上时，让闲置的CPU来执行其它任务的计算部分。那么假设本来需要两个小时完成的类似1+2这种计算结果并打印的大量任务，现在提升效率后大体只需要一个小时就能完成了。\n\n人们为了提升计算机各种设备的使用效率，引入了操作系统来统一管理计算机中的各种设备。所有的任务只需要和操作系统打交道，由操作系统统一调度计算机中的各种设备，尽最大可能保证各种设备在同一时间没有被闲置。操作系统除了保证各种设备没有被闲置外，还要保证各种任务在使用计算机设备时尽可能的公平，当我们用计算机的CPU解码mp3文件听歌时，不能因要执行1+2的计算任务把CPU抢占过去后不能听歌曲了，操作系统会把任务对CPU的使用时间切成无数小的几毫秒的时间片段，每个任务交替的获取使用CPU的时间片段来保证各个任务在执行顺序上的公平。不同任务对CPU按照时间片来交替使用，这个叫做并发。\n\n# 2 java中的并发编程\n\n上节我们知道计算系统分配CPU时间片的最小单位是一个个具体的任务，操作系统提供线程的概念给各种各样的程序，程序把一个大任务按照不同的性质分隔成小任务，每个小任务被封装在一个线程中交给操作系统来调度执行。同一个程序中的线程有如下特点：\n\n+ 资源共享，操作系统分配给程序的各种资源对于线程来说都是共享的，如内存，CPU等。\n\n+ 线程之间是交替执行的，一个程序中的线程一般是不会少于机器的CPU数量的，这势必导致同一时间点，并不是所有的程序线程都在运行。\n\njava中的并发编程问题也就是对线程和线程能访问到的资源的管理问题，即怎样管理线程和资源才能让程序的执行效率更高同时不出差错。具体来说就是解决以下三大问题：\n\n1. 正确性问题。由于线程可以共享程序中的各种资源，这有可能导致多个线程对同一个资源的竞争使用，使原来单线程顺序执行时正确的程序，在多线程下出现问题。\n\n2. 可行性问题。由于对锁的管理不当，导致发生死锁问题，而程序中的死锁可能导致程序“僵死”，没办法完成指定的任务。当然多线程的可行性问题不全是死锁导致的，还有线程饥饿，活锁等多种可能。\n\n3. 高效性问题。引入多线程后原本一个线程用来执行任务现在交给多个线程一起执行了，效率一定会更高吗？其实并不是绝对的，为了保证多线程程序的正确性和可行性，势必会引入管理成本，同时线程在切换时间片的时候也会有成本。如果平衡不好这些成本，多线程的引入可能带来的是效率的倒退。\n\n\n这里栗子给大家举个例子,多线程程序就好比是一个交通系统，一辆汽车就好比是一个线程，其中的道路就好比是线程运行时所需要的各种公共资源。如果交通管理系统没能正确的调度其上运行的车辆，让南北行驶的汽车（线程1）和东西行驶的汽车（线程2）同时经过（操作）了交通路口（公共资源）而出了车祸（出现脏数据），这就是没解决好正确性问题；如果因为交通系统调度不合理导致很多车辆相互“顶牛”（A线程拿着B线程要用的资源1，B线程拿着A线程要用的资源2，大家都不释放），互不让路，这就会出现可行性问题；一个调度良好的交通系统能让车辆的吞吐率大幅度提升，这就是高效性问题。\n\n这三大问题正确性是基本，不管是不是并发编程，首先你要保证执行结果是正确的；其次是可行性，程序如果引入了java并发编程先不说效率能提升多少，最起码程序能够顺利执行完成；最后是高效性问题，在满足正确性和可行性时，我们希望我们的程序能在java并发的加持下，相较于单线程顺序执行的程序能更快地完成任务。栗子本系列文章就是围绕这三大问题展开的，而深入了解这三大问题，相信大家会对java多线程有一个更加深刻的认识。\n\n\n\n\n\n\n\n","slug":"java/concurrency/post1/post1","published":1,"updated":"2020-05-21T01:45:44.849Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckag4s7qp000b3oiedii184w7","content":"<h1 id=\"1-并发简史\"><a href=\"#1-并发简史\" class=\"headerlink\" title=\"1 并发简史\"></a>1 并发简史</h1><p>在计算机发明早期，一台计算机在同一时间只能运行一个程序。如果将人比作一台计算机的话，就是一个人在同一时间内只能做一件事情不能三心二意。就拿博主我给老婆做最爱吃的皮蛋瘦肉粥来说，要经历洗米、把米放锅中煮、切肉和皮蛋、找准火候放入肉和皮蛋、电饭煲闷煮、电饭煲提示灯亮后给老婆大人盛饭，我们要按照顺序执行每一步，在得到结果后再执行下一步，最后得到最终的结果。同样对于早期的计算机来说，交给它一个任务如计算1+2的结果并打印，其要先分别拿到1和2放到寄存器中、然后执行加法运算得出结果3、然后把3回写到内存中、最后把结果通过打印机输出到纸上。大略一看，这个观点似乎没什么问题，但是效率上其实还可以提升下，不管是在人做饭还是计算机执行算数任务这件事上。</p>\n<p>不管是人还是机器，都需要提高自身资源的使用效率。人在做饭时最主要使用的是眼睛、双手、和大脑，我们另外一个主要器官耳朵在做饭过程中的使用率并不是太高，这样我们就可以变做饭边听早间新闻提高我们自身器官的使用率，那么效率自然也就提升了。对于计算机来说道理也是相同，在计算机执行计算任务时主要使用的是CPU，在计算机回写计算结果时使用的主要是I/O设备，如果我们能让计算机在执行1+2任务的计算部分时，能让闲置的I/O设备忙起来搞其它任务的输入或者输出部分的工作；亦或在计算机通过I/O设备将1+2的计算结果打印到纸上时，让闲置的CPU来执行其它任务的计算部分。那么假设本来需要两个小时完成的类似1+2这种计算结果并打印的大量任务，现在提升效率后大体只需要一个小时就能完成了。</p>\n<p>人们为了提升计算机各种设备的使用效率，引入了操作系统来统一管理计算机中的各种设备。所有的任务只需要和操作系统打交道，由操作系统统一调度计算机中的各种设备，尽最大可能保证各种设备在同一时间没有被闲置。操作系统除了保证各种设备没有被闲置外，还要保证各种任务在使用计算机设备时尽可能的公平，当我们用计算机的CPU解码mp3文件听歌时，不能因要执行1+2的计算任务把CPU抢占过去后不能听歌曲了，操作系统会把任务对CPU的使用时间切成无数小的几毫秒的时间片段，每个任务交替的获取使用CPU的时间片段来保证各个任务在执行顺序上的公平。不同任务对CPU按照时间片来交替使用，这个叫做并发。</p>\n<h1 id=\"2-java中的并发编程\"><a href=\"#2-java中的并发编程\" class=\"headerlink\" title=\"2 java中的并发编程\"></a>2 java中的并发编程</h1><p>上节我们知道计算系统分配CPU时间片的最小单位是一个个具体的任务，操作系统提供线程的概念给各种各样的程序，程序把一个大任务按照不同的性质分隔成小任务，每个小任务被封装在一个线程中交给操作系统来调度执行。同一个程序中的线程有如下特点：</p>\n<ul>\n<li><p>资源共享，操作系统分配给程序的各种资源对于线程来说都是共享的，如内存，CPU等。</p>\n</li>\n<li><p>线程之间是交替执行的，一个程序中的线程一般是不会少于机器的CPU数量的，这势必导致同一时间点，并不是所有的程序线程都在运行。</p>\n</li>\n</ul>\n<p>java中的并发编程问题也就是对线程和线程能访问到的资源的管理问题，即怎样管理线程和资源才能让程序的执行效率更高同时不出差错。具体来说就是解决以下三大问题：</p>\n<ol>\n<li><p>正确性问题。由于线程可以共享程序中的各种资源，这有可能导致多个线程对同一个资源的竞争使用，使原来单线程顺序执行时正确的程序，在多线程下出现问题。</p>\n</li>\n<li><p>可行性问题。由于对锁的管理不当，导致发生死锁问题，而程序中的死锁可能导致程序“僵死”，没办法完成指定的任务。当然多线程的可行性问题不全是死锁导致的，还有线程饥饿，活锁等多种可能。</p>\n</li>\n<li><p>高效性问题。引入多线程后原本一个线程用来执行任务现在交给多个线程一起执行了，效率一定会更高吗？其实并不是绝对的，为了保证多线程程序的正确性和可行性，势必会引入管理成本，同时线程在切换时间片的时候也会有成本。如果平衡不好这些成本，多线程的引入可能带来的是效率的倒退。</p>\n</li>\n</ol>\n<p>这里栗子给大家举个例子,多线程程序就好比是一个交通系统，一辆汽车就好比是一个线程，其中的道路就好比是线程运行时所需要的各种公共资源。如果交通管理系统没能正确的调度其上运行的车辆，让南北行驶的汽车（线程1）和东西行驶的汽车（线程2）同时经过（操作）了交通路口（公共资源）而出了车祸（出现脏数据），这就是没解决好正确性问题；如果因为交通系统调度不合理导致很多车辆相互“顶牛”（A线程拿着B线程要用的资源1，B线程拿着A线程要用的资源2，大家都不释放），互不让路，这就会出现可行性问题；一个调度良好的交通系统能让车辆的吞吐率大幅度提升，这就是高效性问题。</p>\n<p>这三大问题正确性是基本，不管是不是并发编程，首先你要保证执行结果是正确的；其次是可行性，程序如果引入了java并发编程先不说效率能提升多少，最起码程序能够顺利执行完成；最后是高效性问题，在满足正确性和可行性时，我们希望我们的程序能在java并发的加持下，相较于单线程顺序执行的程序能更快地完成任务。栗子本系列文章就是围绕这三大问题展开的，而深入了解这三大问题，相信大家会对java多线程有一个更加深刻的认识。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-并发简史\"><a href=\"#1-并发简史\" class=\"headerlink\" title=\"1 并发简史\"></a>1 并发简史</h1><p>在计算机发明早期，一台计算机在同一时间只能运行一个程序。如果将人比作一台计算机的话，就是一个人在同一时间内只能做一件事情不能三心二意。就拿博主我给老婆做最爱吃的皮蛋瘦肉粥来说，要经历洗米、把米放锅中煮、切肉和皮蛋、找准火候放入肉和皮蛋、电饭煲闷煮、电饭煲提示灯亮后给老婆大人盛饭，我们要按照顺序执行每一步，在得到结果后再执行下一步，最后得到最终的结果。同样对于早期的计算机来说，交给它一个任务如计算1+2的结果并打印，其要先分别拿到1和2放到寄存器中、然后执行加法运算得出结果3、然后把3回写到内存中、最后把结果通过打印机输出到纸上。大略一看，这个观点似乎没什么问题，但是效率上其实还可以提升下，不管是在人做饭还是计算机执行算数任务这件事上。</p>\n<p>不管是人还是机器，都需要提高自身资源的使用效率。人在做饭时最主要使用的是眼睛、双手、和大脑，我们另外一个主要器官耳朵在做饭过程中的使用率并不是太高，这样我们就可以变做饭边听早间新闻提高我们自身器官的使用率，那么效率自然也就提升了。对于计算机来说道理也是相同，在计算机执行计算任务时主要使用的是CPU，在计算机回写计算结果时使用的主要是I/O设备，如果我们能让计算机在执行1+2任务的计算部分时，能让闲置的I/O设备忙起来搞其它任务的输入或者输出部分的工作；亦或在计算机通过I/O设备将1+2的计算结果打印到纸上时，让闲置的CPU来执行其它任务的计算部分。那么假设本来需要两个小时完成的类似1+2这种计算结果并打印的大量任务，现在提升效率后大体只需要一个小时就能完成了。</p>\n<p>人们为了提升计算机各种设备的使用效率，引入了操作系统来统一管理计算机中的各种设备。所有的任务只需要和操作系统打交道，由操作系统统一调度计算机中的各种设备，尽最大可能保证各种设备在同一时间没有被闲置。操作系统除了保证各种设备没有被闲置外，还要保证各种任务在使用计算机设备时尽可能的公平，当我们用计算机的CPU解码mp3文件听歌时，不能因要执行1+2的计算任务把CPU抢占过去后不能听歌曲了，操作系统会把任务对CPU的使用时间切成无数小的几毫秒的时间片段，每个任务交替的获取使用CPU的时间片段来保证各个任务在执行顺序上的公平。不同任务对CPU按照时间片来交替使用，这个叫做并发。</p>\n<h1 id=\"2-java中的并发编程\"><a href=\"#2-java中的并发编程\" class=\"headerlink\" title=\"2 java中的并发编程\"></a>2 java中的并发编程</h1><p>上节我们知道计算系统分配CPU时间片的最小单位是一个个具体的任务，操作系统提供线程的概念给各种各样的程序，程序把一个大任务按照不同的性质分隔成小任务，每个小任务被封装在一个线程中交给操作系统来调度执行。同一个程序中的线程有如下特点：</p>\n<ul>\n<li><p>资源共享，操作系统分配给程序的各种资源对于线程来说都是共享的，如内存，CPU等。</p>\n</li>\n<li><p>线程之间是交替执行的，一个程序中的线程一般是不会少于机器的CPU数量的，这势必导致同一时间点，并不是所有的程序线程都在运行。</p>\n</li>\n</ul>\n<p>java中的并发编程问题也就是对线程和线程能访问到的资源的管理问题，即怎样管理线程和资源才能让程序的执行效率更高同时不出差错。具体来说就是解决以下三大问题：</p>\n<ol>\n<li><p>正确性问题。由于线程可以共享程序中的各种资源，这有可能导致多个线程对同一个资源的竞争使用，使原来单线程顺序执行时正确的程序，在多线程下出现问题。</p>\n</li>\n<li><p>可行性问题。由于对锁的管理不当，导致发生死锁问题，而程序中的死锁可能导致程序“僵死”，没办法完成指定的任务。当然多线程的可行性问题不全是死锁导致的，还有线程饥饿，活锁等多种可能。</p>\n</li>\n<li><p>高效性问题。引入多线程后原本一个线程用来执行任务现在交给多个线程一起执行了，效率一定会更高吗？其实并不是绝对的，为了保证多线程程序的正确性和可行性，势必会引入管理成本，同时线程在切换时间片的时候也会有成本。如果平衡不好这些成本，多线程的引入可能带来的是效率的倒退。</p>\n</li>\n</ol>\n<p>这里栗子给大家举个例子,多线程程序就好比是一个交通系统，一辆汽车就好比是一个线程，其中的道路就好比是线程运行时所需要的各种公共资源。如果交通管理系统没能正确的调度其上运行的车辆，让南北行驶的汽车（线程1）和东西行驶的汽车（线程2）同时经过（操作）了交通路口（公共资源）而出了车祸（出现脏数据），这就是没解决好正确性问题；如果因为交通系统调度不合理导致很多车辆相互“顶牛”（A线程拿着B线程要用的资源1，B线程拿着A线程要用的资源2，大家都不释放），互不让路，这就会出现可行性问题；一个调度良好的交通系统能让车辆的吞吐率大幅度提升，这就是高效性问题。</p>\n<p>这三大问题正确性是基本，不管是不是并发编程，首先你要保证执行结果是正确的；其次是可行性，程序如果引入了java并发编程先不说效率能提升多少，最起码程序能够顺利执行完成；最后是高效性问题，在满足正确性和可行性时，我们希望我们的程序能在java并发的加持下，相较于单线程顺序执行的程序能更快地完成任务。栗子本系列文章就是围绕这三大问题展开的，而深入了解这三大问题，相信大家会对java多线程有一个更加深刻的认识。</p>\n"},{"title":"01 spring解决循环源码分析","date":"2020-05-08T08:46:13.000Z","_content":"# 0 看前必读\n\n先看下 \n[00 spring源码剖析系列说明](http://aworker.cn/2020/05/07/java/spring/post0/post0/)\n\n# 1 什么是循环依赖\n\n\n循环依赖在spring框架中有一个专有名词叫 *Circular dependencies*，其具体是指受spring管理的两个bean对象 Bean1和Bean2，Bean1中有成员变量Bean2；Bean2中有成员变量Bean1。具体代码case如下：\n\n代码结构如图：\n\n![代码结构图](https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/spring/post1/spring_post1_code_struct.png)\n\n前前后后一共使用了四个类，其中两个Bean类如下：\n\n```aidl\n@Component\npublic class Chicken {\n    @Autowired\n    Egg egg;\n}\n\n```\n\n```aidl\n@Component\npublic class Egg {\n    @Autowired\n    Chicken chicken;\n}\n```\n\n一个配置类：\n\n```aidl\n@ComponentScan(\"spring.post1.beans\")\npublic class Config {\n\n}\n```\n\n一个简单的main方法启动类：\n\n```aidl\npublic class DemoSpringCircularDependencies {\n    public static void main(String[] args) {\n        AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(Config.class);\n        Chicken chicken = ac.getBean(\"chicken\", Chicken.class);\n        System.out.println(chicken);\n    }\n}\n```\n\n通过代码可以看出，本章主要讨论下spring怎么解决基于@AutoWired注解的Bean的循环依赖问题。而两个循环依赖的Bean就是Chiken（里面需要属性Egg）和Egg（里面需要属性Chicken）。\n\n# 2 前置知识\n\n+ 学习本文前需要对spring的基于注解的bean管理配置方式有基本的了解，不然看不懂上述4个类的作用，那么就无从谈及学习spring源码了，本系列的文章也不是基本的spring配置学习文章，这部分知识自行google。\n\n+ 需要对jdk8的lambda有基础的了解。\n\n\n# 3 源码分析\n\n## 3.1 源码栈帧\n首先我们先看下需要分析的源码的主要栈帧：\n\n![源码栈帧图](https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/spring/post1/bean_create_process_of_CD.jpg)\n\n先对上图做简单的说明，上图中的每蓝色小块代表一个方法，里面的数字部分表示方法的执行先后顺序（数字小的先执行）。两个相邻的方法之间大数字方法是程序在执行小数字方法的过程中要调用的方法（和debug时的的栈信息类似）。我们对源码的分析也将按照“创建所有单例Bean”，“创建Chicken对象”，“填充Chicken对象属性”，“创建Egg对象”，“填充Egg对象属性”，“获取Chicken对象”等顺序进行。\n\n## 3.2 创建所有单例Bean\n\n方法1. 是AnnotationConfigApplicationContext类的构造方法，构造方法引出对Bean的初始化创建操作。其中可以留意下方法2. 中要执行的**finishBeanFactoryInitialization**方法也就是源码栈帧图中的3.方法。在方法3.上面有一句英文注释： “ // Instantiate all remaining (non-lazy-init) singletons. ”，清晰的表明方法3.的主要目的就是要创建剩下没被创建的非懒加载的单例对象。那么我们定义的两个Bean对象Chiken和Egg显然是在这个方法里面创建的，至于为什么是“剩下的”而不是所有的，其它的非懒加载的单例对象是在哪里创建的，不是本文要描述的问题。\n\n## 3.3 创建Chicken对象\n\nspring创建在创建Bean对象前会给每个Bean对象创建一个BeanDefinition对象，BeanDefinition对象会搜集用户定义的关于Bean的各种配置信息，如这个Bean对象的类型，这个Bean对象的id和name，是否为单例对象等等，这些配置信息可以是xml形式的配置文件，也可以是基于注解的配置信息。\n\n以BeanDefinition的形式搜集了这些信息后，spring就开始初始化非懒加载的单例对象了（**这里我们只分析我们自己定义的和循环依赖相关的两个Bean对象Chicken和Egg的加载过程**）。也就是执行 5. getBean方法。方法5. 是个空壳方法其内部调用的是方法 6. doGetBean方法。doGetBean方法执行过程中会执行一个名为getSingleton(String beanName, boolean allowEarlyReference) 的方法。此方法定义如下：\n\n```\nprotected Object getSingleton(String beanName, boolean allowEarlyReference) {\n\t\tObject singletonObject = this.singletonObjects.get(beanName);\n\t\tif (singletonObject == null && isSingletonCurrentlyInCreation(beanName)) {\n\t\t\tsynchronized (this.singletonObjects) {\n\t\t\t\tsingletonObject = this.earlySingletonObjects.get(beanName);\n\t\t\t\tif (singletonObject == null && allowEarlyReference) {\n\t\t\t\t\tObjectFactory<?> singletonFactory = this.singletonFactories.get(beanName);\n\t\t\t\t\tif (singletonFactory != null) {\n\t\t\t\t\t\tsingletonObject = singletonFactory.getObject();\n\t\t\t\t\t\tthis.earlySingletonObjects.put(beanName, singletonObject);\n\t\t\t\t\t\tthis.singletonFactories.remove(beanName);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn singletonObject;\n\t}\n```\n其主要流程就是通过beanName参数查看先查看map对象*singletonObjects* 中是否有对应名称的Bean对象，有返回此Bean对象；没有查看map对象 *earlySingletonObjects* 中是否有对应名称的Bean对象，有返回此Bean对象；没有查看map对象 *singletonFactories* 是否有对应名称的ObjectFactory对象，有通过*ObjectFactory*对象的*getObject*方法获取到对应的Bean对象，然后清除 *singletonFactories* 对应的beanName的映射，同时将得到的Bean对象放到 *earlySingletonObjects* 中。这其中还有一个方法*isSingletonCurrentlyInCreation(String beanName)* 其内部是通过查看一个名为singletonsCurrentlyInCreation的Set对象是否包含指定的beanName,来判断这个单例bean是否正在创建bean对象。\n\n这三个Map对象和一个Set对象就是Spring中解决循环依赖非常重要的缓存，一下我们简称 “**三Map一Set**”，三个map对象因其在执行获取beanName对应的Bean对象的过程中的先后执行顺序，分别简称为 一级缓存、二级缓存、三级缓存。\n\n+ singletonObjects：一级缓存。此缓存中的Bean对象是经历Spring完整生命周期的Bean对象，\n\n+ earlySingletonObjects：二级缓存。此缓存中的Bean对象是已经通过创建出来的但没有经历spring完整的生命周期的Bean对象。\n\n+ singletonFactories：三级缓存。此缓存存在的是beanName和能获取Bean对象的一个工厂类*ObjectFactory*对象。\n\n方法6. doGetBean 第一次调用 getSingleton(String beanName) 方法时从三个缓存中都没能获得参数chicken对应的Bean对象，程序继续执行到方法7. getSingleton(String beanName, ObjectFactory<?> singletonFactory) ，7. 方法中会执行一个 名为 *beforeSingletonCreation(String beanName)* 的方法，这个方法会在我们上文提到的中的三Map一Set中的Set添加对应的beanName（chicken）表示此chicken对应的单例Bean处在正在创建过程中，程序继续执行执行到 8. getObject() 方法，方法8. 是一个lambada对象对应的方法，其调用的是方法9. createBean方法进入Bean的创建过程。方法9. 中我们重点关注其执行的方法10. doCreateBean ，此方法是真正执行bean对象的创建的方法。在方法10. 中我们注意到其会执行一个名为 *addSingletonFactory* 方法，此方法会在我们提到的 三Map一Set中的 三级缓存singletonFactories添加一个beanName(chicken)对应的ObjectFactory对象，而后执行方法10. 中的方法11.  populateBean，此时程序传给方法11. 的三个参数分别为beanName:值为chicken、mbd：ChickenBean的BeanDefiniton对象、instanceWrapper：通过构造方法创建的一个Chicken对象，即Spring注解中经常提到的raw bean对象。由方法11.的名称可知，此类的主要目的是填充Chicken对象中的属性（Egg对象），循环依赖正是在此方法中解决的。\n\n## 3.4 填充Chicken对象属性\n\n紧接上面小节，方法11.中spring通过在Chicken类中的@Autowired 注解来发现其需要的属性:Egg对象并填充其值，这个过程在方法12. postProcessProperties方法中执行，顺便提一句@Autowired注解依赖的属性由*AutowiredAnnotationBeanPostProcessor*类处理，@Resource注解依赖的属性由*CommonAnnotationBeanPostProcessor* 类处理。\n而方法13. 到方法17. 主要作用就是找到合适的beanName以便用来通过此beanName找到对应的Bean来填充Chicken中的Egg对象，此部分代码和本文主旨无关以后的文章会分析，感兴趣的童鞋可以自行debug看下代码。\n\n## 3.5 创建Egg对象\n\n紧接上面小节，spring通过方法17. resolveCandidate将找到的合适beanName(egg)传递下来，通过方法18. getBean 来执行对Egg Bean对象的获取操作。此小节调用的方法栈和 “*3.3 创建chicken对象*” 小节的方法栈是一样的，唯一的区别是3.3小节传递的beanName参数值为chicken，而本小节传递的beanName参数为egg。\n\n## 3.6 填充Egg对象属性\n\n本小节对标的是 “*3.4 填充Chicken对象属性*”小节，两个小节调用的方法栈是一样的，区别也是参数的不同而已。Spring发现Egg对象需要注入一个Chicken对象。\n\n## 3.7 获取Chicken对象\n\n这里我们分析的方法31. getBean 和方法18. getBean都是因为我们自己定义的Bean对象中有需要的注入的Bean对象。但是方法31. 传递的参数是chicken，而Chicken对象在 3.3小节中分析得知，其在三Map一Set中的第三级缓存*singletonFactories*存放了一个对应的ObjectFactory对象。spring通过这个ObjectFactory对象获取到了对应的Chicken 对象，而避免了循环依赖。\n\n## 3.8 缓存创建完的Egg 和缓存创建完的Chicken\n\n通过3.6小节我们获取到了Egg对象需要的成员变量Chicken对象。随着方法栈帧的层层返回，我们将焦点聚焦在由方法21.返回后的方法20.中，在程序执行完方法21. getObject 并获取到经历完Bean生命周期的Egg Bean后，其在方法20. 中还要执行两个比较重要的方法 **afterSingletonCreation** 和 **addSingleton**，其中前者会把三Map一Set中的Set对象singletonsCurrentlyInCreation中的egg移除，表示此Bean对象不是正在创建的Bean对象，Bean创建已经完成；后者会把Egg Bean存放在一级缓存中，同时清空二级缓存和三级缓存中egg对应的映射，至此Egg Bean的spring生命周期已经大体完成。Chicken对象也会执行**afterSingletonCreation** 和 **addSingleton** 两个方法来完成Chicken Bean的spring生命周期。\n\n## 3.9 源码分析小结\n\n+ 创建chicken对象、创建Egg对象：步骤主要解决一个Bean的raw bean对象的创建和的前期准备工作,和本文循环依赖相关的主要是对三Map一Set的对象的保存的内容的修改。\n\n+ 填充Chicken对象属性、填充Chicken对象属性：本文中主要通过AutowiredAnnotationBeanPostProcessor类完成依赖对象的搜集和适合依赖对象的beanName的筛选。\n\n+ 获取Chicken对象：主要是通过第三级缓存来获取，避免了Chicken对象的重复创建而进入一个死循环。\n\n+ 缓存创建完的Egg 和缓存创建完的Chicken：完成善后工作，将走完spring生命周期的Egg Bean和Chicken Bean放到一级缓存中，供客户端程序从spring中获取使用。\n\n# 4 缓存数据变化\n\n在 “3 源码分析” 章节中，随着程序运行过程中除了有由方法调用和方法返回而产生的线程方法栈图中方法的压栈和出栈外。在这进进出出的背后发生改变的是我们的**三Map一Set** 中的数据。\n\n在源码分析的开头小节“*3.3 创建Chicken对象*” 和结尾小节“3.8 缓存创建完的Egg 和缓存创建完的Chicken”我们有对三Map一Set的分析，但着并不是说只有这两个小节的部分有数据变更，而是其缓存变化的原理和这连个小节一直，唯一的区别是方法调用的参数不同。整个数据变化图如下：\n\n![数据流通图](https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/spring/post1/cache_process_of_CD.jpg)\n\n图中每个状态图都有一个“[a,b)”形式的步骤指示器，其中a,b分别表示 “3.1小节” 中源码栈帧图中一个方法数字，而括号用的是高等数学中常见的方式左闭右开方式，表示在程序在执行方法a到方法b（包含a不包含b）过程中缓存数据的状态和其下面的表格一致。\n\n通过对八个表格数据的观察我们可以发现，对于同一个beanName所映射的对象，基本上经历从第三级缓存、第二级缓存、第一级缓存，的一个升级过程。而对网上经常困惑的第三级缓存的作用（认为第三级缓存没有必要存在）,博主认为存在第三级缓存是基于以下两个事实的：\n\n1. 某些Bean对象（并不是所有的bean对象）在创建过程中且尚未创建完时就会被其它Bean对象所引用的问题（就是循环依赖，貌似是一句废话^_^）。\n\n2. Bean的生命周期过程是一个成本较高的过程。\n\n本文中只有Chicken 对象在创建过程中有被其它对象引用而Egg对象没有。因为第三级缓存存储的是一个raw bean后续创建的方法，那么对于在创建时被其它对象引用的Chicken对象来说，可以执行完第三级缓存中存储的bean对象后续的处理方法（AOP的功能就是在此实现的）后将Chicken bean返回，对于没有在创建过程中被引用的Egg对象来说，其只是浪费第三级缓存中的一点点内存，而避免重复执行spring对Egg Bean的某些生命周期逻辑的重复执行，这些重复的逻辑很可能是很高成本的过程，如AOP的实现。\n\n\n\n\n\n\n# 5 总结\n\n编程界有个很著名的说法：“算法加数据结构等于程序”，本文的“3 源码分析”和“4 缓存数据变化”分别充当了spring解决基于@AutoWired注解的Bean的循环依赖程序中的算法和数据结构。和理解其关键是对“**三Map一Set**”数据变化的深入理解。\n\n\n\n\n\n\n\n\n# 参考资料\n\n[1、Spring Circular Dependencies](https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-dependency-resolution)","source":"_posts/java/spring/post1/post1.md","raw":"---\ntitle: 01 spring解决循环源码分析\ndate: 2020-05-08 16:46:13\ncategories:\n    - spring\n    - spring源码剖析系列\ntags:\n---\n# 0 看前必读\n\n先看下 \n[00 spring源码剖析系列说明](http://aworker.cn/2020/05/07/java/spring/post0/post0/)\n\n# 1 什么是循环依赖\n\n\n循环依赖在spring框架中有一个专有名词叫 *Circular dependencies*，其具体是指受spring管理的两个bean对象 Bean1和Bean2，Bean1中有成员变量Bean2；Bean2中有成员变量Bean1。具体代码case如下：\n\n代码结构如图：\n\n![代码结构图](https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/spring/post1/spring_post1_code_struct.png)\n\n前前后后一共使用了四个类，其中两个Bean类如下：\n\n```aidl\n@Component\npublic class Chicken {\n    @Autowired\n    Egg egg;\n}\n\n```\n\n```aidl\n@Component\npublic class Egg {\n    @Autowired\n    Chicken chicken;\n}\n```\n\n一个配置类：\n\n```aidl\n@ComponentScan(\"spring.post1.beans\")\npublic class Config {\n\n}\n```\n\n一个简单的main方法启动类：\n\n```aidl\npublic class DemoSpringCircularDependencies {\n    public static void main(String[] args) {\n        AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(Config.class);\n        Chicken chicken = ac.getBean(\"chicken\", Chicken.class);\n        System.out.println(chicken);\n    }\n}\n```\n\n通过代码可以看出，本章主要讨论下spring怎么解决基于@AutoWired注解的Bean的循环依赖问题。而两个循环依赖的Bean就是Chiken（里面需要属性Egg）和Egg（里面需要属性Chicken）。\n\n# 2 前置知识\n\n+ 学习本文前需要对spring的基于注解的bean管理配置方式有基本的了解，不然看不懂上述4个类的作用，那么就无从谈及学习spring源码了，本系列的文章也不是基本的spring配置学习文章，这部分知识自行google。\n\n+ 需要对jdk8的lambda有基础的了解。\n\n\n# 3 源码分析\n\n## 3.1 源码栈帧\n首先我们先看下需要分析的源码的主要栈帧：\n\n![源码栈帧图](https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/spring/post1/bean_create_process_of_CD.jpg)\n\n先对上图做简单的说明，上图中的每蓝色小块代表一个方法，里面的数字部分表示方法的执行先后顺序（数字小的先执行）。两个相邻的方法之间大数字方法是程序在执行小数字方法的过程中要调用的方法（和debug时的的栈信息类似）。我们对源码的分析也将按照“创建所有单例Bean”，“创建Chicken对象”，“填充Chicken对象属性”，“创建Egg对象”，“填充Egg对象属性”，“获取Chicken对象”等顺序进行。\n\n## 3.2 创建所有单例Bean\n\n方法1. 是AnnotationConfigApplicationContext类的构造方法，构造方法引出对Bean的初始化创建操作。其中可以留意下方法2. 中要执行的**finishBeanFactoryInitialization**方法也就是源码栈帧图中的3.方法。在方法3.上面有一句英文注释： “ // Instantiate all remaining (non-lazy-init) singletons. ”，清晰的表明方法3.的主要目的就是要创建剩下没被创建的非懒加载的单例对象。那么我们定义的两个Bean对象Chiken和Egg显然是在这个方法里面创建的，至于为什么是“剩下的”而不是所有的，其它的非懒加载的单例对象是在哪里创建的，不是本文要描述的问题。\n\n## 3.3 创建Chicken对象\n\nspring创建在创建Bean对象前会给每个Bean对象创建一个BeanDefinition对象，BeanDefinition对象会搜集用户定义的关于Bean的各种配置信息，如这个Bean对象的类型，这个Bean对象的id和name，是否为单例对象等等，这些配置信息可以是xml形式的配置文件，也可以是基于注解的配置信息。\n\n以BeanDefinition的形式搜集了这些信息后，spring就开始初始化非懒加载的单例对象了（**这里我们只分析我们自己定义的和循环依赖相关的两个Bean对象Chicken和Egg的加载过程**）。也就是执行 5. getBean方法。方法5. 是个空壳方法其内部调用的是方法 6. doGetBean方法。doGetBean方法执行过程中会执行一个名为getSingleton(String beanName, boolean allowEarlyReference) 的方法。此方法定义如下：\n\n```\nprotected Object getSingleton(String beanName, boolean allowEarlyReference) {\n\t\tObject singletonObject = this.singletonObjects.get(beanName);\n\t\tif (singletonObject == null && isSingletonCurrentlyInCreation(beanName)) {\n\t\t\tsynchronized (this.singletonObjects) {\n\t\t\t\tsingletonObject = this.earlySingletonObjects.get(beanName);\n\t\t\t\tif (singletonObject == null && allowEarlyReference) {\n\t\t\t\t\tObjectFactory<?> singletonFactory = this.singletonFactories.get(beanName);\n\t\t\t\t\tif (singletonFactory != null) {\n\t\t\t\t\t\tsingletonObject = singletonFactory.getObject();\n\t\t\t\t\t\tthis.earlySingletonObjects.put(beanName, singletonObject);\n\t\t\t\t\t\tthis.singletonFactories.remove(beanName);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn singletonObject;\n\t}\n```\n其主要流程就是通过beanName参数查看先查看map对象*singletonObjects* 中是否有对应名称的Bean对象，有返回此Bean对象；没有查看map对象 *earlySingletonObjects* 中是否有对应名称的Bean对象，有返回此Bean对象；没有查看map对象 *singletonFactories* 是否有对应名称的ObjectFactory对象，有通过*ObjectFactory*对象的*getObject*方法获取到对应的Bean对象，然后清除 *singletonFactories* 对应的beanName的映射，同时将得到的Bean对象放到 *earlySingletonObjects* 中。这其中还有一个方法*isSingletonCurrentlyInCreation(String beanName)* 其内部是通过查看一个名为singletonsCurrentlyInCreation的Set对象是否包含指定的beanName,来判断这个单例bean是否正在创建bean对象。\n\n这三个Map对象和一个Set对象就是Spring中解决循环依赖非常重要的缓存，一下我们简称 “**三Map一Set**”，三个map对象因其在执行获取beanName对应的Bean对象的过程中的先后执行顺序，分别简称为 一级缓存、二级缓存、三级缓存。\n\n+ singletonObjects：一级缓存。此缓存中的Bean对象是经历Spring完整生命周期的Bean对象，\n\n+ earlySingletonObjects：二级缓存。此缓存中的Bean对象是已经通过创建出来的但没有经历spring完整的生命周期的Bean对象。\n\n+ singletonFactories：三级缓存。此缓存存在的是beanName和能获取Bean对象的一个工厂类*ObjectFactory*对象。\n\n方法6. doGetBean 第一次调用 getSingleton(String beanName) 方法时从三个缓存中都没能获得参数chicken对应的Bean对象，程序继续执行到方法7. getSingleton(String beanName, ObjectFactory<?> singletonFactory) ，7. 方法中会执行一个 名为 *beforeSingletonCreation(String beanName)* 的方法，这个方法会在我们上文提到的中的三Map一Set中的Set添加对应的beanName（chicken）表示此chicken对应的单例Bean处在正在创建过程中，程序继续执行执行到 8. getObject() 方法，方法8. 是一个lambada对象对应的方法，其调用的是方法9. createBean方法进入Bean的创建过程。方法9. 中我们重点关注其执行的方法10. doCreateBean ，此方法是真正执行bean对象的创建的方法。在方法10. 中我们注意到其会执行一个名为 *addSingletonFactory* 方法，此方法会在我们提到的 三Map一Set中的 三级缓存singletonFactories添加一个beanName(chicken)对应的ObjectFactory对象，而后执行方法10. 中的方法11.  populateBean，此时程序传给方法11. 的三个参数分别为beanName:值为chicken、mbd：ChickenBean的BeanDefiniton对象、instanceWrapper：通过构造方法创建的一个Chicken对象，即Spring注解中经常提到的raw bean对象。由方法11.的名称可知，此类的主要目的是填充Chicken对象中的属性（Egg对象），循环依赖正是在此方法中解决的。\n\n## 3.4 填充Chicken对象属性\n\n紧接上面小节，方法11.中spring通过在Chicken类中的@Autowired 注解来发现其需要的属性:Egg对象并填充其值，这个过程在方法12. postProcessProperties方法中执行，顺便提一句@Autowired注解依赖的属性由*AutowiredAnnotationBeanPostProcessor*类处理，@Resource注解依赖的属性由*CommonAnnotationBeanPostProcessor* 类处理。\n而方法13. 到方法17. 主要作用就是找到合适的beanName以便用来通过此beanName找到对应的Bean来填充Chicken中的Egg对象，此部分代码和本文主旨无关以后的文章会分析，感兴趣的童鞋可以自行debug看下代码。\n\n## 3.5 创建Egg对象\n\n紧接上面小节，spring通过方法17. resolveCandidate将找到的合适beanName(egg)传递下来，通过方法18. getBean 来执行对Egg Bean对象的获取操作。此小节调用的方法栈和 “*3.3 创建chicken对象*” 小节的方法栈是一样的，唯一的区别是3.3小节传递的beanName参数值为chicken，而本小节传递的beanName参数为egg。\n\n## 3.6 填充Egg对象属性\n\n本小节对标的是 “*3.4 填充Chicken对象属性*”小节，两个小节调用的方法栈是一样的，区别也是参数的不同而已。Spring发现Egg对象需要注入一个Chicken对象。\n\n## 3.7 获取Chicken对象\n\n这里我们分析的方法31. getBean 和方法18. getBean都是因为我们自己定义的Bean对象中有需要的注入的Bean对象。但是方法31. 传递的参数是chicken，而Chicken对象在 3.3小节中分析得知，其在三Map一Set中的第三级缓存*singletonFactories*存放了一个对应的ObjectFactory对象。spring通过这个ObjectFactory对象获取到了对应的Chicken 对象，而避免了循环依赖。\n\n## 3.8 缓存创建完的Egg 和缓存创建完的Chicken\n\n通过3.6小节我们获取到了Egg对象需要的成员变量Chicken对象。随着方法栈帧的层层返回，我们将焦点聚焦在由方法21.返回后的方法20.中，在程序执行完方法21. getObject 并获取到经历完Bean生命周期的Egg Bean后，其在方法20. 中还要执行两个比较重要的方法 **afterSingletonCreation** 和 **addSingleton**，其中前者会把三Map一Set中的Set对象singletonsCurrentlyInCreation中的egg移除，表示此Bean对象不是正在创建的Bean对象，Bean创建已经完成；后者会把Egg Bean存放在一级缓存中，同时清空二级缓存和三级缓存中egg对应的映射，至此Egg Bean的spring生命周期已经大体完成。Chicken对象也会执行**afterSingletonCreation** 和 **addSingleton** 两个方法来完成Chicken Bean的spring生命周期。\n\n## 3.9 源码分析小结\n\n+ 创建chicken对象、创建Egg对象：步骤主要解决一个Bean的raw bean对象的创建和的前期准备工作,和本文循环依赖相关的主要是对三Map一Set的对象的保存的内容的修改。\n\n+ 填充Chicken对象属性、填充Chicken对象属性：本文中主要通过AutowiredAnnotationBeanPostProcessor类完成依赖对象的搜集和适合依赖对象的beanName的筛选。\n\n+ 获取Chicken对象：主要是通过第三级缓存来获取，避免了Chicken对象的重复创建而进入一个死循环。\n\n+ 缓存创建完的Egg 和缓存创建完的Chicken：完成善后工作，将走完spring生命周期的Egg Bean和Chicken Bean放到一级缓存中，供客户端程序从spring中获取使用。\n\n# 4 缓存数据变化\n\n在 “3 源码分析” 章节中，随着程序运行过程中除了有由方法调用和方法返回而产生的线程方法栈图中方法的压栈和出栈外。在这进进出出的背后发生改变的是我们的**三Map一Set** 中的数据。\n\n在源码分析的开头小节“*3.3 创建Chicken对象*” 和结尾小节“3.8 缓存创建完的Egg 和缓存创建完的Chicken”我们有对三Map一Set的分析，但着并不是说只有这两个小节的部分有数据变更，而是其缓存变化的原理和这连个小节一直，唯一的区别是方法调用的参数不同。整个数据变化图如下：\n\n![数据流通图](https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/spring/post1/cache_process_of_CD.jpg)\n\n图中每个状态图都有一个“[a,b)”形式的步骤指示器，其中a,b分别表示 “3.1小节” 中源码栈帧图中一个方法数字，而括号用的是高等数学中常见的方式左闭右开方式，表示在程序在执行方法a到方法b（包含a不包含b）过程中缓存数据的状态和其下面的表格一致。\n\n通过对八个表格数据的观察我们可以发现，对于同一个beanName所映射的对象，基本上经历从第三级缓存、第二级缓存、第一级缓存，的一个升级过程。而对网上经常困惑的第三级缓存的作用（认为第三级缓存没有必要存在）,博主认为存在第三级缓存是基于以下两个事实的：\n\n1. 某些Bean对象（并不是所有的bean对象）在创建过程中且尚未创建完时就会被其它Bean对象所引用的问题（就是循环依赖，貌似是一句废话^_^）。\n\n2. Bean的生命周期过程是一个成本较高的过程。\n\n本文中只有Chicken 对象在创建过程中有被其它对象引用而Egg对象没有。因为第三级缓存存储的是一个raw bean后续创建的方法，那么对于在创建时被其它对象引用的Chicken对象来说，可以执行完第三级缓存中存储的bean对象后续的处理方法（AOP的功能就是在此实现的）后将Chicken bean返回，对于没有在创建过程中被引用的Egg对象来说，其只是浪费第三级缓存中的一点点内存，而避免重复执行spring对Egg Bean的某些生命周期逻辑的重复执行，这些重复的逻辑很可能是很高成本的过程，如AOP的实现。\n\n\n\n\n\n\n# 5 总结\n\n编程界有个很著名的说法：“算法加数据结构等于程序”，本文的“3 源码分析”和“4 缓存数据变化”分别充当了spring解决基于@AutoWired注解的Bean的循环依赖程序中的算法和数据结构。和理解其关键是对“**三Map一Set**”数据变化的深入理解。\n\n\n\n\n\n\n\n\n# 参考资料\n\n[1、Spring Circular Dependencies](https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-dependency-resolution)","slug":"java/spring/post1/post1","published":1,"updated":"2020-05-13T09:44:07.233Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckag4s7qt000c3oie6dkjdy77","content":"<h1 id=\"0-看前必读\"><a href=\"#0-看前必读\" class=\"headerlink\" title=\"0 看前必读\"></a>0 看前必读</h1><p>先看下<br><a href=\"http://aworker.cn/2020/05/07/java/spring/post0/post0/\">00 spring源码剖析系列说明</a></p>\n<h1 id=\"1-什么是循环依赖\"><a href=\"#1-什么是循环依赖\" class=\"headerlink\" title=\"1 什么是循环依赖\"></a>1 什么是循环依赖</h1><p>循环依赖在spring框架中有一个专有名词叫 <em>Circular dependencies</em>，其具体是指受spring管理的两个bean对象 Bean1和Bean2，Bean1中有成员变量Bean2；Bean2中有成员变量Bean1。具体代码case如下：</p>\n<p>代码结构如图：</p>\n<p><img src=\"https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/spring/post1/spring_post1_code_struct.png\" alt=\"代码结构图\"></p>\n<p>前前后后一共使用了四个类，其中两个Bean类如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Component</span><br><span class=\"line\">public class Chicken &#123;</span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    Egg egg;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Component</span><br><span class=\"line\">public class Egg &#123;</span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    Chicken chicken;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>一个配置类：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@ComponentScan(&quot;spring.post1.beans&quot;)</span><br><span class=\"line\">public class Config &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>一个简单的main方法启动类：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class DemoSpringCircularDependencies &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(Config.class);</span><br><span class=\"line\">        Chicken chicken = ac.getBean(&quot;chicken&quot;, Chicken.class);</span><br><span class=\"line\">        System.out.println(chicken);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过代码可以看出，本章主要讨论下spring怎么解决基于@AutoWired注解的Bean的循环依赖问题。而两个循环依赖的Bean就是Chiken（里面需要属性Egg）和Egg（里面需要属性Chicken）。</p>\n<h1 id=\"2-前置知识\"><a href=\"#2-前置知识\" class=\"headerlink\" title=\"2 前置知识\"></a>2 前置知识</h1><ul>\n<li><p>学习本文前需要对spring的基于注解的bean管理配置方式有基本的了解，不然看不懂上述4个类的作用，那么就无从谈及学习spring源码了，本系列的文章也不是基本的spring配置学习文章，这部分知识自行google。</p>\n</li>\n<li><p>需要对jdk8的lambda有基础的了解。</p>\n</li>\n</ul>\n<h1 id=\"3-源码分析\"><a href=\"#3-源码分析\" class=\"headerlink\" title=\"3 源码分析\"></a>3 源码分析</h1><h2 id=\"3-1-源码栈帧\"><a href=\"#3-1-源码栈帧\" class=\"headerlink\" title=\"3.1 源码栈帧\"></a>3.1 源码栈帧</h2><p>首先我们先看下需要分析的源码的主要栈帧：</p>\n<p><img src=\"https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/spring/post1/bean_create_process_of_CD.jpg\" alt=\"源码栈帧图\"></p>\n<p>先对上图做简单的说明，上图中的每蓝色小块代表一个方法，里面的数字部分表示方法的执行先后顺序（数字小的先执行）。两个相邻的方法之间大数字方法是程序在执行小数字方法的过程中要调用的方法（和debug时的的栈信息类似）。我们对源码的分析也将按照“创建所有单例Bean”，“创建Chicken对象”，“填充Chicken对象属性”，“创建Egg对象”，“填充Egg对象属性”，“获取Chicken对象”等顺序进行。</p>\n<h2 id=\"3-2-创建所有单例Bean\"><a href=\"#3-2-创建所有单例Bean\" class=\"headerlink\" title=\"3.2 创建所有单例Bean\"></a>3.2 创建所有单例Bean</h2><p>方法1. 是AnnotationConfigApplicationContext类的构造方法，构造方法引出对Bean的初始化创建操作。其中可以留意下方法2. 中要执行的<strong>finishBeanFactoryInitialization</strong>方法也就是源码栈帧图中的3.方法。在方法3.上面有一句英文注释： “ // Instantiate all remaining (non-lazy-init) singletons. ”，清晰的表明方法3.的主要目的就是要创建剩下没被创建的非懒加载的单例对象。那么我们定义的两个Bean对象Chiken和Egg显然是在这个方法里面创建的，至于为什么是“剩下的”而不是所有的，其它的非懒加载的单例对象是在哪里创建的，不是本文要描述的问题。</p>\n<h2 id=\"3-3-创建Chicken对象\"><a href=\"#3-3-创建Chicken对象\" class=\"headerlink\" title=\"3.3 创建Chicken对象\"></a>3.3 创建Chicken对象</h2><p>spring创建在创建Bean对象前会给每个Bean对象创建一个BeanDefinition对象，BeanDefinition对象会搜集用户定义的关于Bean的各种配置信息，如这个Bean对象的类型，这个Bean对象的id和name，是否为单例对象等等，这些配置信息可以是xml形式的配置文件，也可以是基于注解的配置信息。</p>\n<p>以BeanDefinition的形式搜集了这些信息后，spring就开始初始化非懒加载的单例对象了（<strong>这里我们只分析我们自己定义的和循环依赖相关的两个Bean对象Chicken和Egg的加载过程</strong>）。也就是执行 5. getBean方法。方法5. 是个空壳方法其内部调用的是方法 6. doGetBean方法。doGetBean方法执行过程中会执行一个名为getSingleton(String beanName, boolean allowEarlyReference) 的方法。此方法定义如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected Object getSingleton(String beanName, boolean allowEarlyReference) &#123;</span><br><span class=\"line\">\t\tObject singletonObject = this.singletonObjects.get(beanName);</span><br><span class=\"line\">\t\tif (singletonObject == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class=\"line\">\t\t\tsynchronized (this.singletonObjects) &#123;</span><br><span class=\"line\">\t\t\t\tsingletonObject = this.earlySingletonObjects.get(beanName);</span><br><span class=\"line\">\t\t\t\tif (singletonObject == null &amp;&amp; allowEarlyReference) &#123;</span><br><span class=\"line\">\t\t\t\t\tObjectFactory&lt;?&gt; singletonFactory = this.singletonFactories.get(beanName);</span><br><span class=\"line\">\t\t\t\t\tif (singletonFactory != null) &#123;</span><br><span class=\"line\">\t\t\t\t\t\tsingletonObject = singletonFactory.getObject();</span><br><span class=\"line\">\t\t\t\t\t\tthis.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class=\"line\">\t\t\t\t\t\tthis.singletonFactories.remove(beanName);</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn singletonObject;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<p>其主要流程就是通过beanName参数查看先查看map对象<em>singletonObjects</em> 中是否有对应名称的Bean对象，有返回此Bean对象；没有查看map对象 <em>earlySingletonObjects</em> 中是否有对应名称的Bean对象，有返回此Bean对象；没有查看map对象 <em>singletonFactories</em> 是否有对应名称的ObjectFactory对象，有通过<em>ObjectFactory<em>对象的</em>getObject*方法获取到对应的Bean对象，然后清除 *singletonFactories</em> 对应的beanName的映射，同时将得到的Bean对象放到 <em>earlySingletonObjects</em> 中。这其中还有一个方法<em>isSingletonCurrentlyInCreation(String beanName)</em> 其内部是通过查看一个名为singletonsCurrentlyInCreation的Set对象是否包含指定的beanName,来判断这个单例bean是否正在创建bean对象。</p>\n<p>这三个Map对象和一个Set对象就是Spring中解决循环依赖非常重要的缓存，一下我们简称 “<strong>三Map一Set</strong>”，三个map对象因其在执行获取beanName对应的Bean对象的过程中的先后执行顺序，分别简称为 一级缓存、二级缓存、三级缓存。</p>\n<ul>\n<li><p>singletonObjects：一级缓存。此缓存中的Bean对象是经历Spring完整生命周期的Bean对象，</p>\n</li>\n<li><p>earlySingletonObjects：二级缓存。此缓存中的Bean对象是已经通过创建出来的但没有经历spring完整的生命周期的Bean对象。</p>\n</li>\n<li><p>singletonFactories：三级缓存。此缓存存在的是beanName和能获取Bean对象的一个工厂类<em>ObjectFactory</em>对象。</p>\n</li>\n</ul>\n<p>方法6. doGetBean 第一次调用 getSingleton(String beanName) 方法时从三个缓存中都没能获得参数chicken对应的Bean对象，程序继续执行到方法7. getSingleton(String beanName, ObjectFactory&lt;?&gt; singletonFactory) ，7. 方法中会执行一个 名为 <em>beforeSingletonCreation(String beanName)</em> 的方法，这个方法会在我们上文提到的中的三Map一Set中的Set添加对应的beanName（chicken）表示此chicken对应的单例Bean处在正在创建过程中，程序继续执行执行到 8. getObject() 方法，方法8. 是一个lambada对象对应的方法，其调用的是方法9. createBean方法进入Bean的创建过程。方法9. 中我们重点关注其执行的方法10. doCreateBean ，此方法是真正执行bean对象的创建的方法。在方法10. 中我们注意到其会执行一个名为 <em>addSingletonFactory</em> 方法，此方法会在我们提到的 三Map一Set中的 三级缓存singletonFactories添加一个beanName(chicken)对应的ObjectFactory对象，而后执行方法10. 中的方法11.  populateBean，此时程序传给方法11. 的三个参数分别为beanName:值为chicken、mbd：ChickenBean的BeanDefiniton对象、instanceWrapper：通过构造方法创建的一个Chicken对象，即Spring注解中经常提到的raw bean对象。由方法11.的名称可知，此类的主要目的是填充Chicken对象中的属性（Egg对象），循环依赖正是在此方法中解决的。</p>\n<h2 id=\"3-4-填充Chicken对象属性\"><a href=\"#3-4-填充Chicken对象属性\" class=\"headerlink\" title=\"3.4 填充Chicken对象属性\"></a>3.4 填充Chicken对象属性</h2><p>紧接上面小节，方法11.中spring通过在Chicken类中的@Autowired 注解来发现其需要的属性:Egg对象并填充其值，这个过程在方法12. postProcessProperties方法中执行，顺便提一句@Autowired注解依赖的属性由<em>AutowiredAnnotationBeanPostProcessor<em>类处理，@Resource注解依赖的属性由</em>CommonAnnotationBeanPostProcessor</em> 类处理。<br>而方法13. 到方法17. 主要作用就是找到合适的beanName以便用来通过此beanName找到对应的Bean来填充Chicken中的Egg对象，此部分代码和本文主旨无关以后的文章会分析，感兴趣的童鞋可以自行debug看下代码。</p>\n<h2 id=\"3-5-创建Egg对象\"><a href=\"#3-5-创建Egg对象\" class=\"headerlink\" title=\"3.5 创建Egg对象\"></a>3.5 创建Egg对象</h2><p>紧接上面小节，spring通过方法17. resolveCandidate将找到的合适beanName(egg)传递下来，通过方法18. getBean 来执行对Egg Bean对象的获取操作。此小节调用的方法栈和 “<em>3.3 创建chicken对象</em>” 小节的方法栈是一样的，唯一的区别是3.3小节传递的beanName参数值为chicken，而本小节传递的beanName参数为egg。</p>\n<h2 id=\"3-6-填充Egg对象属性\"><a href=\"#3-6-填充Egg对象属性\" class=\"headerlink\" title=\"3.6 填充Egg对象属性\"></a>3.6 填充Egg对象属性</h2><p>本小节对标的是 “<em>3.4 填充Chicken对象属性</em>”小节，两个小节调用的方法栈是一样的，区别也是参数的不同而已。Spring发现Egg对象需要注入一个Chicken对象。</p>\n<h2 id=\"3-7-获取Chicken对象\"><a href=\"#3-7-获取Chicken对象\" class=\"headerlink\" title=\"3.7 获取Chicken对象\"></a>3.7 获取Chicken对象</h2><p>这里我们分析的方法31. getBean 和方法18. getBean都是因为我们自己定义的Bean对象中有需要的注入的Bean对象。但是方法31. 传递的参数是chicken，而Chicken对象在 3.3小节中分析得知，其在三Map一Set中的第三级缓存<em>singletonFactories</em>存放了一个对应的ObjectFactory对象。spring通过这个ObjectFactory对象获取到了对应的Chicken 对象，而避免了循环依赖。</p>\n<h2 id=\"3-8-缓存创建完的Egg-和缓存创建完的Chicken\"><a href=\"#3-8-缓存创建完的Egg-和缓存创建完的Chicken\" class=\"headerlink\" title=\"3.8 缓存创建完的Egg 和缓存创建完的Chicken\"></a>3.8 缓存创建完的Egg 和缓存创建完的Chicken</h2><p>通过3.6小节我们获取到了Egg对象需要的成员变量Chicken对象。随着方法栈帧的层层返回，我们将焦点聚焦在由方法21.返回后的方法20.中，在程序执行完方法21. getObject 并获取到经历完Bean生命周期的Egg Bean后，其在方法20. 中还要执行两个比较重要的方法 <strong>afterSingletonCreation</strong> 和 <strong>addSingleton</strong>，其中前者会把三Map一Set中的Set对象singletonsCurrentlyInCreation中的egg移除，表示此Bean对象不是正在创建的Bean对象，Bean创建已经完成；后者会把Egg Bean存放在一级缓存中，同时清空二级缓存和三级缓存中egg对应的映射，至此Egg Bean的spring生命周期已经大体完成。Chicken对象也会执行<strong>afterSingletonCreation</strong> 和 <strong>addSingleton</strong> 两个方法来完成Chicken Bean的spring生命周期。</p>\n<h2 id=\"3-9-源码分析小结\"><a href=\"#3-9-源码分析小结\" class=\"headerlink\" title=\"3.9 源码分析小结\"></a>3.9 源码分析小结</h2><ul>\n<li><p>创建chicken对象、创建Egg对象：步骤主要解决一个Bean的raw bean对象的创建和的前期准备工作,和本文循环依赖相关的主要是对三Map一Set的对象的保存的内容的修改。</p>\n</li>\n<li><p>填充Chicken对象属性、填充Chicken对象属性：本文中主要通过AutowiredAnnotationBeanPostProcessor类完成依赖对象的搜集和适合依赖对象的beanName的筛选。</p>\n</li>\n<li><p>获取Chicken对象：主要是通过第三级缓存来获取，避免了Chicken对象的重复创建而进入一个死循环。</p>\n</li>\n<li><p>缓存创建完的Egg 和缓存创建完的Chicken：完成善后工作，将走完spring生命周期的Egg Bean和Chicken Bean放到一级缓存中，供客户端程序从spring中获取使用。</p>\n</li>\n</ul>\n<h1 id=\"4-缓存数据变化\"><a href=\"#4-缓存数据变化\" class=\"headerlink\" title=\"4 缓存数据变化\"></a>4 缓存数据变化</h1><p>在 “3 源码分析” 章节中，随着程序运行过程中除了有由方法调用和方法返回而产生的线程方法栈图中方法的压栈和出栈外。在这进进出出的背后发生改变的是我们的<strong>三Map一Set</strong> 中的数据。</p>\n<p>在源码分析的开头小节“<em>3.3 创建Chicken对象</em>” 和结尾小节“3.8 缓存创建完的Egg 和缓存创建完的Chicken”我们有对三Map一Set的分析，但着并不是说只有这两个小节的部分有数据变更，而是其缓存变化的原理和这连个小节一直，唯一的区别是方法调用的参数不同。整个数据变化图如下：</p>\n<p><img src=\"https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/spring/post1/cache_process_of_CD.jpg\" alt=\"数据流通图\"></p>\n<p>图中每个状态图都有一个“[a,b)”形式的步骤指示器，其中a,b分别表示 “3.1小节” 中源码栈帧图中一个方法数字，而括号用的是高等数学中常见的方式左闭右开方式，表示在程序在执行方法a到方法b（包含a不包含b）过程中缓存数据的状态和其下面的表格一致。</p>\n<p>通过对八个表格数据的观察我们可以发现，对于同一个beanName所映射的对象，基本上经历从第三级缓存、第二级缓存、第一级缓存，的一个升级过程。而对网上经常困惑的第三级缓存的作用（认为第三级缓存没有必要存在）,博主认为存在第三级缓存是基于以下两个事实的：</p>\n<ol>\n<li><p>某些Bean对象（并不是所有的bean对象）在创建过程中且尚未创建完时就会被其它Bean对象所引用的问题（就是循环依赖，貌似是一句废话^_^）。</p>\n</li>\n<li><p>Bean的生命周期过程是一个成本较高的过程。</p>\n</li>\n</ol>\n<p>本文中只有Chicken 对象在创建过程中有被其它对象引用而Egg对象没有。因为第三级缓存存储的是一个raw bean后续创建的方法，那么对于在创建时被其它对象引用的Chicken对象来说，可以执行完第三级缓存中存储的bean对象后续的处理方法（AOP的功能就是在此实现的）后将Chicken bean返回，对于没有在创建过程中被引用的Egg对象来说，其只是浪费第三级缓存中的一点点内存，而避免重复执行spring对Egg Bean的某些生命周期逻辑的重复执行，这些重复的逻辑很可能是很高成本的过程，如AOP的实现。</p>\n<h1 id=\"5-总结\"><a href=\"#5-总结\" class=\"headerlink\" title=\"5 总结\"></a>5 总结</h1><p>编程界有个很著名的说法：“算法加数据结构等于程序”，本文的“3 源码分析”和“4 缓存数据变化”分别充当了spring解决基于@AutoWired注解的Bean的循环依赖程序中的算法和数据结构。和理解其关键是对“<strong>三Map一Set</strong>”数据变化的深入理解。</p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><a href=\"https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-dependency-resolution\" target=\"_blank\" rel=\"noopener\">1、Spring Circular Dependencies</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"0-看前必读\"><a href=\"#0-看前必读\" class=\"headerlink\" title=\"0 看前必读\"></a>0 看前必读</h1><p>先看下<br><a href=\"http://aworker.cn/2020/05/07/java/spring/post0/post0/\">00 spring源码剖析系列说明</a></p>\n<h1 id=\"1-什么是循环依赖\"><a href=\"#1-什么是循环依赖\" class=\"headerlink\" title=\"1 什么是循环依赖\"></a>1 什么是循环依赖</h1><p>循环依赖在spring框架中有一个专有名词叫 <em>Circular dependencies</em>，其具体是指受spring管理的两个bean对象 Bean1和Bean2，Bean1中有成员变量Bean2；Bean2中有成员变量Bean1。具体代码case如下：</p>\n<p>代码结构如图：</p>\n<p><img src=\"https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/spring/post1/spring_post1_code_struct.png\" alt=\"代码结构图\"></p>\n<p>前前后后一共使用了四个类，其中两个Bean类如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Component</span><br><span class=\"line\">public class Chicken &#123;</span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    Egg egg;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Component</span><br><span class=\"line\">public class Egg &#123;</span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    Chicken chicken;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>一个配置类：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@ComponentScan(&quot;spring.post1.beans&quot;)</span><br><span class=\"line\">public class Config &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>一个简单的main方法启动类：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class DemoSpringCircularDependencies &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(Config.class);</span><br><span class=\"line\">        Chicken chicken = ac.getBean(&quot;chicken&quot;, Chicken.class);</span><br><span class=\"line\">        System.out.println(chicken);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过代码可以看出，本章主要讨论下spring怎么解决基于@AutoWired注解的Bean的循环依赖问题。而两个循环依赖的Bean就是Chiken（里面需要属性Egg）和Egg（里面需要属性Chicken）。</p>\n<h1 id=\"2-前置知识\"><a href=\"#2-前置知识\" class=\"headerlink\" title=\"2 前置知识\"></a>2 前置知识</h1><ul>\n<li><p>学习本文前需要对spring的基于注解的bean管理配置方式有基本的了解，不然看不懂上述4个类的作用，那么就无从谈及学习spring源码了，本系列的文章也不是基本的spring配置学习文章，这部分知识自行google。</p>\n</li>\n<li><p>需要对jdk8的lambda有基础的了解。</p>\n</li>\n</ul>\n<h1 id=\"3-源码分析\"><a href=\"#3-源码分析\" class=\"headerlink\" title=\"3 源码分析\"></a>3 源码分析</h1><h2 id=\"3-1-源码栈帧\"><a href=\"#3-1-源码栈帧\" class=\"headerlink\" title=\"3.1 源码栈帧\"></a>3.1 源码栈帧</h2><p>首先我们先看下需要分析的源码的主要栈帧：</p>\n<p><img src=\"https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/spring/post1/bean_create_process_of_CD.jpg\" alt=\"源码栈帧图\"></p>\n<p>先对上图做简单的说明，上图中的每蓝色小块代表一个方法，里面的数字部分表示方法的执行先后顺序（数字小的先执行）。两个相邻的方法之间大数字方法是程序在执行小数字方法的过程中要调用的方法（和debug时的的栈信息类似）。我们对源码的分析也将按照“创建所有单例Bean”，“创建Chicken对象”，“填充Chicken对象属性”，“创建Egg对象”，“填充Egg对象属性”，“获取Chicken对象”等顺序进行。</p>\n<h2 id=\"3-2-创建所有单例Bean\"><a href=\"#3-2-创建所有单例Bean\" class=\"headerlink\" title=\"3.2 创建所有单例Bean\"></a>3.2 创建所有单例Bean</h2><p>方法1. 是AnnotationConfigApplicationContext类的构造方法，构造方法引出对Bean的初始化创建操作。其中可以留意下方法2. 中要执行的<strong>finishBeanFactoryInitialization</strong>方法也就是源码栈帧图中的3.方法。在方法3.上面有一句英文注释： “ // Instantiate all remaining (non-lazy-init) singletons. ”，清晰的表明方法3.的主要目的就是要创建剩下没被创建的非懒加载的单例对象。那么我们定义的两个Bean对象Chiken和Egg显然是在这个方法里面创建的，至于为什么是“剩下的”而不是所有的，其它的非懒加载的单例对象是在哪里创建的，不是本文要描述的问题。</p>\n<h2 id=\"3-3-创建Chicken对象\"><a href=\"#3-3-创建Chicken对象\" class=\"headerlink\" title=\"3.3 创建Chicken对象\"></a>3.3 创建Chicken对象</h2><p>spring创建在创建Bean对象前会给每个Bean对象创建一个BeanDefinition对象，BeanDefinition对象会搜集用户定义的关于Bean的各种配置信息，如这个Bean对象的类型，这个Bean对象的id和name，是否为单例对象等等，这些配置信息可以是xml形式的配置文件，也可以是基于注解的配置信息。</p>\n<p>以BeanDefinition的形式搜集了这些信息后，spring就开始初始化非懒加载的单例对象了（<strong>这里我们只分析我们自己定义的和循环依赖相关的两个Bean对象Chicken和Egg的加载过程</strong>）。也就是执行 5. getBean方法。方法5. 是个空壳方法其内部调用的是方法 6. doGetBean方法。doGetBean方法执行过程中会执行一个名为getSingleton(String beanName, boolean allowEarlyReference) 的方法。此方法定义如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected Object getSingleton(String beanName, boolean allowEarlyReference) &#123;</span><br><span class=\"line\">\t\tObject singletonObject = this.singletonObjects.get(beanName);</span><br><span class=\"line\">\t\tif (singletonObject == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class=\"line\">\t\t\tsynchronized (this.singletonObjects) &#123;</span><br><span class=\"line\">\t\t\t\tsingletonObject = this.earlySingletonObjects.get(beanName);</span><br><span class=\"line\">\t\t\t\tif (singletonObject == null &amp;&amp; allowEarlyReference) &#123;</span><br><span class=\"line\">\t\t\t\t\tObjectFactory&lt;?&gt; singletonFactory = this.singletonFactories.get(beanName);</span><br><span class=\"line\">\t\t\t\t\tif (singletonFactory != null) &#123;</span><br><span class=\"line\">\t\t\t\t\t\tsingletonObject = singletonFactory.getObject();</span><br><span class=\"line\">\t\t\t\t\t\tthis.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class=\"line\">\t\t\t\t\t\tthis.singletonFactories.remove(beanName);</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn singletonObject;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<p>其主要流程就是通过beanName参数查看先查看map对象<em>singletonObjects</em> 中是否有对应名称的Bean对象，有返回此Bean对象；没有查看map对象 <em>earlySingletonObjects</em> 中是否有对应名称的Bean对象，有返回此Bean对象；没有查看map对象 <em>singletonFactories</em> 是否有对应名称的ObjectFactory对象，有通过<em>ObjectFactory<em>对象的</em>getObject*方法获取到对应的Bean对象，然后清除 *singletonFactories</em> 对应的beanName的映射，同时将得到的Bean对象放到 <em>earlySingletonObjects</em> 中。这其中还有一个方法<em>isSingletonCurrentlyInCreation(String beanName)</em> 其内部是通过查看一个名为singletonsCurrentlyInCreation的Set对象是否包含指定的beanName,来判断这个单例bean是否正在创建bean对象。</p>\n<p>这三个Map对象和一个Set对象就是Spring中解决循环依赖非常重要的缓存，一下我们简称 “<strong>三Map一Set</strong>”，三个map对象因其在执行获取beanName对应的Bean对象的过程中的先后执行顺序，分别简称为 一级缓存、二级缓存、三级缓存。</p>\n<ul>\n<li><p>singletonObjects：一级缓存。此缓存中的Bean对象是经历Spring完整生命周期的Bean对象，</p>\n</li>\n<li><p>earlySingletonObjects：二级缓存。此缓存中的Bean对象是已经通过创建出来的但没有经历spring完整的生命周期的Bean对象。</p>\n</li>\n<li><p>singletonFactories：三级缓存。此缓存存在的是beanName和能获取Bean对象的一个工厂类<em>ObjectFactory</em>对象。</p>\n</li>\n</ul>\n<p>方法6. doGetBean 第一次调用 getSingleton(String beanName) 方法时从三个缓存中都没能获得参数chicken对应的Bean对象，程序继续执行到方法7. getSingleton(String beanName, ObjectFactory&lt;?&gt; singletonFactory) ，7. 方法中会执行一个 名为 <em>beforeSingletonCreation(String beanName)</em> 的方法，这个方法会在我们上文提到的中的三Map一Set中的Set添加对应的beanName（chicken）表示此chicken对应的单例Bean处在正在创建过程中，程序继续执行执行到 8. getObject() 方法，方法8. 是一个lambada对象对应的方法，其调用的是方法9. createBean方法进入Bean的创建过程。方法9. 中我们重点关注其执行的方法10. doCreateBean ，此方法是真正执行bean对象的创建的方法。在方法10. 中我们注意到其会执行一个名为 <em>addSingletonFactory</em> 方法，此方法会在我们提到的 三Map一Set中的 三级缓存singletonFactories添加一个beanName(chicken)对应的ObjectFactory对象，而后执行方法10. 中的方法11.  populateBean，此时程序传给方法11. 的三个参数分别为beanName:值为chicken、mbd：ChickenBean的BeanDefiniton对象、instanceWrapper：通过构造方法创建的一个Chicken对象，即Spring注解中经常提到的raw bean对象。由方法11.的名称可知，此类的主要目的是填充Chicken对象中的属性（Egg对象），循环依赖正是在此方法中解决的。</p>\n<h2 id=\"3-4-填充Chicken对象属性\"><a href=\"#3-4-填充Chicken对象属性\" class=\"headerlink\" title=\"3.4 填充Chicken对象属性\"></a>3.4 填充Chicken对象属性</h2><p>紧接上面小节，方法11.中spring通过在Chicken类中的@Autowired 注解来发现其需要的属性:Egg对象并填充其值，这个过程在方法12. postProcessProperties方法中执行，顺便提一句@Autowired注解依赖的属性由<em>AutowiredAnnotationBeanPostProcessor<em>类处理，@Resource注解依赖的属性由</em>CommonAnnotationBeanPostProcessor</em> 类处理。<br>而方法13. 到方法17. 主要作用就是找到合适的beanName以便用来通过此beanName找到对应的Bean来填充Chicken中的Egg对象，此部分代码和本文主旨无关以后的文章会分析，感兴趣的童鞋可以自行debug看下代码。</p>\n<h2 id=\"3-5-创建Egg对象\"><a href=\"#3-5-创建Egg对象\" class=\"headerlink\" title=\"3.5 创建Egg对象\"></a>3.5 创建Egg对象</h2><p>紧接上面小节，spring通过方法17. resolveCandidate将找到的合适beanName(egg)传递下来，通过方法18. getBean 来执行对Egg Bean对象的获取操作。此小节调用的方法栈和 “<em>3.3 创建chicken对象</em>” 小节的方法栈是一样的，唯一的区别是3.3小节传递的beanName参数值为chicken，而本小节传递的beanName参数为egg。</p>\n<h2 id=\"3-6-填充Egg对象属性\"><a href=\"#3-6-填充Egg对象属性\" class=\"headerlink\" title=\"3.6 填充Egg对象属性\"></a>3.6 填充Egg对象属性</h2><p>本小节对标的是 “<em>3.4 填充Chicken对象属性</em>”小节，两个小节调用的方法栈是一样的，区别也是参数的不同而已。Spring发现Egg对象需要注入一个Chicken对象。</p>\n<h2 id=\"3-7-获取Chicken对象\"><a href=\"#3-7-获取Chicken对象\" class=\"headerlink\" title=\"3.7 获取Chicken对象\"></a>3.7 获取Chicken对象</h2><p>这里我们分析的方法31. getBean 和方法18. getBean都是因为我们自己定义的Bean对象中有需要的注入的Bean对象。但是方法31. 传递的参数是chicken，而Chicken对象在 3.3小节中分析得知，其在三Map一Set中的第三级缓存<em>singletonFactories</em>存放了一个对应的ObjectFactory对象。spring通过这个ObjectFactory对象获取到了对应的Chicken 对象，而避免了循环依赖。</p>\n<h2 id=\"3-8-缓存创建完的Egg-和缓存创建完的Chicken\"><a href=\"#3-8-缓存创建完的Egg-和缓存创建完的Chicken\" class=\"headerlink\" title=\"3.8 缓存创建完的Egg 和缓存创建完的Chicken\"></a>3.8 缓存创建完的Egg 和缓存创建完的Chicken</h2><p>通过3.6小节我们获取到了Egg对象需要的成员变量Chicken对象。随着方法栈帧的层层返回，我们将焦点聚焦在由方法21.返回后的方法20.中，在程序执行完方法21. getObject 并获取到经历完Bean生命周期的Egg Bean后，其在方法20. 中还要执行两个比较重要的方法 <strong>afterSingletonCreation</strong> 和 <strong>addSingleton</strong>，其中前者会把三Map一Set中的Set对象singletonsCurrentlyInCreation中的egg移除，表示此Bean对象不是正在创建的Bean对象，Bean创建已经完成；后者会把Egg Bean存放在一级缓存中，同时清空二级缓存和三级缓存中egg对应的映射，至此Egg Bean的spring生命周期已经大体完成。Chicken对象也会执行<strong>afterSingletonCreation</strong> 和 <strong>addSingleton</strong> 两个方法来完成Chicken Bean的spring生命周期。</p>\n<h2 id=\"3-9-源码分析小结\"><a href=\"#3-9-源码分析小结\" class=\"headerlink\" title=\"3.9 源码分析小结\"></a>3.9 源码分析小结</h2><ul>\n<li><p>创建chicken对象、创建Egg对象：步骤主要解决一个Bean的raw bean对象的创建和的前期准备工作,和本文循环依赖相关的主要是对三Map一Set的对象的保存的内容的修改。</p>\n</li>\n<li><p>填充Chicken对象属性、填充Chicken对象属性：本文中主要通过AutowiredAnnotationBeanPostProcessor类完成依赖对象的搜集和适合依赖对象的beanName的筛选。</p>\n</li>\n<li><p>获取Chicken对象：主要是通过第三级缓存来获取，避免了Chicken对象的重复创建而进入一个死循环。</p>\n</li>\n<li><p>缓存创建完的Egg 和缓存创建完的Chicken：完成善后工作，将走完spring生命周期的Egg Bean和Chicken Bean放到一级缓存中，供客户端程序从spring中获取使用。</p>\n</li>\n</ul>\n<h1 id=\"4-缓存数据变化\"><a href=\"#4-缓存数据变化\" class=\"headerlink\" title=\"4 缓存数据变化\"></a>4 缓存数据变化</h1><p>在 “3 源码分析” 章节中，随着程序运行过程中除了有由方法调用和方法返回而产生的线程方法栈图中方法的压栈和出栈外。在这进进出出的背后发生改变的是我们的<strong>三Map一Set</strong> 中的数据。</p>\n<p>在源码分析的开头小节“<em>3.3 创建Chicken对象</em>” 和结尾小节“3.8 缓存创建完的Egg 和缓存创建完的Chicken”我们有对三Map一Set的分析，但着并不是说只有这两个小节的部分有数据变更，而是其缓存变化的原理和这连个小节一直，唯一的区别是方法调用的参数不同。整个数据变化图如下：</p>\n<p><img src=\"https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/spring/post1/cache_process_of_CD.jpg\" alt=\"数据流通图\"></p>\n<p>图中每个状态图都有一个“[a,b)”形式的步骤指示器，其中a,b分别表示 “3.1小节” 中源码栈帧图中一个方法数字，而括号用的是高等数学中常见的方式左闭右开方式，表示在程序在执行方法a到方法b（包含a不包含b）过程中缓存数据的状态和其下面的表格一致。</p>\n<p>通过对八个表格数据的观察我们可以发现，对于同一个beanName所映射的对象，基本上经历从第三级缓存、第二级缓存、第一级缓存，的一个升级过程。而对网上经常困惑的第三级缓存的作用（认为第三级缓存没有必要存在）,博主认为存在第三级缓存是基于以下两个事实的：</p>\n<ol>\n<li><p>某些Bean对象（并不是所有的bean对象）在创建过程中且尚未创建完时就会被其它Bean对象所引用的问题（就是循环依赖，貌似是一句废话^_^）。</p>\n</li>\n<li><p>Bean的生命周期过程是一个成本较高的过程。</p>\n</li>\n</ol>\n<p>本文中只有Chicken 对象在创建过程中有被其它对象引用而Egg对象没有。因为第三级缓存存储的是一个raw bean后续创建的方法，那么对于在创建时被其它对象引用的Chicken对象来说，可以执行完第三级缓存中存储的bean对象后续的处理方法（AOP的功能就是在此实现的）后将Chicken bean返回，对于没有在创建过程中被引用的Egg对象来说，其只是浪费第三级缓存中的一点点内存，而避免重复执行spring对Egg Bean的某些生命周期逻辑的重复执行，这些重复的逻辑很可能是很高成本的过程，如AOP的实现。</p>\n<h1 id=\"5-总结\"><a href=\"#5-总结\" class=\"headerlink\" title=\"5 总结\"></a>5 总结</h1><p>编程界有个很著名的说法：“算法加数据结构等于程序”，本文的“3 源码分析”和“4 缓存数据变化”分别充当了spring解决基于@AutoWired注解的Bean的循环依赖程序中的算法和数据结构。和理解其关键是对“<strong>三Map一Set</strong>”数据变化的深入理解。</p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><a href=\"https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-dependency-resolution\" target=\"_blank\" rel=\"noopener\">1、Spring Circular Dependencies</a></p>\n"},{"title":"00 spring源码剖析系列说明","date":"2020-05-07T08:46:13.000Z","character":"1. 及时更新如果spring版本有升级，本代码也会跟着升级","_content":"\nspring可以说是在web1.0时代java最流行的ssh框架（Struts，Spring，Hibernate) 中三元老的一员，追溯历史也有20年之久了。\n而时至今日只有spring框架以及衍生的项目的开源社区还非常活跃，而且spring框架已经成为企业级 java web项目的标准框架。在其基础上衍生的springboot项目和springcloud更是最近几年非常火爆的web框架。废话不多说，如果想在java技术栈企业级开发走的更深更远，spring源码的阅读和理解是必不可少的一环。\n\n但是spring的知识又是非常庞杂的。盘根错节的功能依赖，犬牙交错接口的调用让即使在web开发多年的老司机在遇到稍微深入一点的spring问题时，如果没有源码阅读经验也很难全身而退！对于小白来说如果遇到问题更是一头雾水。对于老司机和小白来说，源码的阅读都是必不可少的。\n\n博主认为源码阅读无外乎有两种方式:\n\n+ 横向死磕，new 一个ClassPathXmlApplicationContext对象，一行一行的刷代码，debug代码一步一步的走，博主曾经这样尝试过。刷的过程中非常的痛苦，需要极大的耐心和毅力。刷完后没有和业务相结合导致学完了无的放矢，最后投入大量时间，产出比却非常的低。\n\n+ 纵向死磕，spring中帮我们实现了很多功能，拿DI和AOP这两个核心功能来说其每个功能点的实现又可以拆分好多小功能点的实现。比如DI的实现：需要spring能读取classpath中的xml文件或者扫描加载指定包中的特定注解类、需要解决Bean的循环依赖问题、需要解决Bean生命周期管理问题等等，而这些问题还可以继续拆分。拿Bean的循环依赖问题来举例，spring创建Bean的方式有xml文件配置和注解配置两种，Bean1依赖的Bean2的注入方式也有构造器注入和Setter方法注入两种，Setter方法注入的Bean也有@Resource和@Autowired两种方式，Bean1依赖的Bean2和Bean1的类型可能是同一个类型也可能是不同的类型。具体化一个case来说就是spring是如何解决基于@Autowired注解的Setter方法Bean注入（注入的Bean和被注入的Bean类型不同）的循环依赖问题的？我们可以把这个特别具化的case通过阅读源码来解决。而通过源码了解这一个case的运作原理的过程中，我们会多多少少的了解spring其它部分的代码。通过多个具化case的纵向分析，潜移默化的情况下就会对spring有一个整体的把我和了解。但是纵向死磕也有个问题，面对spring庞杂的代码海洋，小白要想找到其具化case相关的代码就如大海捞针一样，最后相关的核心代码没有找到，自己却被淹个半死。\n\n看博主对两种源码阅读方法的着墨程度，也可以知道博主比较推荐第二种 **纵向死磕** 的方式。而本系列文章的目的就是做读者在spring源码这片汪洋大海中航行的灯塔——指明具化case的相关代码所在，同时对其做必要的分析。在此我想说下阅读过程中的一些小经验：\n\n1. 源码阅读要多debug，多思考。显而易见的道理，但也是最重要的原则。\n2. 源码阅读要“心无旁骛”。本系列的每篇文章会针对一个很具化的case做相关源码的分析。在这个过程中难免会涉及到一些不相关的代码，比如源码中某类的A方法的第189行代码到200行代码和一个具化的case相关，读者就不要在A方法的前189行代码做过多研究。spring源码枝繁叶茂，稍微偏离一点主干就会迷失在代码海洋中。可能有读者会有这样的疑惑，不仔细看前189行代码，能理解的了189行到200行代码的意思吗？这个大可放心，对代码的抽离过程由博主给读者做，保证大家能彻彻底底的了解一个具化case的相关源码。通过多个具化case源码的分析，你会不经意间发现，A方法的全部作用你都了解了。\n3. 做难事必有所得。最近在看金一南教授的《苦难辉煌》，感觉其中最让我深刻明白的一个道理就是：做难事必有所得。希望大家在阅读过程中有困难时咬咬牙坚持下来，最后一定会有所收获。\n\n最后，博主也不是spring大神，系列文章难免有瑕疵和纰漏，希望和积极留言讨论，愿诸君共同进步。本系列文章中使用的代码全是构建在maven项目中，项目也比较简单，其依赖的maven坐标如下：\n\n```aidl\n<dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-context</artifactId>\n        <version>5.2.1.RELEASE</version>\n</dependency>\n```\n\n\n系列文章建议的学习顺序如下：\n\n[1、spring解决循环源码分析](http://aworker.cn/2020/05/08/java/spring/post1/post1/)\n","source":"_posts/java/spring/post0/post0.md","raw":"---\ntitle: 00 spring源码剖析系列说明\ndate: 2020-05-07 16:46:13\ncategories:\n    - spring\n    - spring源码剖析系列\ntags:\ncharacter: 1. 及时更新如果spring版本有升级，本代码也会跟着升级\n---\n\nspring可以说是在web1.0时代java最流行的ssh框架（Struts，Spring，Hibernate) 中三元老的一员，追溯历史也有20年之久了。\n而时至今日只有spring框架以及衍生的项目的开源社区还非常活跃，而且spring框架已经成为企业级 java web项目的标准框架。在其基础上衍生的springboot项目和springcloud更是最近几年非常火爆的web框架。废话不多说，如果想在java技术栈企业级开发走的更深更远，spring源码的阅读和理解是必不可少的一环。\n\n但是spring的知识又是非常庞杂的。盘根错节的功能依赖，犬牙交错接口的调用让即使在web开发多年的老司机在遇到稍微深入一点的spring问题时，如果没有源码阅读经验也很难全身而退！对于小白来说如果遇到问题更是一头雾水。对于老司机和小白来说，源码的阅读都是必不可少的。\n\n博主认为源码阅读无外乎有两种方式:\n\n+ 横向死磕，new 一个ClassPathXmlApplicationContext对象，一行一行的刷代码，debug代码一步一步的走，博主曾经这样尝试过。刷的过程中非常的痛苦，需要极大的耐心和毅力。刷完后没有和业务相结合导致学完了无的放矢，最后投入大量时间，产出比却非常的低。\n\n+ 纵向死磕，spring中帮我们实现了很多功能，拿DI和AOP这两个核心功能来说其每个功能点的实现又可以拆分好多小功能点的实现。比如DI的实现：需要spring能读取classpath中的xml文件或者扫描加载指定包中的特定注解类、需要解决Bean的循环依赖问题、需要解决Bean生命周期管理问题等等，而这些问题还可以继续拆分。拿Bean的循环依赖问题来举例，spring创建Bean的方式有xml文件配置和注解配置两种，Bean1依赖的Bean2的注入方式也有构造器注入和Setter方法注入两种，Setter方法注入的Bean也有@Resource和@Autowired两种方式，Bean1依赖的Bean2和Bean1的类型可能是同一个类型也可能是不同的类型。具体化一个case来说就是spring是如何解决基于@Autowired注解的Setter方法Bean注入（注入的Bean和被注入的Bean类型不同）的循环依赖问题的？我们可以把这个特别具化的case通过阅读源码来解决。而通过源码了解这一个case的运作原理的过程中，我们会多多少少的了解spring其它部分的代码。通过多个具化case的纵向分析，潜移默化的情况下就会对spring有一个整体的把我和了解。但是纵向死磕也有个问题，面对spring庞杂的代码海洋，小白要想找到其具化case相关的代码就如大海捞针一样，最后相关的核心代码没有找到，自己却被淹个半死。\n\n看博主对两种源码阅读方法的着墨程度，也可以知道博主比较推荐第二种 **纵向死磕** 的方式。而本系列文章的目的就是做读者在spring源码这片汪洋大海中航行的灯塔——指明具化case的相关代码所在，同时对其做必要的分析。在此我想说下阅读过程中的一些小经验：\n\n1. 源码阅读要多debug，多思考。显而易见的道理，但也是最重要的原则。\n2. 源码阅读要“心无旁骛”。本系列的每篇文章会针对一个很具化的case做相关源码的分析。在这个过程中难免会涉及到一些不相关的代码，比如源码中某类的A方法的第189行代码到200行代码和一个具化的case相关，读者就不要在A方法的前189行代码做过多研究。spring源码枝繁叶茂，稍微偏离一点主干就会迷失在代码海洋中。可能有读者会有这样的疑惑，不仔细看前189行代码，能理解的了189行到200行代码的意思吗？这个大可放心，对代码的抽离过程由博主给读者做，保证大家能彻彻底底的了解一个具化case的相关源码。通过多个具化case源码的分析，你会不经意间发现，A方法的全部作用你都了解了。\n3. 做难事必有所得。最近在看金一南教授的《苦难辉煌》，感觉其中最让我深刻明白的一个道理就是：做难事必有所得。希望大家在阅读过程中有困难时咬咬牙坚持下来，最后一定会有所收获。\n\n最后，博主也不是spring大神，系列文章难免有瑕疵和纰漏，希望和积极留言讨论，愿诸君共同进步。本系列文章中使用的代码全是构建在maven项目中，项目也比较简单，其依赖的maven坐标如下：\n\n```aidl\n<dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-context</artifactId>\n        <version>5.2.1.RELEASE</version>\n</dependency>\n```\n\n\n系列文章建议的学习顺序如下：\n\n[1、spring解决循环源码分析](http://aworker.cn/2020/05/08/java/spring/post1/post1/)\n","slug":"java/spring/post0/post0","published":1,"updated":"2020-05-17T07:26:24.696Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckag4s7qu000d3oief6kn34d9","content":"<p>spring可以说是在web1.0时代java最流行的ssh框架（Struts，Spring，Hibernate) 中三元老的一员，追溯历史也有20年之久了。<br>而时至今日只有spring框架以及衍生的项目的开源社区还非常活跃，而且spring框架已经成为企业级 java web项目的标准框架。在其基础上衍生的springboot项目和springcloud更是最近几年非常火爆的web框架。废话不多说，如果想在java技术栈企业级开发走的更深更远，spring源码的阅读和理解是必不可少的一环。</p>\n<p>但是spring的知识又是非常庞杂的。盘根错节的功能依赖，犬牙交错接口的调用让即使在web开发多年的老司机在遇到稍微深入一点的spring问题时，如果没有源码阅读经验也很难全身而退！对于小白来说如果遇到问题更是一头雾水。对于老司机和小白来说，源码的阅读都是必不可少的。</p>\n<p>博主认为源码阅读无外乎有两种方式:</p>\n<ul>\n<li><p>横向死磕，new 一个ClassPathXmlApplicationContext对象，一行一行的刷代码，debug代码一步一步的走，博主曾经这样尝试过。刷的过程中非常的痛苦，需要极大的耐心和毅力。刷完后没有和业务相结合导致学完了无的放矢，最后投入大量时间，产出比却非常的低。</p>\n</li>\n<li><p>纵向死磕，spring中帮我们实现了很多功能，拿DI和AOP这两个核心功能来说其每个功能点的实现又可以拆分好多小功能点的实现。比如DI的实现：需要spring能读取classpath中的xml文件或者扫描加载指定包中的特定注解类、需要解决Bean的循环依赖问题、需要解决Bean生命周期管理问题等等，而这些问题还可以继续拆分。拿Bean的循环依赖问题来举例，spring创建Bean的方式有xml文件配置和注解配置两种，Bean1依赖的Bean2的注入方式也有构造器注入和Setter方法注入两种，Setter方法注入的Bean也有@Resource和@Autowired两种方式，Bean1依赖的Bean2和Bean1的类型可能是同一个类型也可能是不同的类型。具体化一个case来说就是spring是如何解决基于@Autowired注解的Setter方法Bean注入（注入的Bean和被注入的Bean类型不同）的循环依赖问题的？我们可以把这个特别具化的case通过阅读源码来解决。而通过源码了解这一个case的运作原理的过程中，我们会多多少少的了解spring其它部分的代码。通过多个具化case的纵向分析，潜移默化的情况下就会对spring有一个整体的把我和了解。但是纵向死磕也有个问题，面对spring庞杂的代码海洋，小白要想找到其具化case相关的代码就如大海捞针一样，最后相关的核心代码没有找到，自己却被淹个半死。</p>\n</li>\n</ul>\n<p>看博主对两种源码阅读方法的着墨程度，也可以知道博主比较推荐第二种 <strong>纵向死磕</strong> 的方式。而本系列文章的目的就是做读者在spring源码这片汪洋大海中航行的灯塔——指明具化case的相关代码所在，同时对其做必要的分析。在此我想说下阅读过程中的一些小经验：</p>\n<ol>\n<li>源码阅读要多debug，多思考。显而易见的道理，但也是最重要的原则。</li>\n<li>源码阅读要“心无旁骛”。本系列的每篇文章会针对一个很具化的case做相关源码的分析。在这个过程中难免会涉及到一些不相关的代码，比如源码中某类的A方法的第189行代码到200行代码和一个具化的case相关，读者就不要在A方法的前189行代码做过多研究。spring源码枝繁叶茂，稍微偏离一点主干就会迷失在代码海洋中。可能有读者会有这样的疑惑，不仔细看前189行代码，能理解的了189行到200行代码的意思吗？这个大可放心，对代码的抽离过程由博主给读者做，保证大家能彻彻底底的了解一个具化case的相关源码。通过多个具化case源码的分析，你会不经意间发现，A方法的全部作用你都了解了。</li>\n<li>做难事必有所得。最近在看金一南教授的《苦难辉煌》，感觉其中最让我深刻明白的一个道理就是：做难事必有所得。希望大家在阅读过程中有困难时咬咬牙坚持下来，最后一定会有所收获。</li>\n</ol>\n<p>最后，博主也不是spring大神，系列文章难免有瑕疵和纰漏，希望和积极留言讨论，愿诸君共同进步。本系列文章中使用的代码全是构建在maven项目中，项目也比较简单，其依赖的maven坐标如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class=\"line\">        &lt;version&gt;5.2.1.RELEASE&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n\n\n<p>系列文章建议的学习顺序如下：</p>\n<p><a href=\"http://aworker.cn/2020/05/08/java/spring/post1/post1/\">1、spring解决循环源码分析</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>spring可以说是在web1.0时代java最流行的ssh框架（Struts，Spring，Hibernate) 中三元老的一员，追溯历史也有20年之久了。<br>而时至今日只有spring框架以及衍生的项目的开源社区还非常活跃，而且spring框架已经成为企业级 java web项目的标准框架。在其基础上衍生的springboot项目和springcloud更是最近几年非常火爆的web框架。废话不多说，如果想在java技术栈企业级开发走的更深更远，spring源码的阅读和理解是必不可少的一环。</p>\n<p>但是spring的知识又是非常庞杂的。盘根错节的功能依赖，犬牙交错接口的调用让即使在web开发多年的老司机在遇到稍微深入一点的spring问题时，如果没有源码阅读经验也很难全身而退！对于小白来说如果遇到问题更是一头雾水。对于老司机和小白来说，源码的阅读都是必不可少的。</p>\n<p>博主认为源码阅读无外乎有两种方式:</p>\n<ul>\n<li><p>横向死磕，new 一个ClassPathXmlApplicationContext对象，一行一行的刷代码，debug代码一步一步的走，博主曾经这样尝试过。刷的过程中非常的痛苦，需要极大的耐心和毅力。刷完后没有和业务相结合导致学完了无的放矢，最后投入大量时间，产出比却非常的低。</p>\n</li>\n<li><p>纵向死磕，spring中帮我们实现了很多功能，拿DI和AOP这两个核心功能来说其每个功能点的实现又可以拆分好多小功能点的实现。比如DI的实现：需要spring能读取classpath中的xml文件或者扫描加载指定包中的特定注解类、需要解决Bean的循环依赖问题、需要解决Bean生命周期管理问题等等，而这些问题还可以继续拆分。拿Bean的循环依赖问题来举例，spring创建Bean的方式有xml文件配置和注解配置两种，Bean1依赖的Bean2的注入方式也有构造器注入和Setter方法注入两种，Setter方法注入的Bean也有@Resource和@Autowired两种方式，Bean1依赖的Bean2和Bean1的类型可能是同一个类型也可能是不同的类型。具体化一个case来说就是spring是如何解决基于@Autowired注解的Setter方法Bean注入（注入的Bean和被注入的Bean类型不同）的循环依赖问题的？我们可以把这个特别具化的case通过阅读源码来解决。而通过源码了解这一个case的运作原理的过程中，我们会多多少少的了解spring其它部分的代码。通过多个具化case的纵向分析，潜移默化的情况下就会对spring有一个整体的把我和了解。但是纵向死磕也有个问题，面对spring庞杂的代码海洋，小白要想找到其具化case相关的代码就如大海捞针一样，最后相关的核心代码没有找到，自己却被淹个半死。</p>\n</li>\n</ul>\n<p>看博主对两种源码阅读方法的着墨程度，也可以知道博主比较推荐第二种 <strong>纵向死磕</strong> 的方式。而本系列文章的目的就是做读者在spring源码这片汪洋大海中航行的灯塔——指明具化case的相关代码所在，同时对其做必要的分析。在此我想说下阅读过程中的一些小经验：</p>\n<ol>\n<li>源码阅读要多debug，多思考。显而易见的道理，但也是最重要的原则。</li>\n<li>源码阅读要“心无旁骛”。本系列的每篇文章会针对一个很具化的case做相关源码的分析。在这个过程中难免会涉及到一些不相关的代码，比如源码中某类的A方法的第189行代码到200行代码和一个具化的case相关，读者就不要在A方法的前189行代码做过多研究。spring源码枝繁叶茂，稍微偏离一点主干就会迷失在代码海洋中。可能有读者会有这样的疑惑，不仔细看前189行代码，能理解的了189行到200行代码的意思吗？这个大可放心，对代码的抽离过程由博主给读者做，保证大家能彻彻底底的了解一个具化case的相关源码。通过多个具化case源码的分析，你会不经意间发现，A方法的全部作用你都了解了。</li>\n<li>做难事必有所得。最近在看金一南教授的《苦难辉煌》，感觉其中最让我深刻明白的一个道理就是：做难事必有所得。希望大家在阅读过程中有困难时咬咬牙坚持下来，最后一定会有所收获。</li>\n</ol>\n<p>最后，博主也不是spring大神，系列文章难免有瑕疵和纰漏，希望和积极留言讨论，愿诸君共同进步。本系列文章中使用的代码全是构建在maven项目中，项目也比较简单，其依赖的maven坐标如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class=\"line\">        &lt;version&gt;5.2.1.RELEASE&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n\n\n<p>系列文章建议的学习顺序如下：</p>\n<p><a href=\"http://aworker.cn/2020/05/08/java/spring/post1/post1/\">1、spring解决循环源码分析</a></p>\n"},{"title":"00开篇","date":"2019-11-09T08:36:13.000Z","_content":"\n有别于C/C++语言，java虚拟机解放了java程序员，使我们在开发过程中不必负责每个对象的出生和死亡，我们只管用new关键字创建对象，使用对象，对于不在使用的对象所占的内存空间的回收，完全交给java虚拟机来负责。在程序内存管理领域，java虚拟机即让我们避免成为分配对象内存，回收对象内存这样单调工作的奴隶；也让我们丧失了成为掌握对象内存空间管理“生杀大权”的皇帝，内存管理对我们越发的陌生和透明，一旦有内存泄露或者溢出以及涉及到虚拟机方面的性能调优，都会让我们手足无措。《也谈java虚拟机，说点不一样的》系列文章，力求用简单，生动，具体的讲述风格讲解java虚拟机的运作机制，让广大java开发人员得以管窥一二，在实际工作中、在面试找工作时、在饭后和同事吹逼时，都能得心应手，从容应对。鉴于java虚拟机知识体系的庞杂和深邃以及本员能力的限制，系列文章中难免有错误和不足，希望大家多多包涵。\n\njava虚拟机是一个抽象的计算机。对于程序开发人员来说，我们只需要编写好我们的程序，让不同平台上的java虚拟机完成java代码到不同操作系统计算机指令的转化，通过这种方式java语言实现了其夸平台特性。虽然名为java虚拟机，但是它并不是和java语言强绑定的，java虚拟机只能识别有特定语法格式的class文件，而所有能编译为class文件的语言，都可以在java虚拟机上运行，java虚拟机不是“java语言的虚拟机”而是“多语言的虚拟机”。\n\n在java虚拟机的发展历史上，曾经有很多的优秀的虚拟机实现。如随着jdk1.0一起发布的Classic VM，号称速度最快的JRockit VM，以及专精Windows平台的Microsoft JVM等。但我们普通程序员用的最多的也是“血统最纯正”虚拟机实现就是Sun公司发布的HotSpot VM，这个系列也以HotSpot虚拟机为蓝本进行讲述的。\n\n\nHotSpot虚拟机的组件结构如下：\n\n![HotSpot虚拟机组件结构](https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/jvm/post0/HotSpot-architecture.jpg) \n\nHotSpot虚拟机有三大主要模块：\n\n+ 类加载子系统，主要用来加载class文件，从中获取类信息。\n+ 虚拟机运行时数据区，主要存储程序运行时的各种对象信息和线程栈帧数据。\n+ 执行引擎，主要内存垃圾回收和运行时代码优化。\n\n本系列将会从实际应用、面试需要、饭后吹逼等三个角度分别讲解这三大主要模块。同时给自己立个flag到2020年6月能完成本系列文章的全部写作。\n\n> 有任何不懂或者质疑的地方，都欢迎大家积极留言讨论，留言必回，一起学习进步。\n\n\n\n<!-- \n参考文献 https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html\n-->","source":"_posts/java/jvm/post0/post0.md","raw":"---\ntitle: 00开篇\ndate: 2019-11-09 16:36:13\ncategories:\n    - jvm\n    - java虚拟机，说点不一样的\ntags:\n---\n\n有别于C/C++语言，java虚拟机解放了java程序员，使我们在开发过程中不必负责每个对象的出生和死亡，我们只管用new关键字创建对象，使用对象，对于不在使用的对象所占的内存空间的回收，完全交给java虚拟机来负责。在程序内存管理领域，java虚拟机即让我们避免成为分配对象内存，回收对象内存这样单调工作的奴隶；也让我们丧失了成为掌握对象内存空间管理“生杀大权”的皇帝，内存管理对我们越发的陌生和透明，一旦有内存泄露或者溢出以及涉及到虚拟机方面的性能调优，都会让我们手足无措。《也谈java虚拟机，说点不一样的》系列文章，力求用简单，生动，具体的讲述风格讲解java虚拟机的运作机制，让广大java开发人员得以管窥一二，在实际工作中、在面试找工作时、在饭后和同事吹逼时，都能得心应手，从容应对。鉴于java虚拟机知识体系的庞杂和深邃以及本员能力的限制，系列文章中难免有错误和不足，希望大家多多包涵。\n\njava虚拟机是一个抽象的计算机。对于程序开发人员来说，我们只需要编写好我们的程序，让不同平台上的java虚拟机完成java代码到不同操作系统计算机指令的转化，通过这种方式java语言实现了其夸平台特性。虽然名为java虚拟机，但是它并不是和java语言强绑定的，java虚拟机只能识别有特定语法格式的class文件，而所有能编译为class文件的语言，都可以在java虚拟机上运行，java虚拟机不是“java语言的虚拟机”而是“多语言的虚拟机”。\n\n在java虚拟机的发展历史上，曾经有很多的优秀的虚拟机实现。如随着jdk1.0一起发布的Classic VM，号称速度最快的JRockit VM，以及专精Windows平台的Microsoft JVM等。但我们普通程序员用的最多的也是“血统最纯正”虚拟机实现就是Sun公司发布的HotSpot VM，这个系列也以HotSpot虚拟机为蓝本进行讲述的。\n\n\nHotSpot虚拟机的组件结构如下：\n\n![HotSpot虚拟机组件结构](https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/jvm/post0/HotSpot-architecture.jpg) \n\nHotSpot虚拟机有三大主要模块：\n\n+ 类加载子系统，主要用来加载class文件，从中获取类信息。\n+ 虚拟机运行时数据区，主要存储程序运行时的各种对象信息和线程栈帧数据。\n+ 执行引擎，主要内存垃圾回收和运行时代码优化。\n\n本系列将会从实际应用、面试需要、饭后吹逼等三个角度分别讲解这三大主要模块。同时给自己立个flag到2020年6月能完成本系列文章的全部写作。\n\n> 有任何不懂或者质疑的地方，都欢迎大家积极留言讨论，留言必回，一起学习进步。\n\n\n\n<!-- \n参考文献 https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html\n-->","slug":"java/jvm/post0/post0","published":1,"updated":"2020-01-30T09:04:16.375Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckag4s7qw000f3oie7v9gbm01","content":"<p>有别于C/C++语言，java虚拟机解放了java程序员，使我们在开发过程中不必负责每个对象的出生和死亡，我们只管用new关键字创建对象，使用对象，对于不在使用的对象所占的内存空间的回收，完全交给java虚拟机来负责。在程序内存管理领域，java虚拟机即让我们避免成为分配对象内存，回收对象内存这样单调工作的奴隶；也让我们丧失了成为掌握对象内存空间管理“生杀大权”的皇帝，内存管理对我们越发的陌生和透明，一旦有内存泄露或者溢出以及涉及到虚拟机方面的性能调优，都会让我们手足无措。《也谈java虚拟机，说点不一样的》系列文章，力求用简单，生动，具体的讲述风格讲解java虚拟机的运作机制，让广大java开发人员得以管窥一二，在实际工作中、在面试找工作时、在饭后和同事吹逼时，都能得心应手，从容应对。鉴于java虚拟机知识体系的庞杂和深邃以及本员能力的限制，系列文章中难免有错误和不足，希望大家多多包涵。</p>\n<p>java虚拟机是一个抽象的计算机。对于程序开发人员来说，我们只需要编写好我们的程序，让不同平台上的java虚拟机完成java代码到不同操作系统计算机指令的转化，通过这种方式java语言实现了其夸平台特性。虽然名为java虚拟机，但是它并不是和java语言强绑定的，java虚拟机只能识别有特定语法格式的class文件，而所有能编译为class文件的语言，都可以在java虚拟机上运行，java虚拟机不是“java语言的虚拟机”而是“多语言的虚拟机”。</p>\n<p>在java虚拟机的发展历史上，曾经有很多的优秀的虚拟机实现。如随着jdk1.0一起发布的Classic VM，号称速度最快的JRockit VM，以及专精Windows平台的Microsoft JVM等。但我们普通程序员用的最多的也是“血统最纯正”虚拟机实现就是Sun公司发布的HotSpot VM，这个系列也以HotSpot虚拟机为蓝本进行讲述的。</p>\n<p>HotSpot虚拟机的组件结构如下：</p>\n<p><img src=\"https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/jvm/post0/HotSpot-architecture.jpg\" alt=\"HotSpot虚拟机组件结构\"> </p>\n<p>HotSpot虚拟机有三大主要模块：</p>\n<ul>\n<li>类加载子系统，主要用来加载class文件，从中获取类信息。</li>\n<li>虚拟机运行时数据区，主要存储程序运行时的各种对象信息和线程栈帧数据。</li>\n<li>执行引擎，主要内存垃圾回收和运行时代码优化。</li>\n</ul>\n<p>本系列将会从实际应用、面试需要、饭后吹逼等三个角度分别讲解这三大主要模块。同时给自己立个flag到2020年6月能完成本系列文章的全部写作。</p>\n<blockquote>\n<p>有任何不懂或者质疑的地方，都欢迎大家积极留言讨论，留言必回，一起学习进步。</p>\n</blockquote>\n<!-- \n参考文献 https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html\n-->","site":{"data":{}},"excerpt":"","more":"<p>有别于C/C++语言，java虚拟机解放了java程序员，使我们在开发过程中不必负责每个对象的出生和死亡，我们只管用new关键字创建对象，使用对象，对于不在使用的对象所占的内存空间的回收，完全交给java虚拟机来负责。在程序内存管理领域，java虚拟机即让我们避免成为分配对象内存，回收对象内存这样单调工作的奴隶；也让我们丧失了成为掌握对象内存空间管理“生杀大权”的皇帝，内存管理对我们越发的陌生和透明，一旦有内存泄露或者溢出以及涉及到虚拟机方面的性能调优，都会让我们手足无措。《也谈java虚拟机，说点不一样的》系列文章，力求用简单，生动，具体的讲述风格讲解java虚拟机的运作机制，让广大java开发人员得以管窥一二，在实际工作中、在面试找工作时、在饭后和同事吹逼时，都能得心应手，从容应对。鉴于java虚拟机知识体系的庞杂和深邃以及本员能力的限制，系列文章中难免有错误和不足，希望大家多多包涵。</p>\n<p>java虚拟机是一个抽象的计算机。对于程序开发人员来说，我们只需要编写好我们的程序，让不同平台上的java虚拟机完成java代码到不同操作系统计算机指令的转化，通过这种方式java语言实现了其夸平台特性。虽然名为java虚拟机，但是它并不是和java语言强绑定的，java虚拟机只能识别有特定语法格式的class文件，而所有能编译为class文件的语言，都可以在java虚拟机上运行，java虚拟机不是“java语言的虚拟机”而是“多语言的虚拟机”。</p>\n<p>在java虚拟机的发展历史上，曾经有很多的优秀的虚拟机实现。如随着jdk1.0一起发布的Classic VM，号称速度最快的JRockit VM，以及专精Windows平台的Microsoft JVM等。但我们普通程序员用的最多的也是“血统最纯正”虚拟机实现就是Sun公司发布的HotSpot VM，这个系列也以HotSpot虚拟机为蓝本进行讲述的。</p>\n<p>HotSpot虚拟机的组件结构如下：</p>\n<p><img src=\"https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/jvm/post0/HotSpot-architecture.jpg\" alt=\"HotSpot虚拟机组件结构\"> </p>\n<p>HotSpot虚拟机有三大主要模块：</p>\n<ul>\n<li>类加载子系统，主要用来加载class文件，从中获取类信息。</li>\n<li>虚拟机运行时数据区，主要存储程序运行时的各种对象信息和线程栈帧数据。</li>\n<li>执行引擎，主要内存垃圾回收和运行时代码优化。</li>\n</ul>\n<p>本系列将会从实际应用、面试需要、饭后吹逼等三个角度分别讲解这三大主要模块。同时给自己立个flag到2020年6月能完成本系列文章的全部写作。</p>\n<blockquote>\n<p>有任何不懂或者质疑的地方，都欢迎大家积极留言讨论，留言必回，一起学习进步。</p>\n</blockquote>\n<!-- \n参考文献 https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html\n-->"},{"title":"01最全面的jvm运行时数据区讲解","date":"2019-11-09T08:36:13.000Z","_content":"\n# 最全面的jvm运行时数据区讲解\n\n\n记得有位大佬曾经说过这样一句话：\n> 如欲征服java，必须征服java虚拟机，如欲征服java虚拟机，需先征服java虚拟机内存模型。\n\njava虚拟机内存，是java虚拟机进行对象内存空间分配、垃圾回收的活动室，只有先了解java虚拟机内存才能在此基础上进一步了解对象内存分配、垃圾回收等活动。有别于真实物理机硬盘、主存、缓存、寄存器的存储模型，java虚拟机内存模型按照其存储模块负责的数据类型将其划分为如下图所示的模型：\n\n![java虚拟机内存模型](https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/jvm/post1/jvm_memory_model.png)\n                    \n\n## 堆\n堆是各个线程共享的内存区域，是java对象内存分配和垃圾回收的主战场，几乎所有的对象都是在堆中创建的。根据*Java虚拟机规范（Java Virtual Machine Specification）* 的规则，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。如果在堆中没有内存空间完成Java对象的内存分配时，将会抛出OutOfMemoryError（一下简称OOM）。\n\n关于堆的最常见虚拟机参数：\n+ -Xms ：表示虚拟机堆的最小值，如 -Xms10M 表示堆的最小值为10MB\n+ -Xmx ：表示虚拟机堆的最大值，如果 -Xmx100M 表示堆的最大值为100MB\n\n\n```\n/**\n * 设置虚拟机参数为：-Xms5M -Xmx5M\n */\npublic class HeapOOM {\n    public static void main(String[] args) {\n        ArrayList<Byte[]> bytes = new ArrayList<>();\n        for (; ; ) {\n            Byte[] _1M = new Byte[1024 * 1024];\n            bytes.add(_1M);\n        }\n\n    }\n}\n```\n\n执行结果:\n\n```\nException in thread \"main\" java.lang.OutOfMemoryError: Java heap space\n\tat jvm.post1.HeapOOM.main(HeapOOM.java:15)\n```\n\n“Java heap space”类型的OOM表示堆中没有可用的内存空间，具体到本例子中就是在大小为5M的堆中没有可用空间分配给大小为1M的数组对象。再来看一个例子：\n\n```\n/**\n * @createtime 2019/11/2\n * 虚拟机参数 -Xms5M -Xmx5M \n*/ \npublic class HeapOOM1 {\n    public static void main(String[] args) {\n        ArrayList<Object> heapOOM1s = new ArrayList<>();\n        for (; ; ) {\n            heapOOM1s.add(new Object());\n        }\n    }\n}\n```\n\n执行结果:\n\n```\nException in thread \"main\" java.lang.OutOfMemoryError: GC overhead limit exceeded\n\tat jvm.post1.HeapOOM1.main(HeapOOM1.java:14)\n```\n\n“GC overhead limit exceeded” 类型的OOM是在jdk6后引入的一种新的错误类型。发生错误的原因是虚拟机用了大量的时间进行GC但是只释放了较小的空间，这是虚拟机的一种保护机制。具体到本例子中就是虚拟机在GC时没有能回收内存空间，浪费了时间却没有收获，所以就抛出了这个错误。可以用 *-XX:-UseGCOverheadLimit*参数禁用这个检查，但解决不了内存问题，只是把错误的信息延后，替换成 java.lang.OutOfMemoryError: Java heap space错误。\n\n## 方法区\n方法区和堆一样，也是各个线程共享的内存区域，它用来存储已经被虚拟机加载的类信息、常量池、静态变量等。方法区是jdk5到jdk8变化较大的java虚拟机内存区域。在jdk5和jdk6时，常量池是存在方法区的：\n\n![jdk5和jdk6](https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/jvm/post1/jvm_memory_model_1.5.png)\n\n\n而从jdk7及其以后的版本，常量池被放到了堆里面：\n\n![jdk7](https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/jvm/post1/jvm_memory_model_1.7.png)\n\n常量池就是java语言系统级别的缓存，目的是让程序在运行过程中速度更快，更节省内存空间，java的8种基本数据类型外加String类型，共9种类型都有对应的常量池。这些类型的对象不可能全都放到常量池中存储，因此不同的类型有不同的存储策略，具体到String类型的对象来说，有如下三条规则：\n\n+ 用双引号创建的对象放在常量池中，如 \"Hello\"，\"Jvm\"这种。\n+ 用双引号创建的对象相加产生的对象放在常量池，如 *String s = \"Hello\" + \"Jvm\";*，这里的s对象就是放在常量池中的。\n+ 调用String对象的intern方法会返回一个存放在常量池中的String对象,且两个对象内容相同。\n\n再回到本篇的主题上，因为常量池位置的变化，在不同的jdk版本下，下面代码的执行结果是不一样的：\n\n```\npublic class ConstantsPool {\n    public static void main(String[] args) {\n\n        String s = new String(\"Hello\") + new String(\"Jvm\"); //1\n        String s1 = s.intern();  //2\n        System.out.println(s == s1); //jdk5和jdk6中返回false，jdk7及其以上版本返回true。\n    }\n}\n\n```\n\n\n\n在jdk7之前，程序在执行//2处代码之前常量池中没有\"HelloJvm\"这个字符串常量，//2处代码执行时，程序会在常量池中创建一个\"HelloJvm\"的字符串对象s1并返回，而常量池是在方法区的。那一个在堆中的s对象和方法区中的s1对象比较地址是否相同，当然会得到false。\n在jdk7及其以后的版本，程序在执行//2出代码时，发现常量池中同样没有\"HelloJvm\"这个对象，但因为常量池已经迁移到堆中，常量池不需要存储一个对象了，程序只是简单的把s这个对象的引用在常量池中存储了，此时s和s1指向的是同一个对象，结果当然是true。\n\n上面简单介绍了jdk7中常量池的变化，而在jdk8中方法整个方法区被放到了物理机的本地内存,同时也更名为元空间（MetaSpace）：\n\n![jdk8](https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/jvm/post1/jvm_memory_model_1.8.png)\n\n\njdk8及其以后的版本，元空间直接使用物理机的本地内存，在不加限制的情况下其最大值为本地内存的最大可用值。考虑到物理机上可能部署其它的应用服务，通常会给元空间加一个大小限制。\n\n关于元空间最常见的虚拟机参数是：\n+ -XX:MetaspaceSize : 表示虚拟机元空间发生MetadataGC时的初始阈值,如 -XX:MetaspaceSize=10M 表示元空间在第一次到大10M时，会发生一次MetadataGC。\n+ -XX:MaxMetaspaceSize ： 表示虚拟机元空间的最大值为MaxMetaspaceSize，如 -XX:MaxMetaspaceSize=15M 表示元空间的最大值为15M，再大就会发生OOM异常。\n\n关于元空间的的内存溢出模拟，我们需要借助CGLib来动态的创建类，先引入如下maven依赖：\n\n```\n<dependency>\n    <groupId>cglib</groupId>\n    <artifactId>cglib-nodep</artifactId>\n    <version>3.3.0</version>\n</dependency>\n\n```\n\n具体代码如下：\n\n```\n/**\n * 虚拟机参数 -XX:MaxMetaspaceSize=10M \n * @description 元空间内存溢出\n */\npublic class MetaSpaceOOM {\n    public static void main(String[] args) {\n        BeanGenerator beanGenerator = new BeanGenerator();\n        List<Class> classes = new ArrayList<>();\n        for (int i=0; i<1000000000L;i++ ) {\n\n            beanGenerator.addProperty(\"id\"+i, Integer.class);\n            Object aClass = beanGenerator.createClass();\n            classes.add((Class) aClass);\n\n        }\n    }\n}\n```\n\n 执行结果为：\n\n```aidl\nException in thread \"main\" java.lang.IllegalStateException: Unable to load cache item\n\tat net.sf.cglib.core.internal.LoadingCache.createEntry(LoadingCache.java:79)\n\tat net.sf.cglib.core.internal.LoadingCache.get(LoadingCache.java:34)\n\tat net.sf.cglib.core.AbstractClassGenerator$ClassLoaderData.get(AbstractClassGenerator.java:119)\n\tat net.sf.cglib.core.AbstractClassGenerator.create(AbstractClassGenerator.java:294)\n\tat net.sf.cglib.beans.BeanGenerator.createHelper(BeanGenerator.java:94)\n\tat net.sf.cglib.beans.BeanGenerator.createClass(BeanGenerator.java:85)\n\tat jvm.post1.MetaSpaceOOM.main(MetaSpaceOOM.java:19)\nCaused by: java.lang.OutOfMemoryError: Metaspace\n\tat net.sf.cglib.core.AbstractClassGenerator.generate(AbstractClassGenerator.java:348)\n\tat net.sf.cglib.core.AbstractClassGenerator$ClassLoaderData$3.apply(AbstractClassGenerator.java:96)\n\tat net.sf.cglib.core.AbstractClassGenerator$ClassLoaderData$3.apply(AbstractClassGenerator.java:94)\n\tat net.sf.cglib.core.internal.LoadingCache$2.call(LoadingCache.java:54)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat net.sf.cglib.core.internal.LoadingCache.createEntry(LoadingCache.java:61)\n\t... 6 more\n```\n\n可以看到，引起IllegalStateException异常的正是因为\"Metaspace\"类型的OOM错误。具体原因为BeanGenerator对象通过createClass方法不断创建新的类，导致最大内存为10MB的元空间没办法存储类的信息而抛出异常。\n\n## 虚拟机栈和本地方法栈\n\n虚拟机栈和本地方法栈，都是线程私有的，主要用来存储在线程运行过程中的局部变量、操作数栈、方法出入口等信息，这些信息是以栈帧的形式存储的，虚拟机栈和本地方法栈的区别就是一个存储java方法运行时的栈帧数据一个存储本地方法（native 关键字修饰的方法）运行时的栈帧数据。由于都是存储栈帧数据，两种栈的区别不是很大，甚至在HotSpot虚拟机中，直接把这两个合二为一，所以本小节把这两种栈合起来说。java程序在运行时的栈数据结构如下图：\n\n![运行时栈结构](https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/jvm/post1/stack-model.jpg)  \n\n\n在介绍堆时，我们曾说过几乎所有的对象都是在堆中创建的，这几乎中的特例就来自于栈，对象是可以在栈上创建，我们称为栈上分配。\n\n```\n\n/**\n * 执行栈上分配的虚拟机参数  -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -Xmx10M\n * 不执行栈上分配的虚拟机参数  -XX:-DoEscapeAnalysis -XX:+EliminateAllocations -Xmx10M\n * \n * 参数说明：\n * DoEscapeAnalysis  ： 逃逸分析，对于本例来说逃逸分析可以判断出//1处创建的对象是否会被本方法外的方法获取到。\n * EliminateAllocations ： 标量替换，对于本例来说，在逃逸分析的帮助下发现//1出的User对象不会逃逸出方法allo，那么消除User对象的堆内存分配，把它的字段改为一个个独立的局部变量（本例中是int类型的标量）存储在线程的栈中。\n * 要模拟栈上分配，需要逃逸分析和标量替换两个功能都是开启的。\n * @description 栈上分配\n */\npublic class StackAllocation {\n    static class User{\n        int i;\n    }\n\n    public static void allo() {\n        User user = new User(); //1\n        user.i = 4;\n    }\n\n    public static void main(String[] args) {\n        long startTime = System.currentTimeMillis();\n        for (int i = 0; i < 100000000L; i++) {\n            allo();\n        }\n        long endTime = System.currentTimeMillis();\n        System.out.println(endTime - startTime);\n    }\n}\n\n```\n\n用不同的虚拟机参数执行上面的代码时，会发现同样执行1亿次方法调用，栈上分配的执行时间明显比非栈上分配的执行时间短。简单的解释就是1亿个的User对象不是被分配在堆上，这样就避免了频繁的GC，对性能自然有很大提升。\n\n与栈相关的虚拟机参数主要有：\n+ -Xss : 设置java线程栈的大小，如 -Xss100k 表示每个java线程栈的大小为100k。\n\n线程栈是用来存方法的栈帧的。线程栈越大其能调用的方法深度越大，运行如下代码可以印证此观点：\n\n```\n\n/**\n * 虚拟机参数 -Xss1000K\n * @description 模拟栈内存溢出\n */\npublic class StackOverFlowOOM {\n    private static int num = 0;\n\n    public static void loop(){\n        num++;\n        loop();\n    }\n\n    public static void main(String[] args) {\n        try {\n            loop();\n        } catch (Throwable e) {\n            e.printStackTrace();\n            System.out.println(num);\n        }\n    }\n}\n\n```\n\n当Xss的值越大时，程序中的num变量在栈溢出异常时的值越大。jdk8中如果不指定Xss参数的大小，那么其默认值为1MB，这也从内存角度印证线程是一种昂贵的资源，即使简单的创建一个线程而不分配给其处理任务，其也要占用一些内存空间。\n\n\n## 程序计数器\n\n程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器，因为操作系统会分配给各个线程一些时间片来运行，当时间片用完后，就需要有程序计数器记录线程执行的位置，用来在线程重新获得时间片时能恢复到原来的执行位置。从程序计数器的用途得知，程序程序计数器也是线程私有的，而且也是唯一一个不会有OOM异常的虚拟机内存区域。\n\n\n\n## 篇尾小节\n\n本篇主要简绍了java虚拟机在运行时的各个内存区域，简单介绍了它们的作用和内存溢出的方式。\n\n\n\n\n> 有任何不懂或者质疑的地方，都欢迎大家积极留言讨论，留言必回，一起学习进步。\n\n\n\n<!--\n参考文献 ：\nhttp://lovestblog.cn/blog/2016/10/29/metaspace/ \n-->","source":"_posts/java/jvm/post1/post1.md","raw":"---\ntitle: 01最全面的jvm运行时数据区讲解\ndate: 2019-11-09 16:36:13\ncategories:\n    - jvm\n    - java虚拟机，说点不一样的\ntags:\n---\n\n# 最全面的jvm运行时数据区讲解\n\n\n记得有位大佬曾经说过这样一句话：\n> 如欲征服java，必须征服java虚拟机，如欲征服java虚拟机，需先征服java虚拟机内存模型。\n\njava虚拟机内存，是java虚拟机进行对象内存空间分配、垃圾回收的活动室，只有先了解java虚拟机内存才能在此基础上进一步了解对象内存分配、垃圾回收等活动。有别于真实物理机硬盘、主存、缓存、寄存器的存储模型，java虚拟机内存模型按照其存储模块负责的数据类型将其划分为如下图所示的模型：\n\n![java虚拟机内存模型](https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/jvm/post1/jvm_memory_model.png)\n                    \n\n## 堆\n堆是各个线程共享的内存区域，是java对象内存分配和垃圾回收的主战场，几乎所有的对象都是在堆中创建的。根据*Java虚拟机规范（Java Virtual Machine Specification）* 的规则，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。如果在堆中没有内存空间完成Java对象的内存分配时，将会抛出OutOfMemoryError（一下简称OOM）。\n\n关于堆的最常见虚拟机参数：\n+ -Xms ：表示虚拟机堆的最小值，如 -Xms10M 表示堆的最小值为10MB\n+ -Xmx ：表示虚拟机堆的最大值，如果 -Xmx100M 表示堆的最大值为100MB\n\n\n```\n/**\n * 设置虚拟机参数为：-Xms5M -Xmx5M\n */\npublic class HeapOOM {\n    public static void main(String[] args) {\n        ArrayList<Byte[]> bytes = new ArrayList<>();\n        for (; ; ) {\n            Byte[] _1M = new Byte[1024 * 1024];\n            bytes.add(_1M);\n        }\n\n    }\n}\n```\n\n执行结果:\n\n```\nException in thread \"main\" java.lang.OutOfMemoryError: Java heap space\n\tat jvm.post1.HeapOOM.main(HeapOOM.java:15)\n```\n\n“Java heap space”类型的OOM表示堆中没有可用的内存空间，具体到本例子中就是在大小为5M的堆中没有可用空间分配给大小为1M的数组对象。再来看一个例子：\n\n```\n/**\n * @createtime 2019/11/2\n * 虚拟机参数 -Xms5M -Xmx5M \n*/ \npublic class HeapOOM1 {\n    public static void main(String[] args) {\n        ArrayList<Object> heapOOM1s = new ArrayList<>();\n        for (; ; ) {\n            heapOOM1s.add(new Object());\n        }\n    }\n}\n```\n\n执行结果:\n\n```\nException in thread \"main\" java.lang.OutOfMemoryError: GC overhead limit exceeded\n\tat jvm.post1.HeapOOM1.main(HeapOOM1.java:14)\n```\n\n“GC overhead limit exceeded” 类型的OOM是在jdk6后引入的一种新的错误类型。发生错误的原因是虚拟机用了大量的时间进行GC但是只释放了较小的空间，这是虚拟机的一种保护机制。具体到本例子中就是虚拟机在GC时没有能回收内存空间，浪费了时间却没有收获，所以就抛出了这个错误。可以用 *-XX:-UseGCOverheadLimit*参数禁用这个检查，但解决不了内存问题，只是把错误的信息延后，替换成 java.lang.OutOfMemoryError: Java heap space错误。\n\n## 方法区\n方法区和堆一样，也是各个线程共享的内存区域，它用来存储已经被虚拟机加载的类信息、常量池、静态变量等。方法区是jdk5到jdk8变化较大的java虚拟机内存区域。在jdk5和jdk6时，常量池是存在方法区的：\n\n![jdk5和jdk6](https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/jvm/post1/jvm_memory_model_1.5.png)\n\n\n而从jdk7及其以后的版本，常量池被放到了堆里面：\n\n![jdk7](https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/jvm/post1/jvm_memory_model_1.7.png)\n\n常量池就是java语言系统级别的缓存，目的是让程序在运行过程中速度更快，更节省内存空间，java的8种基本数据类型外加String类型，共9种类型都有对应的常量池。这些类型的对象不可能全都放到常量池中存储，因此不同的类型有不同的存储策略，具体到String类型的对象来说，有如下三条规则：\n\n+ 用双引号创建的对象放在常量池中，如 \"Hello\"，\"Jvm\"这种。\n+ 用双引号创建的对象相加产生的对象放在常量池，如 *String s = \"Hello\" + \"Jvm\";*，这里的s对象就是放在常量池中的。\n+ 调用String对象的intern方法会返回一个存放在常量池中的String对象,且两个对象内容相同。\n\n再回到本篇的主题上，因为常量池位置的变化，在不同的jdk版本下，下面代码的执行结果是不一样的：\n\n```\npublic class ConstantsPool {\n    public static void main(String[] args) {\n\n        String s = new String(\"Hello\") + new String(\"Jvm\"); //1\n        String s1 = s.intern();  //2\n        System.out.println(s == s1); //jdk5和jdk6中返回false，jdk7及其以上版本返回true。\n    }\n}\n\n```\n\n\n\n在jdk7之前，程序在执行//2处代码之前常量池中没有\"HelloJvm\"这个字符串常量，//2处代码执行时，程序会在常量池中创建一个\"HelloJvm\"的字符串对象s1并返回，而常量池是在方法区的。那一个在堆中的s对象和方法区中的s1对象比较地址是否相同，当然会得到false。\n在jdk7及其以后的版本，程序在执行//2出代码时，发现常量池中同样没有\"HelloJvm\"这个对象，但因为常量池已经迁移到堆中，常量池不需要存储一个对象了，程序只是简单的把s这个对象的引用在常量池中存储了，此时s和s1指向的是同一个对象，结果当然是true。\n\n上面简单介绍了jdk7中常量池的变化，而在jdk8中方法整个方法区被放到了物理机的本地内存,同时也更名为元空间（MetaSpace）：\n\n![jdk8](https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/jvm/post1/jvm_memory_model_1.8.png)\n\n\njdk8及其以后的版本，元空间直接使用物理机的本地内存，在不加限制的情况下其最大值为本地内存的最大可用值。考虑到物理机上可能部署其它的应用服务，通常会给元空间加一个大小限制。\n\n关于元空间最常见的虚拟机参数是：\n+ -XX:MetaspaceSize : 表示虚拟机元空间发生MetadataGC时的初始阈值,如 -XX:MetaspaceSize=10M 表示元空间在第一次到大10M时，会发生一次MetadataGC。\n+ -XX:MaxMetaspaceSize ： 表示虚拟机元空间的最大值为MaxMetaspaceSize，如 -XX:MaxMetaspaceSize=15M 表示元空间的最大值为15M，再大就会发生OOM异常。\n\n关于元空间的的内存溢出模拟，我们需要借助CGLib来动态的创建类，先引入如下maven依赖：\n\n```\n<dependency>\n    <groupId>cglib</groupId>\n    <artifactId>cglib-nodep</artifactId>\n    <version>3.3.0</version>\n</dependency>\n\n```\n\n具体代码如下：\n\n```\n/**\n * 虚拟机参数 -XX:MaxMetaspaceSize=10M \n * @description 元空间内存溢出\n */\npublic class MetaSpaceOOM {\n    public static void main(String[] args) {\n        BeanGenerator beanGenerator = new BeanGenerator();\n        List<Class> classes = new ArrayList<>();\n        for (int i=0; i<1000000000L;i++ ) {\n\n            beanGenerator.addProperty(\"id\"+i, Integer.class);\n            Object aClass = beanGenerator.createClass();\n            classes.add((Class) aClass);\n\n        }\n    }\n}\n```\n\n 执行结果为：\n\n```aidl\nException in thread \"main\" java.lang.IllegalStateException: Unable to load cache item\n\tat net.sf.cglib.core.internal.LoadingCache.createEntry(LoadingCache.java:79)\n\tat net.sf.cglib.core.internal.LoadingCache.get(LoadingCache.java:34)\n\tat net.sf.cglib.core.AbstractClassGenerator$ClassLoaderData.get(AbstractClassGenerator.java:119)\n\tat net.sf.cglib.core.AbstractClassGenerator.create(AbstractClassGenerator.java:294)\n\tat net.sf.cglib.beans.BeanGenerator.createHelper(BeanGenerator.java:94)\n\tat net.sf.cglib.beans.BeanGenerator.createClass(BeanGenerator.java:85)\n\tat jvm.post1.MetaSpaceOOM.main(MetaSpaceOOM.java:19)\nCaused by: java.lang.OutOfMemoryError: Metaspace\n\tat net.sf.cglib.core.AbstractClassGenerator.generate(AbstractClassGenerator.java:348)\n\tat net.sf.cglib.core.AbstractClassGenerator$ClassLoaderData$3.apply(AbstractClassGenerator.java:96)\n\tat net.sf.cglib.core.AbstractClassGenerator$ClassLoaderData$3.apply(AbstractClassGenerator.java:94)\n\tat net.sf.cglib.core.internal.LoadingCache$2.call(LoadingCache.java:54)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat net.sf.cglib.core.internal.LoadingCache.createEntry(LoadingCache.java:61)\n\t... 6 more\n```\n\n可以看到，引起IllegalStateException异常的正是因为\"Metaspace\"类型的OOM错误。具体原因为BeanGenerator对象通过createClass方法不断创建新的类，导致最大内存为10MB的元空间没办法存储类的信息而抛出异常。\n\n## 虚拟机栈和本地方法栈\n\n虚拟机栈和本地方法栈，都是线程私有的，主要用来存储在线程运行过程中的局部变量、操作数栈、方法出入口等信息，这些信息是以栈帧的形式存储的，虚拟机栈和本地方法栈的区别就是一个存储java方法运行时的栈帧数据一个存储本地方法（native 关键字修饰的方法）运行时的栈帧数据。由于都是存储栈帧数据，两种栈的区别不是很大，甚至在HotSpot虚拟机中，直接把这两个合二为一，所以本小节把这两种栈合起来说。java程序在运行时的栈数据结构如下图：\n\n![运行时栈结构](https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/jvm/post1/stack-model.jpg)  \n\n\n在介绍堆时，我们曾说过几乎所有的对象都是在堆中创建的，这几乎中的特例就来自于栈，对象是可以在栈上创建，我们称为栈上分配。\n\n```\n\n/**\n * 执行栈上分配的虚拟机参数  -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -Xmx10M\n * 不执行栈上分配的虚拟机参数  -XX:-DoEscapeAnalysis -XX:+EliminateAllocations -Xmx10M\n * \n * 参数说明：\n * DoEscapeAnalysis  ： 逃逸分析，对于本例来说逃逸分析可以判断出//1处创建的对象是否会被本方法外的方法获取到。\n * EliminateAllocations ： 标量替换，对于本例来说，在逃逸分析的帮助下发现//1出的User对象不会逃逸出方法allo，那么消除User对象的堆内存分配，把它的字段改为一个个独立的局部变量（本例中是int类型的标量）存储在线程的栈中。\n * 要模拟栈上分配，需要逃逸分析和标量替换两个功能都是开启的。\n * @description 栈上分配\n */\npublic class StackAllocation {\n    static class User{\n        int i;\n    }\n\n    public static void allo() {\n        User user = new User(); //1\n        user.i = 4;\n    }\n\n    public static void main(String[] args) {\n        long startTime = System.currentTimeMillis();\n        for (int i = 0; i < 100000000L; i++) {\n            allo();\n        }\n        long endTime = System.currentTimeMillis();\n        System.out.println(endTime - startTime);\n    }\n}\n\n```\n\n用不同的虚拟机参数执行上面的代码时，会发现同样执行1亿次方法调用，栈上分配的执行时间明显比非栈上分配的执行时间短。简单的解释就是1亿个的User对象不是被分配在堆上，这样就避免了频繁的GC，对性能自然有很大提升。\n\n与栈相关的虚拟机参数主要有：\n+ -Xss : 设置java线程栈的大小，如 -Xss100k 表示每个java线程栈的大小为100k。\n\n线程栈是用来存方法的栈帧的。线程栈越大其能调用的方法深度越大，运行如下代码可以印证此观点：\n\n```\n\n/**\n * 虚拟机参数 -Xss1000K\n * @description 模拟栈内存溢出\n */\npublic class StackOverFlowOOM {\n    private static int num = 0;\n\n    public static void loop(){\n        num++;\n        loop();\n    }\n\n    public static void main(String[] args) {\n        try {\n            loop();\n        } catch (Throwable e) {\n            e.printStackTrace();\n            System.out.println(num);\n        }\n    }\n}\n\n```\n\n当Xss的值越大时，程序中的num变量在栈溢出异常时的值越大。jdk8中如果不指定Xss参数的大小，那么其默认值为1MB，这也从内存角度印证线程是一种昂贵的资源，即使简单的创建一个线程而不分配给其处理任务，其也要占用一些内存空间。\n\n\n## 程序计数器\n\n程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器，因为操作系统会分配给各个线程一些时间片来运行，当时间片用完后，就需要有程序计数器记录线程执行的位置，用来在线程重新获得时间片时能恢复到原来的执行位置。从程序计数器的用途得知，程序程序计数器也是线程私有的，而且也是唯一一个不会有OOM异常的虚拟机内存区域。\n\n\n\n## 篇尾小节\n\n本篇主要简绍了java虚拟机在运行时的各个内存区域，简单介绍了它们的作用和内存溢出的方式。\n\n\n\n\n> 有任何不懂或者质疑的地方，都欢迎大家积极留言讨论，留言必回，一起学习进步。\n\n\n\n<!--\n参考文献 ：\nhttp://lovestblog.cn/blog/2016/10/29/metaspace/ \n-->","slug":"java/jvm/post1/post1","published":1,"updated":"2020-01-30T09:04:16.389Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckag4s7r500123oie5kc54wri","content":"<h1 id=\"最全面的jvm运行时数据区讲解\"><a href=\"#最全面的jvm运行时数据区讲解\" class=\"headerlink\" title=\"最全面的jvm运行时数据区讲解\"></a>最全面的jvm运行时数据区讲解</h1><p>记得有位大佬曾经说过这样一句话：</p>\n<blockquote>\n<p>如欲征服java，必须征服java虚拟机，如欲征服java虚拟机，需先征服java虚拟机内存模型。</p>\n</blockquote>\n<p>java虚拟机内存，是java虚拟机进行对象内存空间分配、垃圾回收的活动室，只有先了解java虚拟机内存才能在此基础上进一步了解对象内存分配、垃圾回收等活动。有别于真实物理机硬盘、主存、缓存、寄存器的存储模型，java虚拟机内存模型按照其存储模块负责的数据类型将其划分为如下图所示的模型：</p>\n<p><img src=\"https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/jvm/post1/jvm_memory_model.png\" alt=\"java虚拟机内存模型\"></p>\n<h2 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h2><p>堆是各个线程共享的内存区域，是java对象内存分配和垃圾回收的主战场，几乎所有的对象都是在堆中创建的。根据<em>Java虚拟机规范（Java Virtual Machine Specification）</em> 的规则，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。如果在堆中没有内存空间完成Java对象的内存分配时，将会抛出OutOfMemoryError（一下简称OOM）。</p>\n<p>关于堆的最常见虚拟机参数：</p>\n<ul>\n<li>-Xms ：表示虚拟机堆的最小值，如 -Xms10M 表示堆的最小值为10MB</li>\n<li>-Xmx ：表示虚拟机堆的最大值，如果 -Xmx100M 表示堆的最大值为100MB</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 设置虚拟机参数为：-Xms5M -Xmx5M</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class HeapOOM &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        ArrayList&lt;Byte[]&gt; bytes = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        for (; ; ) &#123;</span><br><span class=\"line\">            Byte[] _1M = new Byte[1024 * 1024];</span><br><span class=\"line\">            bytes.add(_1M);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>执行结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br><span class=\"line\">\tat jvm.post1.HeapOOM.main(HeapOOM.java:15)</span><br></pre></td></tr></table></figure>\n\n<p>“Java heap space”类型的OOM表示堆中没有可用的内存空间，具体到本例子中就是在大小为5M的堆中没有可用空间分配给大小为1M的数组对象。再来看一个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * @createtime 2019/11/2</span><br><span class=\"line\"> * 虚拟机参数 -Xms5M -Xmx5M </span><br><span class=\"line\">*/ </span><br><span class=\"line\">public class HeapOOM1 &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        ArrayList&lt;Object&gt; heapOOM1s = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        for (; ; ) &#123;</span><br><span class=\"line\">            heapOOM1s.add(new Object());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>执行结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: GC overhead limit exceeded</span><br><span class=\"line\">\tat jvm.post1.HeapOOM1.main(HeapOOM1.java:14)</span><br></pre></td></tr></table></figure>\n\n<p>“GC overhead limit exceeded” 类型的OOM是在jdk6后引入的一种新的错误类型。发生错误的原因是虚拟机用了大量的时间进行GC但是只释放了较小的空间，这是虚拟机的一种保护机制。具体到本例子中就是虚拟机在GC时没有能回收内存空间，浪费了时间却没有收获，所以就抛出了这个错误。可以用 <em>-XX:-UseGCOverheadLimit</em>参数禁用这个检查，但解决不了内存问题，只是把错误的信息延后，替换成 java.lang.OutOfMemoryError: Java heap space错误。</p>\n<h2 id=\"方法区\"><a href=\"#方法区\" class=\"headerlink\" title=\"方法区\"></a>方法区</h2><p>方法区和堆一样，也是各个线程共享的内存区域，它用来存储已经被虚拟机加载的类信息、常量池、静态变量等。方法区是jdk5到jdk8变化较大的java虚拟机内存区域。在jdk5和jdk6时，常量池是存在方法区的：</p>\n<p><img src=\"https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/jvm/post1/jvm_memory_model_1.5.png\" alt=\"jdk5和jdk6\"></p>\n<p>而从jdk7及其以后的版本，常量池被放到了堆里面：</p>\n<p><img src=\"https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/jvm/post1/jvm_memory_model_1.7.png\" alt=\"jdk7\"></p>\n<p>常量池就是java语言系统级别的缓存，目的是让程序在运行过程中速度更快，更节省内存空间，java的8种基本数据类型外加String类型，共9种类型都有对应的常量池。这些类型的对象不可能全都放到常量池中存储，因此不同的类型有不同的存储策略，具体到String类型的对象来说，有如下三条规则：</p>\n<ul>\n<li>用双引号创建的对象放在常量池中，如 “Hello”，”Jvm”这种。</li>\n<li>用双引号创建的对象相加产生的对象放在常量池，如 <em>String s = “Hello” + “Jvm”;</em>，这里的s对象就是放在常量池中的。</li>\n<li>调用String对象的intern方法会返回一个存放在常量池中的String对象,且两个对象内容相同。</li>\n</ul>\n<p>再回到本篇的主题上，因为常量池位置的变化，在不同的jdk版本下，下面代码的执行结果是不一样的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ConstantsPool &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        String s = new String(&quot;Hello&quot;) + new String(&quot;Jvm&quot;); //1</span><br><span class=\"line\">        String s1 = s.intern();  //2</span><br><span class=\"line\">        System.out.println(s == s1); //jdk5和jdk6中返回false，jdk7及其以上版本返回true。</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>在jdk7之前，程序在执行//2处代码之前常量池中没有”HelloJvm”这个字符串常量，//2处代码执行时，程序会在常量池中创建一个”HelloJvm”的字符串对象s1并返回，而常量池是在方法区的。那一个在堆中的s对象和方法区中的s1对象比较地址是否相同，当然会得到false。<br>在jdk7及其以后的版本，程序在执行//2出代码时，发现常量池中同样没有”HelloJvm”这个对象，但因为常量池已经迁移到堆中，常量池不需要存储一个对象了，程序只是简单的把s这个对象的引用在常量池中存储了，此时s和s1指向的是同一个对象，结果当然是true。</p>\n<p>上面简单介绍了jdk7中常量池的变化，而在jdk8中方法整个方法区被放到了物理机的本地内存,同时也更名为元空间（MetaSpace）：</p>\n<p><img src=\"https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/jvm/post1/jvm_memory_model_1.8.png\" alt=\"jdk8\"></p>\n<p>jdk8及其以后的版本，元空间直接使用物理机的本地内存，在不加限制的情况下其最大值为本地内存的最大可用值。考虑到物理机上可能部署其它的应用服务，通常会给元空间加一个大小限制。</p>\n<p>关于元空间最常见的虚拟机参数是：</p>\n<ul>\n<li>-XX:MetaspaceSize : 表示虚拟机元空间发生MetadataGC时的初始阈值,如 -XX:MetaspaceSize=10M 表示元空间在第一次到大10M时，会发生一次MetadataGC。</li>\n<li>-XX:MaxMetaspaceSize ： 表示虚拟机元空间的最大值为MaxMetaspaceSize，如 -XX:MaxMetaspaceSize=15M 表示元空间的最大值为15M，再大就会发生OOM异常。</li>\n</ul>\n<p>关于元空间的的内存溢出模拟，我们需要借助CGLib来动态的创建类，先引入如下maven依赖：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;cglib&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;cglib-nodep&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;3.3.0&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n\n<p>具体代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 虚拟机参数 -XX:MaxMetaspaceSize=10M </span><br><span class=\"line\"> * @description 元空间内存溢出</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class MetaSpaceOOM &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        BeanGenerator beanGenerator = new BeanGenerator();</span><br><span class=\"line\">        List&lt;Class&gt; classes = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        for (int i=0; i&lt;1000000000L;i++ ) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            beanGenerator.addProperty(&quot;id&quot;+i, Integer.class);</span><br><span class=\"line\">            Object aClass = beanGenerator.createClass();</span><br><span class=\"line\">            classes.add((Class) aClass);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> 执行结果为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Exception in thread &quot;main&quot; java.lang.IllegalStateException: Unable to load cache item</span><br><span class=\"line\">\tat net.sf.cglib.core.internal.LoadingCache.createEntry(LoadingCache.java:79)</span><br><span class=\"line\">\tat net.sf.cglib.core.internal.LoadingCache.get(LoadingCache.java:34)</span><br><span class=\"line\">\tat net.sf.cglib.core.AbstractClassGenerator$ClassLoaderData.get(AbstractClassGenerator.java:119)</span><br><span class=\"line\">\tat net.sf.cglib.core.AbstractClassGenerator.create(AbstractClassGenerator.java:294)</span><br><span class=\"line\">\tat net.sf.cglib.beans.BeanGenerator.createHelper(BeanGenerator.java:94)</span><br><span class=\"line\">\tat net.sf.cglib.beans.BeanGenerator.createClass(BeanGenerator.java:85)</span><br><span class=\"line\">\tat jvm.post1.MetaSpaceOOM.main(MetaSpaceOOM.java:19)</span><br><span class=\"line\">Caused by: java.lang.OutOfMemoryError: Metaspace</span><br><span class=\"line\">\tat net.sf.cglib.core.AbstractClassGenerator.generate(AbstractClassGenerator.java:348)</span><br><span class=\"line\">\tat net.sf.cglib.core.AbstractClassGenerator$ClassLoaderData$3.apply(AbstractClassGenerator.java:96)</span><br><span class=\"line\">\tat net.sf.cglib.core.AbstractClassGenerator$ClassLoaderData$3.apply(AbstractClassGenerator.java:94)</span><br><span class=\"line\">\tat net.sf.cglib.core.internal.LoadingCache$2.call(LoadingCache.java:54)</span><br><span class=\"line\">\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)</span><br><span class=\"line\">\tat net.sf.cglib.core.internal.LoadingCache.createEntry(LoadingCache.java:61)</span><br><span class=\"line\">\t... 6 more</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，引起IllegalStateException异常的正是因为”Metaspace”类型的OOM错误。具体原因为BeanGenerator对象通过createClass方法不断创建新的类，导致最大内存为10MB的元空间没办法存储类的信息而抛出异常。</p>\n<h2 id=\"虚拟机栈和本地方法栈\"><a href=\"#虚拟机栈和本地方法栈\" class=\"headerlink\" title=\"虚拟机栈和本地方法栈\"></a>虚拟机栈和本地方法栈</h2><p>虚拟机栈和本地方法栈，都是线程私有的，主要用来存储在线程运行过程中的局部变量、操作数栈、方法出入口等信息，这些信息是以栈帧的形式存储的，虚拟机栈和本地方法栈的区别就是一个存储java方法运行时的栈帧数据一个存储本地方法（native 关键字修饰的方法）运行时的栈帧数据。由于都是存储栈帧数据，两种栈的区别不是很大，甚至在HotSpot虚拟机中，直接把这两个合二为一，所以本小节把这两种栈合起来说。java程序在运行时的栈数据结构如下图：</p>\n<p><img src=\"https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/jvm/post1/stack-model.jpg\" alt=\"运行时栈结构\">  </p>\n<p>在介绍堆时，我们曾说过几乎所有的对象都是在堆中创建的，这几乎中的特例就来自于栈，对象是可以在栈上创建，我们称为栈上分配。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 执行栈上分配的虚拟机参数  -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -Xmx10M</span><br><span class=\"line\"> * 不执行栈上分配的虚拟机参数  -XX:-DoEscapeAnalysis -XX:+EliminateAllocations -Xmx10M</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * 参数说明：</span><br><span class=\"line\"> * DoEscapeAnalysis  ： 逃逸分析，对于本例来说逃逸分析可以判断出//1处创建的对象是否会被本方法外的方法获取到。</span><br><span class=\"line\"> * EliminateAllocations ： 标量替换，对于本例来说，在逃逸分析的帮助下发现//1出的User对象不会逃逸出方法allo，那么消除User对象的堆内存分配，把它的字段改为一个个独立的局部变量（本例中是int类型的标量）存储在线程的栈中。</span><br><span class=\"line\"> * 要模拟栈上分配，需要逃逸分析和标量替换两个功能都是开启的。</span><br><span class=\"line\"> * @description 栈上分配</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class StackAllocation &#123;</span><br><span class=\"line\">    static class User&#123;</span><br><span class=\"line\">        int i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void allo() &#123;</span><br><span class=\"line\">        User user = new User(); //1</span><br><span class=\"line\">        user.i = 4;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        long startTime = System.currentTimeMillis();</span><br><span class=\"line\">        for (int i = 0; i &lt; 100000000L; i++) &#123;</span><br><span class=\"line\">            allo();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        long endTime = System.currentTimeMillis();</span><br><span class=\"line\">        System.out.println(endTime - startTime);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>用不同的虚拟机参数执行上面的代码时，会发现同样执行1亿次方法调用，栈上分配的执行时间明显比非栈上分配的执行时间短。简单的解释就是1亿个的User对象不是被分配在堆上，这样就避免了频繁的GC，对性能自然有很大提升。</p>\n<p>与栈相关的虚拟机参数主要有：</p>\n<ul>\n<li>-Xss : 设置java线程栈的大小，如 -Xss100k 表示每个java线程栈的大小为100k。</li>\n</ul>\n<p>线程栈是用来存方法的栈帧的。线程栈越大其能调用的方法深度越大，运行如下代码可以印证此观点：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 虚拟机参数 -Xss1000K</span><br><span class=\"line\"> * @description 模拟栈内存溢出</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class StackOverFlowOOM &#123;</span><br><span class=\"line\">    private static int num = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void loop()&#123;</span><br><span class=\"line\">        num++;</span><br><span class=\"line\">        loop();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            loop();</span><br><span class=\"line\">        &#125; catch (Throwable e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            System.out.println(num);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当Xss的值越大时，程序中的num变量在栈溢出异常时的值越大。jdk8中如果不指定Xss参数的大小，那么其默认值为1MB，这也从内存角度印证线程是一种昂贵的资源，即使简单的创建一个线程而不分配给其处理任务，其也要占用一些内存空间。</p>\n<h2 id=\"程序计数器\"><a href=\"#程序计数器\" class=\"headerlink\" title=\"程序计数器\"></a>程序计数器</h2><p>程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器，因为操作系统会分配给各个线程一些时间片来运行，当时间片用完后，就需要有程序计数器记录线程执行的位置，用来在线程重新获得时间片时能恢复到原来的执行位置。从程序计数器的用途得知，程序程序计数器也是线程私有的，而且也是唯一一个不会有OOM异常的虚拟机内存区域。</p>\n<h2 id=\"篇尾小节\"><a href=\"#篇尾小节\" class=\"headerlink\" title=\"篇尾小节\"></a>篇尾小节</h2><p>本篇主要简绍了java虚拟机在运行时的各个内存区域，简单介绍了它们的作用和内存溢出的方式。</p>\n<blockquote>\n<p>有任何不懂或者质疑的地方，都欢迎大家积极留言讨论，留言必回，一起学习进步。</p>\n</blockquote>\n<!--\n参考文献 ：\nhttp://lovestblog.cn/blog/2016/10/29/metaspace/ \n-->","site":{"data":{}},"excerpt":"","more":"<h1 id=\"最全面的jvm运行时数据区讲解\"><a href=\"#最全面的jvm运行时数据区讲解\" class=\"headerlink\" title=\"最全面的jvm运行时数据区讲解\"></a>最全面的jvm运行时数据区讲解</h1><p>记得有位大佬曾经说过这样一句话：</p>\n<blockquote>\n<p>如欲征服java，必须征服java虚拟机，如欲征服java虚拟机，需先征服java虚拟机内存模型。</p>\n</blockquote>\n<p>java虚拟机内存，是java虚拟机进行对象内存空间分配、垃圾回收的活动室，只有先了解java虚拟机内存才能在此基础上进一步了解对象内存分配、垃圾回收等活动。有别于真实物理机硬盘、主存、缓存、寄存器的存储模型，java虚拟机内存模型按照其存储模块负责的数据类型将其划分为如下图所示的模型：</p>\n<p><img src=\"https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/jvm/post1/jvm_memory_model.png\" alt=\"java虚拟机内存模型\"></p>\n<h2 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h2><p>堆是各个线程共享的内存区域，是java对象内存分配和垃圾回收的主战场，几乎所有的对象都是在堆中创建的。根据<em>Java虚拟机规范（Java Virtual Machine Specification）</em> 的规则，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。如果在堆中没有内存空间完成Java对象的内存分配时，将会抛出OutOfMemoryError（一下简称OOM）。</p>\n<p>关于堆的最常见虚拟机参数：</p>\n<ul>\n<li>-Xms ：表示虚拟机堆的最小值，如 -Xms10M 表示堆的最小值为10MB</li>\n<li>-Xmx ：表示虚拟机堆的最大值，如果 -Xmx100M 表示堆的最大值为100MB</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 设置虚拟机参数为：-Xms5M -Xmx5M</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class HeapOOM &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        ArrayList&lt;Byte[]&gt; bytes = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        for (; ; ) &#123;</span><br><span class=\"line\">            Byte[] _1M = new Byte[1024 * 1024];</span><br><span class=\"line\">            bytes.add(_1M);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>执行结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br><span class=\"line\">\tat jvm.post1.HeapOOM.main(HeapOOM.java:15)</span><br></pre></td></tr></table></figure>\n\n<p>“Java heap space”类型的OOM表示堆中没有可用的内存空间，具体到本例子中就是在大小为5M的堆中没有可用空间分配给大小为1M的数组对象。再来看一个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * @createtime 2019/11/2</span><br><span class=\"line\"> * 虚拟机参数 -Xms5M -Xmx5M </span><br><span class=\"line\">*/ </span><br><span class=\"line\">public class HeapOOM1 &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        ArrayList&lt;Object&gt; heapOOM1s = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        for (; ; ) &#123;</span><br><span class=\"line\">            heapOOM1s.add(new Object());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>执行结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: GC overhead limit exceeded</span><br><span class=\"line\">\tat jvm.post1.HeapOOM1.main(HeapOOM1.java:14)</span><br></pre></td></tr></table></figure>\n\n<p>“GC overhead limit exceeded” 类型的OOM是在jdk6后引入的一种新的错误类型。发生错误的原因是虚拟机用了大量的时间进行GC但是只释放了较小的空间，这是虚拟机的一种保护机制。具体到本例子中就是虚拟机在GC时没有能回收内存空间，浪费了时间却没有收获，所以就抛出了这个错误。可以用 <em>-XX:-UseGCOverheadLimit</em>参数禁用这个检查，但解决不了内存问题，只是把错误的信息延后，替换成 java.lang.OutOfMemoryError: Java heap space错误。</p>\n<h2 id=\"方法区\"><a href=\"#方法区\" class=\"headerlink\" title=\"方法区\"></a>方法区</h2><p>方法区和堆一样，也是各个线程共享的内存区域，它用来存储已经被虚拟机加载的类信息、常量池、静态变量等。方法区是jdk5到jdk8变化较大的java虚拟机内存区域。在jdk5和jdk6时，常量池是存在方法区的：</p>\n<p><img src=\"https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/jvm/post1/jvm_memory_model_1.5.png\" alt=\"jdk5和jdk6\"></p>\n<p>而从jdk7及其以后的版本，常量池被放到了堆里面：</p>\n<p><img src=\"https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/jvm/post1/jvm_memory_model_1.7.png\" alt=\"jdk7\"></p>\n<p>常量池就是java语言系统级别的缓存，目的是让程序在运行过程中速度更快，更节省内存空间，java的8种基本数据类型外加String类型，共9种类型都有对应的常量池。这些类型的对象不可能全都放到常量池中存储，因此不同的类型有不同的存储策略，具体到String类型的对象来说，有如下三条规则：</p>\n<ul>\n<li>用双引号创建的对象放在常量池中，如 “Hello”，”Jvm”这种。</li>\n<li>用双引号创建的对象相加产生的对象放在常量池，如 <em>String s = “Hello” + “Jvm”;</em>，这里的s对象就是放在常量池中的。</li>\n<li>调用String对象的intern方法会返回一个存放在常量池中的String对象,且两个对象内容相同。</li>\n</ul>\n<p>再回到本篇的主题上，因为常量池位置的变化，在不同的jdk版本下，下面代码的执行结果是不一样的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ConstantsPool &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        String s = new String(&quot;Hello&quot;) + new String(&quot;Jvm&quot;); //1</span><br><span class=\"line\">        String s1 = s.intern();  //2</span><br><span class=\"line\">        System.out.println(s == s1); //jdk5和jdk6中返回false，jdk7及其以上版本返回true。</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>在jdk7之前，程序在执行//2处代码之前常量池中没有”HelloJvm”这个字符串常量，//2处代码执行时，程序会在常量池中创建一个”HelloJvm”的字符串对象s1并返回，而常量池是在方法区的。那一个在堆中的s对象和方法区中的s1对象比较地址是否相同，当然会得到false。<br>在jdk7及其以后的版本，程序在执行//2出代码时，发现常量池中同样没有”HelloJvm”这个对象，但因为常量池已经迁移到堆中，常量池不需要存储一个对象了，程序只是简单的把s这个对象的引用在常量池中存储了，此时s和s1指向的是同一个对象，结果当然是true。</p>\n<p>上面简单介绍了jdk7中常量池的变化，而在jdk8中方法整个方法区被放到了物理机的本地内存,同时也更名为元空间（MetaSpace）：</p>\n<p><img src=\"https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/jvm/post1/jvm_memory_model_1.8.png\" alt=\"jdk8\"></p>\n<p>jdk8及其以后的版本，元空间直接使用物理机的本地内存，在不加限制的情况下其最大值为本地内存的最大可用值。考虑到物理机上可能部署其它的应用服务，通常会给元空间加一个大小限制。</p>\n<p>关于元空间最常见的虚拟机参数是：</p>\n<ul>\n<li>-XX:MetaspaceSize : 表示虚拟机元空间发生MetadataGC时的初始阈值,如 -XX:MetaspaceSize=10M 表示元空间在第一次到大10M时，会发生一次MetadataGC。</li>\n<li>-XX:MaxMetaspaceSize ： 表示虚拟机元空间的最大值为MaxMetaspaceSize，如 -XX:MaxMetaspaceSize=15M 表示元空间的最大值为15M，再大就会发生OOM异常。</li>\n</ul>\n<p>关于元空间的的内存溢出模拟，我们需要借助CGLib来动态的创建类，先引入如下maven依赖：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;cglib&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;cglib-nodep&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;3.3.0&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n\n<p>具体代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 虚拟机参数 -XX:MaxMetaspaceSize=10M </span><br><span class=\"line\"> * @description 元空间内存溢出</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class MetaSpaceOOM &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        BeanGenerator beanGenerator = new BeanGenerator();</span><br><span class=\"line\">        List&lt;Class&gt; classes = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        for (int i=0; i&lt;1000000000L;i++ ) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            beanGenerator.addProperty(&quot;id&quot;+i, Integer.class);</span><br><span class=\"line\">            Object aClass = beanGenerator.createClass();</span><br><span class=\"line\">            classes.add((Class) aClass);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> 执行结果为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Exception in thread &quot;main&quot; java.lang.IllegalStateException: Unable to load cache item</span><br><span class=\"line\">\tat net.sf.cglib.core.internal.LoadingCache.createEntry(LoadingCache.java:79)</span><br><span class=\"line\">\tat net.sf.cglib.core.internal.LoadingCache.get(LoadingCache.java:34)</span><br><span class=\"line\">\tat net.sf.cglib.core.AbstractClassGenerator$ClassLoaderData.get(AbstractClassGenerator.java:119)</span><br><span class=\"line\">\tat net.sf.cglib.core.AbstractClassGenerator.create(AbstractClassGenerator.java:294)</span><br><span class=\"line\">\tat net.sf.cglib.beans.BeanGenerator.createHelper(BeanGenerator.java:94)</span><br><span class=\"line\">\tat net.sf.cglib.beans.BeanGenerator.createClass(BeanGenerator.java:85)</span><br><span class=\"line\">\tat jvm.post1.MetaSpaceOOM.main(MetaSpaceOOM.java:19)</span><br><span class=\"line\">Caused by: java.lang.OutOfMemoryError: Metaspace</span><br><span class=\"line\">\tat net.sf.cglib.core.AbstractClassGenerator.generate(AbstractClassGenerator.java:348)</span><br><span class=\"line\">\tat net.sf.cglib.core.AbstractClassGenerator$ClassLoaderData$3.apply(AbstractClassGenerator.java:96)</span><br><span class=\"line\">\tat net.sf.cglib.core.AbstractClassGenerator$ClassLoaderData$3.apply(AbstractClassGenerator.java:94)</span><br><span class=\"line\">\tat net.sf.cglib.core.internal.LoadingCache$2.call(LoadingCache.java:54)</span><br><span class=\"line\">\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)</span><br><span class=\"line\">\tat net.sf.cglib.core.internal.LoadingCache.createEntry(LoadingCache.java:61)</span><br><span class=\"line\">\t... 6 more</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，引起IllegalStateException异常的正是因为”Metaspace”类型的OOM错误。具体原因为BeanGenerator对象通过createClass方法不断创建新的类，导致最大内存为10MB的元空间没办法存储类的信息而抛出异常。</p>\n<h2 id=\"虚拟机栈和本地方法栈\"><a href=\"#虚拟机栈和本地方法栈\" class=\"headerlink\" title=\"虚拟机栈和本地方法栈\"></a>虚拟机栈和本地方法栈</h2><p>虚拟机栈和本地方法栈，都是线程私有的，主要用来存储在线程运行过程中的局部变量、操作数栈、方法出入口等信息，这些信息是以栈帧的形式存储的，虚拟机栈和本地方法栈的区别就是一个存储java方法运行时的栈帧数据一个存储本地方法（native 关键字修饰的方法）运行时的栈帧数据。由于都是存储栈帧数据，两种栈的区别不是很大，甚至在HotSpot虚拟机中，直接把这两个合二为一，所以本小节把这两种栈合起来说。java程序在运行时的栈数据结构如下图：</p>\n<p><img src=\"https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/jvm/post1/stack-model.jpg\" alt=\"运行时栈结构\">  </p>\n<p>在介绍堆时，我们曾说过几乎所有的对象都是在堆中创建的，这几乎中的特例就来自于栈，对象是可以在栈上创建，我们称为栈上分配。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 执行栈上分配的虚拟机参数  -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -Xmx10M</span><br><span class=\"line\"> * 不执行栈上分配的虚拟机参数  -XX:-DoEscapeAnalysis -XX:+EliminateAllocations -Xmx10M</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * 参数说明：</span><br><span class=\"line\"> * DoEscapeAnalysis  ： 逃逸分析，对于本例来说逃逸分析可以判断出//1处创建的对象是否会被本方法外的方法获取到。</span><br><span class=\"line\"> * EliminateAllocations ： 标量替换，对于本例来说，在逃逸分析的帮助下发现//1出的User对象不会逃逸出方法allo，那么消除User对象的堆内存分配，把它的字段改为一个个独立的局部变量（本例中是int类型的标量）存储在线程的栈中。</span><br><span class=\"line\"> * 要模拟栈上分配，需要逃逸分析和标量替换两个功能都是开启的。</span><br><span class=\"line\"> * @description 栈上分配</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class StackAllocation &#123;</span><br><span class=\"line\">    static class User&#123;</span><br><span class=\"line\">        int i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void allo() &#123;</span><br><span class=\"line\">        User user = new User(); //1</span><br><span class=\"line\">        user.i = 4;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        long startTime = System.currentTimeMillis();</span><br><span class=\"line\">        for (int i = 0; i &lt; 100000000L; i++) &#123;</span><br><span class=\"line\">            allo();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        long endTime = System.currentTimeMillis();</span><br><span class=\"line\">        System.out.println(endTime - startTime);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>用不同的虚拟机参数执行上面的代码时，会发现同样执行1亿次方法调用，栈上分配的执行时间明显比非栈上分配的执行时间短。简单的解释就是1亿个的User对象不是被分配在堆上，这样就避免了频繁的GC，对性能自然有很大提升。</p>\n<p>与栈相关的虚拟机参数主要有：</p>\n<ul>\n<li>-Xss : 设置java线程栈的大小，如 -Xss100k 表示每个java线程栈的大小为100k。</li>\n</ul>\n<p>线程栈是用来存方法的栈帧的。线程栈越大其能调用的方法深度越大，运行如下代码可以印证此观点：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 虚拟机参数 -Xss1000K</span><br><span class=\"line\"> * @description 模拟栈内存溢出</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class StackOverFlowOOM &#123;</span><br><span class=\"line\">    private static int num = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void loop()&#123;</span><br><span class=\"line\">        num++;</span><br><span class=\"line\">        loop();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            loop();</span><br><span class=\"line\">        &#125; catch (Throwable e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            System.out.println(num);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当Xss的值越大时，程序中的num变量在栈溢出异常时的值越大。jdk8中如果不指定Xss参数的大小，那么其默认值为1MB，这也从内存角度印证线程是一种昂贵的资源，即使简单的创建一个线程而不分配给其处理任务，其也要占用一些内存空间。</p>\n<h2 id=\"程序计数器\"><a href=\"#程序计数器\" class=\"headerlink\" title=\"程序计数器\"></a>程序计数器</h2><p>程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器，因为操作系统会分配给各个线程一些时间片来运行，当时间片用完后，就需要有程序计数器记录线程执行的位置，用来在线程重新获得时间片时能恢复到原来的执行位置。从程序计数器的用途得知，程序程序计数器也是线程私有的，而且也是唯一一个不会有OOM异常的虚拟机内存区域。</p>\n<h2 id=\"篇尾小节\"><a href=\"#篇尾小节\" class=\"headerlink\" title=\"篇尾小节\"></a>篇尾小节</h2><p>本篇主要简绍了java虚拟机在运行时的各个内存区域，简单介绍了它们的作用和内存溢出的方式。</p>\n<blockquote>\n<p>有任何不懂或者质疑的地方，都欢迎大家积极留言讨论，留言必回，一起学习进步。</p>\n</blockquote>\n<!--\n参考文献 ：\nhttp://lovestblog.cn/blog/2016/10/29/metaspace/ \n-->"}],"PostAsset":[],"PostCategory":[{"post_id":"ckag4s7q800023oiehzpy40qr","category_id":"ckag4s7qc00043oieg0dhcyn0","_id":"ckag4s7qh00063oiee6pv9fao"},{"post_id":"ckag4s7qb00033oie0fq099vx","category_id":"ckag4s7qc00043oieg0dhcyn0","_id":"ckag4s7qh00073oie6tc4bxvu"},{"post_id":"ckag4s7qm00083oiefh259h4x","category_id":"ckag4s7qo000a3oieayw0fprl","_id":"ckag4s7r0000l3oieepigae6u"},{"post_id":"ckag4s7qm00083oiefh259h4x","category_id":"ckag4s7qz000i3oieagzt4aeq","_id":"ckag4s7r0000m3oie919zathc"},{"post_id":"ckag4s7qn00093oie0v9e1mgo","category_id":"ckag4s7qo000a3oieayw0fprl","_id":"ckag4s7r2000q3oie4f747wtr"},{"post_id":"ckag4s7qn00093oie0v9e1mgo","category_id":"ckag4s7qz000i3oieagzt4aeq","_id":"ckag4s7r2000r3oie8lm0dunm"},{"post_id":"ckag4s7qp000b3oiedii184w7","category_id":"ckag4s7qo000a3oieayw0fprl","_id":"ckag4s7r2000s3oiehu76gipo"},{"post_id":"ckag4s7qp000b3oiedii184w7","category_id":"ckag4s7qz000i3oieagzt4aeq","_id":"ckag4s7r3000u3oie5g8f8vfk"},{"post_id":"ckag4s7qt000c3oie6dkjdy77","category_id":"ckag4s7qz000h3oieauwube26","_id":"ckag4s7r3000w3oie5aaf99pm"},{"post_id":"ckag4s7qt000c3oie6dkjdy77","category_id":"ckag4s7r2000p3oief0wvhbtw","_id":"ckag4s7r3000x3oiechiv2tz0"},{"post_id":"ckag4s7qu000d3oief6kn34d9","category_id":"ckag4s7qz000h3oieauwube26","_id":"ckag4s7r3000y3oie1zl8b6q6"},{"post_id":"ckag4s7qu000d3oief6kn34d9","category_id":"ckag4s7r2000p3oief0wvhbtw","_id":"ckag4s7r4000z3oie97sp7jcb"},{"post_id":"ckag4s7qw000f3oie7v9gbm01","category_id":"ckag4s7r0000k3oie4uh03wqf","_id":"ckag4s7r400103oie2idi4nsc"},{"post_id":"ckag4s7qw000f3oie7v9gbm01","category_id":"ckag4s7r3000v3oieguba4hf4","_id":"ckag4s7r400113oie0xk4bio8"},{"post_id":"ckag4s7r500123oie5kc54wri","category_id":"ckag4s7r0000k3oie4uh03wqf","_id":"ckag4s7r600133oieh0tda5ru"},{"post_id":"ckag4s7r500123oie5kc54wri","category_id":"ckag4s7r3000v3oieguba4hf4","_id":"ckag4s7r600143oie8bwa5lsn"}],"PostTag":[],"Tag":[]}}