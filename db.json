{"meta":{"version":1,"warehouse":"3.0.2"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"themes/3-hexo/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/gitalk.css","path":"css/gitalk.css","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/mobile.styl","path":"css/mobile.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/img/alipay.jpg","path":"img/alipay.jpg","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/img/school-book.png","path":"img/school-book.png","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/img/article-list-background.jpeg","path":"img/article-list-background.jpeg","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/img/avatar.jpg","path":"img/avatar.jpg","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/img/brown-papersq.png","path":"img/brown-papersq.png","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/img/weixin.jpg","path":"img/weixin.jpg","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/js/jquery.autocomplete.min.js","path":"js/jquery.autocomplete.min.js","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/js/iconfont.js","path":"js/iconfont.js","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/js/jquery.pjax.js","path":"js/jquery.pjax.js","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/js/script.js","path":"js/script.js","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/js/search.js","path":"js/search.js","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.eot","path":"css/fonts/icomoon.eot","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.ttf","path":"css/fonts/icomoon.ttf","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.svg","path":"css/fonts/icomoon.svg","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.woff","path":"css/fonts/icomoon.woff","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/iconfont.eot","path":"css/fonts/iconfont.eot","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/iconfont.ttf","path":"css/fonts/iconfont.ttf","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/iconfont.svg","path":"css/fonts/iconfont.svg","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/iconfont.woff","path":"css/fonts/iconfont.woff","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/selection.json","path":"css/fonts/selection.json","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/atom-dark.styl","path":"css/hl_theme/atom-dark.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/brown-paper.styl","path":"css/hl_theme/brown-paper.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/github-gist.styl","path":"css/hl_theme/github-gist.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/atom-light.styl","path":"css/hl_theme/atom-light.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/darcula.styl","path":"css/hl_theme/darcula.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-dark.styl","path":"css/hl_theme/kimbie-dark.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/github.styl","path":"css/hl_theme/github.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-light.styl","path":"css/hl_theme/kimbie-light.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-dark.styl","path":"css/hl_theme/gruvbox-dark.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-light.styl","path":"css/hl_theme/gruvbox-light.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/railscasts.styl","path":"css/hl_theme/railscasts.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/rainbow.styl","path":"css/hl_theme/rainbow.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/school-book.styl","path":"css/hl_theme/school-book.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/sublime.styl","path":"css/hl_theme/sublime.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/sunburst.styl","path":"css/hl_theme/sunburst.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/zenbum.styl","path":"css/hl_theme/zenbum.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/js/gitment.js","path":"js/gitment.js","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/js/gitalk.js","path":"js/gitalk.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"f5367a984ed6b614412786e8434452fab61cf9e9","modified":1574254007926},{"_id":"themes/3-hexo/.gitignore","hash":"560a43fddfe4559ed1a17e7362874454519f189b","modified":1574254007940},{"_id":"themes/3-hexo/README.md","hash":"754d6f873d73f4a7faf5530fa4062e9a696a8fd4","modified":1574254007940},{"_id":"themes/3-hexo/_config.yml","hash":"55ae74e5614051cd470705d5efd50a03f9796dbd","modified":1574254007940},{"_id":"source/about/index.md","hash":"43b0945986d61f77c62ca7910a212989b5162b19","modified":1574254007939},{"_id":"source/categories/index.md","hash":"f8aea921bd9f768398e8fdbe9565830ce77da537","modified":1574254007939},{"_id":"themes/3-hexo/layout/index.ejs","hash":"a5c464897e7dc9d45d03d8b61e742b1ac4173a95","modified":1574254007949},{"_id":"themes/3-hexo/layout/indexs.md","hash":"4dbd2094fff1e3146e67b33aa0326b193d0496c7","modified":1574254007949},{"_id":"themes/3-hexo/layout/post.ejs","hash":"aeda285031ba8d4e94225e82b364bcf5f79fce1d","modified":1574254007949},{"_id":"themes/3-hexo/layout/_partial/comment.ejs","hash":"d18f94e04ef0cf7abb432a8e707ccb3abc7fe435","modified":1574254007943},{"_id":"themes/3-hexo/layout/_partial/article_copyright.ejs","hash":"05d3cddf5f3a53577452db4efa811bd361f7c0c4","modified":1574254007942},{"_id":"themes/3-hexo/layout/_partial/article.ejs","hash":"d3c928954057bcebdf3fc294b2123885b08396d3","modified":1574254007942},{"_id":"themes/3-hexo/layout/_partial/copyright.ejs","hash":"faffe25aec33936fa2ec9d8f0e34e16ef3d90c25","modified":1574254007944},{"_id":"themes/3-hexo/layout/_partial/friends.ejs","hash":"558a3d4bad578819fb07729fe1b50d9b81da8b93","modified":1574254007946},{"_id":"themes/3-hexo/layout/_partial/full-toc.ejs","hash":"0e976208d79b0396eb51ca1af5016c963c6e4618","modified":1574254007946},{"_id":"themes/3-hexo/layout/_partial/dashang.ejs","hash":"6eab1e5fae6bd60928325d026a1bed61c43d11a9","modified":1574254007945},{"_id":"themes/3-hexo/layout/_partial/footer.ejs","hash":"311489fe2050ada8a0eaad3d0c57e5d5012f470e","modified":1574254007946},{"_id":"themes/3-hexo/layout/_partial/mathjax.ejs","hash":"e2be0e37f3d48e63e65a47d819bfb800b9aa3784","modified":1574254007947},{"_id":"themes/3-hexo/layout/_partial/header.ejs","hash":"915d5f10dd8f3dcd19cb75010e23689e8f385caf","modified":1574254007947},{"_id":"themes/3-hexo/layout/_partial/tag.ejs","hash":"87e932476754f27424f9ec397ed66a4ab8a59ad8","modified":1574254007948},{"_id":"themes/3-hexo/layout/_partial/nav-left.ejs","hash":"c14bc1393f779dff7854089621804dceea236d82","modified":1574254007948},{"_id":"themes/3-hexo/layout/_partial/meta.ejs","hash":"ef387e80043b62e1925a068267f2377cac64adc7","modified":1574254007947},{"_id":"themes/3-hexo/layout/_partial/nav-right.ejs","hash":"98326675546fc6828a45e8b95250899b4ee2d821","modified":1574254007948},{"_id":"themes/3-hexo/layout/_partial/toc-ref.ejs","hash":"33f7a4bfca1bb9835ec8f0d1e73188d1f56cc8b9","modified":1574254007948},{"_id":"themes/3-hexo/source/css/style.styl","hash":"322abe325d5fe9ff37347bdd19e772315a8ebfed","modified":1574254007964},{"_id":"themes/3-hexo/source/css/gitalk.css","hash":"3dc58e9a3fd63a3144d5fe850eb55e3dc885c9fb","modified":1574254007958},{"_id":"themes/3-hexo/source/css/mobile.styl","hash":"d10bdd736aa343f38fe15cba4c81d45d3d259de4","modified":1574254007964},{"_id":"themes/3-hexo/source/img/alipay.jpg","hash":"c4a96cc935740fb2db5b5db401747401f90a74d1","modified":1574254007965},{"_id":"themes/3-hexo/source/img/school-book.png","hash":"711ec983c874e093bb89eb77afcbdf6741fa61ee","modified":1574254007967},{"_id":"themes/3-hexo/source/img/article-list-background.jpeg","hash":"4fdf8b3e53dd02d6ee6360aebfadb0cba1fb5633","modified":1574254007966},{"_id":"themes/3-hexo/source/img/avatar.jpg","hash":"a42360089bfa892d803cf5747eab359d90f337f1","modified":1574254007967},{"_id":"themes/3-hexo/source/img/brown-papersq.png","hash":"3a1332ede3a75a3d24f60b6ed69035b72da5e182","modified":1574254007967},{"_id":"themes/3-hexo/source/img/weixin.jpg","hash":"bb917845578c38ad291a18186225d566b58b0fcc","modified":1574254007968},{"_id":"themes/3-hexo/source/js/jquery.autocomplete.min.js","hash":"2462169ad7f4a8ae9f9f4063995cbe7fed45cd77","modified":1574254007972},{"_id":"themes/3-hexo/source/js/iconfont.js","hash":"3a0869ca1b09af07d82987e343a3bc4cb9558ecb","modified":1574254007972},{"_id":"themes/3-hexo/source/js/jquery.pjax.js","hash":"8c2a4f10a4da3d9615a3a81542494c6d21479b3d","modified":1574254007973},{"_id":"themes/3-hexo/source/js/script.js","hash":"14772b08b9c3d5c99a4b54748be9666deaae2778","modified":1574254007973},{"_id":"themes/3-hexo/source/js/search.js","hash":"788c610149a5f9361295f9f0207c8523f37ddb8b","modified":1574254007974},{"_id":"themes/3-hexo/layout/_partial/comments/gentie.ejs","hash":"908d9046502612d24780ca354bd9392a009b4d7b","modified":1574254007944},{"_id":"themes/3-hexo/layout/_partial/comments/disqus.ejs","hash":"32ce7b48d366b9c888ff2ceb911a3cd82f864537","modified":1574254007943},{"_id":"themes/3-hexo/layout/_partial/comments/click2show.ejs","hash":"8a3a175c2da956366ce91bfc4f4012a487f4bdfc","modified":1574254007943},{"_id":"themes/3-hexo/layout/_partial/comments/gitment.ejs","hash":"eaf2b6f297282606b630ad55fb9e38af7e2829dc","modified":1574254007944},{"_id":"themes/3-hexo/layout/_partial/comments/gitalk.ejs","hash":"01567e010cf4f2dd141fe2019490d3f0d5aa2529","modified":1574254007944},{"_id":"themes/3-hexo/source/css/_partial/autocomplete.styl","hash":"1ffe51e3b77afefcd94d386a718506d5b055ad94","modified":1574254007950},{"_id":"themes/3-hexo/source/css/_partial/comment.styl","hash":"fe00fb1269b4fe1f3d5ab917891926222ce47275","modified":1574254007950},{"_id":"themes/3-hexo/source/css/_partial/dashang.styl","hash":"f0eac1dc1f5dbed1769d032bb5fd5f002faaee26","modified":1574254007951},{"_id":"themes/3-hexo/source/css/_partial/fade.styl","hash":"02c7510a26f306e240f23ddbf772a69be2c890dd","modified":1574254007951},{"_id":"themes/3-hexo/source/css/_partial/full-toc.styl","hash":"4102753dad0cc1ee9ed673f7253ba097a960c3b7","modified":1574254007952},{"_id":"themes/3-hexo/source/css/_partial/nav-left.styl","hash":"bf29eab9ea75fa191d678b6eefec440505ddf6e3","modified":1574254007952},{"_id":"themes/3-hexo/source/css/_partial/font.styl","hash":"c200f3fabcfe83f3e45746e186b4bb111e73ad47","modified":1574254007952},{"_id":"themes/3-hexo/source/css/_partial/nprogress.styl","hash":"2620a02169a6aeb75137fd368eac2c36423d8498","modified":1574254007953},{"_id":"themes/3-hexo/source/css/_partial/nav-right.styl","hash":"1d01247f974b059d9ef6a2178a724b4f72acd659","modified":1574254007953},{"_id":"themes/3-hexo/source/css/fonts/icomoon.eot","hash":"b6195bedc1cb2f9cfcb26cc27021f2e94be2ab0a","modified":1574254007954},{"_id":"themes/3-hexo/source/css/_partial/num-load.styl","hash":"f7ef35459ece22e1da950b86126be1c2bfe97fcf","modified":1574254007953},{"_id":"themes/3-hexo/source/css/fonts/icomoon.ttf","hash":"eb976d8b8559fcddfc2658a03a4350cb566fc06b","modified":1574254007955},{"_id":"themes/3-hexo/source/css/_partial/post.styl","hash":"8a462cf9b0b026e71eda9e704c0fbb952b4615c5","modified":1574254007954},{"_id":"themes/3-hexo/source/css/fonts/icomoon.svg","hash":"b5e7562c8494b0ddb3a70ecc5545ef7340d8e971","modified":1574254007955},{"_id":"themes/3-hexo/source/css/fonts/icomoon.woff","hash":"3985d29416bb9b19f50a2f20f2bbbce47f10af8d","modified":1574254007955},{"_id":"themes/3-hexo/source/css/fonts/iconfont.eot","hash":"3dfe8e557d9dfaf39bca088a02b76deb82dbaa3d","modified":1574254007956},{"_id":"themes/3-hexo/source/css/fonts/iconfont.ttf","hash":"aa087561480fb9c2cfd541e33d1e99d5ac1a56bb","modified":1574254007957},{"_id":"themes/3-hexo/source/css/fonts/iconfont.svg","hash":"7e54ae44c02faa319c4fe128e1e6bda38eae5c9d","modified":1574254007956},{"_id":"themes/3-hexo/source/css/fonts/iconfont.woff","hash":"f8ed131ccf13f4bdd3ec11fc3e997339dd7b66ba","modified":1574254007957},{"_id":"themes/3-hexo/source/css/fonts/selection.json","hash":"b6456a4eabcffd95e822d1d7adce96da524d481a","modified":1574254007958},{"_id":"themes/3-hexo/source/css/hl_theme/atom-dark.styl","hash":"f3eb4e5feda9cbd6242ccf44ca064e2979b5d719","modified":1574254007959},{"_id":"themes/3-hexo/source/css/hl_theme/brown-paper.styl","hash":"03af387edcc1cf8c18d12e9c440fd51b6cf425b6","modified":1574254007960},{"_id":"themes/3-hexo/source/css/hl_theme/github-gist.styl","hash":"5e05b19832c1099bd9d284bc3ed00dc8a3d7ee23","modified":1574254007960},{"_id":"themes/3-hexo/source/css/hl_theme/atom-light.styl","hash":"69d184a682bcaeba2b180b437dc4431bc3be38aa","modified":1574254007959},{"_id":"themes/3-hexo/source/css/hl_theme/darcula.styl","hash":"2bfc14f27ccca108b4b3755782de8366e8bd001e","modified":1574254007960},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-dark.styl","hash":"e9c190f9ffc37a13cac430512e4e0c760205be4a","modified":1574254007961},{"_id":"themes/3-hexo/source/css/hl_theme/github.styl","hash":"53276ff1f224f691dfe811e82c0af7f4476abf5d","modified":1574254007960},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-light.styl","hash":"0c3ccd0d64e7504c7061d246dc32737f502f64e4","modified":1574254007962},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-dark.styl","hash":"315ad610d303caba9eac80a7d51002193a15478a","modified":1574254007961},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-light.styl","hash":"1bece084b1dbbbd4af064f05feffd8c332b96a48","modified":1574254007961},{"_id":"themes/3-hexo/source/css/hl_theme/railscasts.styl","hash":"a6e8cfd2202afd7893f5268f3437421e35066e7b","modified":1574254007962},{"_id":"themes/3-hexo/source/css/hl_theme/rainbow.styl","hash":"e5c37646a9d9c1094f9aab7a7c65a4b242e8db00","modified":1574254007962},{"_id":"themes/3-hexo/source/css/hl_theme/school-book.styl","hash":"51659351b391a2be5c68728bb51b7ad467c5e0db","modified":1574254007962},{"_id":"themes/3-hexo/source/css/hl_theme/sublime.styl","hash":"501d75ef0f4385bea24d9b9b4cc434ba68d4be27","modified":1574254007963},{"_id":"themes/3-hexo/source/css/hl_theme/sunburst.styl","hash":"2aa9817e68fb2ed216781ea04b733039ebe18214","modified":1574254007963},{"_id":"themes/3-hexo/source/css/hl_theme/zenbum.styl","hash":"92941a6ae73b74f44ad7c559c5548c44073c644a","modified":1574254007963},{"_id":"themes/3-hexo/source/js/gitment.js","hash":"67984b83cd46ff4300d4fd959bf6c17dd66b4136","modified":1574254007971},{"_id":"source/_posts/java/jvm/post1/ConstantsPool.java","hash":"7eea4b872f6c126fb69bef08e57c6ce13d938ec5","modified":1574254007929},{"_id":"source/_posts/java/jvm/post1/HeapOOM.java","hash":"c20ca6a4b82843307743d44abdf0b79a873554b7","modified":1574254007930},{"_id":"source/_posts/java/jvm/post0/post0.md","hash":"209cc1ed95b15bd9688ef89f0cfb2547be26abe9","modified":1574254007929},{"_id":"source/_posts/java/jvm/post0/HotSpot-architecture.jpg","hash":"c6be406d9ede267e76ab3d34544313c7c677f9ab","modified":1574254007928},{"_id":"source/_posts/java/jvm/post1/HeapOOM1.java","hash":"2b607db8590bec16abdefaf81b7e0fb7e53af815","modified":1574254007930},{"_id":"source/_posts/java/jvm/post1/StackOverFlowOOM.java","hash":"5384e1e835fbe4b66ae4755a9776f3b09dc9ec31","modified":1574254007934},{"_id":"source/_posts/java/jvm/post1/MetaSpaceOOM.java","hash":"2f938b421196d473b33b96e7cef9243aef96cbe6","modified":1574254007933},{"_id":"source/_posts/java/jvm/post1/jvm_memory_model.png","hash":"457d528d6e7085a77bc05c616e6d47600d926521","modified":1574254007934},{"_id":"source/_posts/java/jvm/post1/StackAllocation.java","hash":"2d6f7c952abb176e7dd2fd433caa5540a438e9ba","modified":1574254007933},{"_id":"source/_posts/java/jvm/post1/jvm_memory_model_1.5.png","hash":"00f81e6613147b382d0f835214066541fd736f6b","modified":1574254007935},{"_id":"source/_posts/java/jvm/post1/stack-model.jpg","hash":"a4ef01cc6abdcd5a1f546c780337e395dd744371","modified":1574254007937},{"_id":"source/_posts/java/jvm/post1/post1.md","hash":"6f48d02bd549eb82660c8de38a1e6d0982875f91","modified":1574254007936},{"_id":"source/_posts/java/jvm/post1/jvm_memory_model_1.7.png","hash":"9f029d55a0f81bb72c39070bd55ac7c85c0ea33f","modified":1574254007935},{"_id":"source/_posts/java/jvm/post1/jvm_memory_model_1.8.png","hash":"e5e0a2798a065b161ff3064687d3b516f86e051a","modified":1574254007936},{"_id":"themes/3-hexo/source/js/gitalk.js","hash":"536f28c4354a13582af826d9d9b2cb27cec07dc6","modified":1574254007970},{"_id":"source/_posts/java/jvm/post0/HotSpot虚拟机组件结构.pos","hash":"6122612c9ac6a86ea4639c43bcd88771f15d661c","modified":1574254007929},{"_id":"source/_posts/java/jvm/post1/栈帧信息.pos","hash":"e2aa655f4634b88ddfac2be666433d30d7031f7d","modified":1574254007938},{"_id":"source/_posts/java/jvm/post1/JAVA运行时数据划分.pos","hash":"5fa8983b220ed70b210eef04c5a83a5992b0aace","modified":1574254007933}],"Category":[{"name":"jvm","_id":"ck5z3rh450004zgiegjz9audd"},{"name":"java虚拟机，说点不一样的","parent":"ck5z3rh450004zgiegjz9audd","_id":"ck5z3rh490006zgie37wx0czu"}],"Data":[],"Page":[{"title":"categories","date":"2019-11-04T09:43:11.000Z","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2019-11-04 17:43:11\n---\n","updated":"2019-11-20T12:46:47.939Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ck5z3rh250000zgie1wh4gsj1","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"关于作者","date":"2017-09-27T02:27:42.000Z","_content":"### 个人简介\naworker，\n\n毕业于[东北哪所大学](http://www.neu.edu.cn/)，目前在贝壳找房从事java后端开发工作。\n\n喜欢研究新兴技术和未来发展方向，有任何疑问都欢迎你留言，留言必回。\n\n### 最近\n最近在写java虚拟机方面的文章\n\n\n### 联系方式\n- 邮箱 : lmyuanwork@163.com\n\n","source":"about/index.md","raw":"---\ntitle: 关于作者\ndate: 2017-09-27 10:27:42\n---\n### 个人简介\naworker，\n\n毕业于[东北哪所大学](http://www.neu.edu.cn/)，目前在贝壳找房从事java后端开发工作。\n\n喜欢研究新兴技术和未来发展方向，有任何疑问都欢迎你留言，留言必回。\n\n### 最近\n最近在写java虚拟机方面的文章\n\n\n### 联系方式\n- 邮箱 : lmyuanwork@163.com\n\n","updated":"2019-11-20T12:46:47.939Z","path":"about/index.html","comments":1,"layout":"page","_id":"ck5z3rh290001zgieermaextu","content":"<h3 id=\"个人简介\"><a href=\"#个人简介\" class=\"headerlink\" title=\"个人简介\"></a>个人简介</h3><p>aworker，</p>\n<p>毕业于<a href=\"http://www.neu.edu.cn/\" target=\"_blank\" rel=\"noopener\">东北哪所大学</a>，目前在贝壳找房从事java后端开发工作。</p>\n<p>喜欢研究新兴技术和未来发展方向，有任何疑问都欢迎你留言，留言必回。</p>\n<h3 id=\"最近\"><a href=\"#最近\" class=\"headerlink\" title=\"最近\"></a>最近</h3><p>最近在写java虚拟机方面的文章</p>\n<h3 id=\"联系方式\"><a href=\"#联系方式\" class=\"headerlink\" title=\"联系方式\"></a>联系方式</h3><ul>\n<li>邮箱 : <a href=\"mailto:lmyuanwork@163.com\">lmyuanwork@163.com</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"个人简介\"><a href=\"#个人简介\" class=\"headerlink\" title=\"个人简介\"></a>个人简介</h3><p>aworker，</p>\n<p>毕业于<a href=\"http://www.neu.edu.cn/\" target=\"_blank\" rel=\"noopener\">东北哪所大学</a>，目前在贝壳找房从事java后端开发工作。</p>\n<p>喜欢研究新兴技术和未来发展方向，有任何疑问都欢迎你留言，留言必回。</p>\n<h3 id=\"最近\"><a href=\"#最近\" class=\"headerlink\" title=\"最近\"></a>最近</h3><p>最近在写java虚拟机方面的文章</p>\n<h3 id=\"联系方式\"><a href=\"#联系方式\" class=\"headerlink\" title=\"联系方式\"></a>联系方式</h3><ul>\n<li>邮箱 : <a href=\"mailto:lmyuanwork@163.com\">lmyuanwork@163.com</a></li>\n</ul>\n"}],"Post":[{"title":"00开篇","date":"2019-11-09T08:36:13.000Z","_content":"\n有别于C/C++语言，java虚拟机解放了java程序员，使我们在开发过程中不必负责每个对象的出生和死亡，我们只管用new关键字创建对象，使用对象，对于不在使用的对象所占的内存空间的回收，完全交给java虚拟机来负责。在程序内存管理领域，java虚拟机即让我们避免成为分配对象内存，回收对象内存这样单调工作的奴隶；也让我们丧失了成为掌握对象内存空间管理“生杀大权”的皇帝，内存管理对我们越发的陌生和透明，一旦有内存泄露或者溢出以及涉及到虚拟机方面的性能调优，都会让我们手足无措。《也谈java虚拟机，说点不一样的》系列文章，力求用简单，生动，具体的讲述风格讲解java虚拟机的运作机制，让广大java开发人员得以管窥一二，在实际工作中、在面试找工作时、在饭后和同事吹逼时，都能得心应手，从容应对。鉴于java虚拟机知识体系的庞杂和深邃以及本员能力的限制，系列文章中难免有错误和不足，希望大家多多包涵。\n\njava虚拟机是一个抽象的计算机。对于程序开发人员来说，我们只需要编写好我们的程序，让不同平台上的java虚拟机完成java代码到不同操作系统计算机指令的转化，通过这种方式java语言实现了其夸平台特性。虽然名为java虚拟机，但是它并不是和java语言强绑定的，java虚拟机只能识别有特定语法格式的class文件，而所有能编译为class文件的语言，都可以在java虚拟机上运行，java虚拟机不是“java语言的虚拟机”而是“多语言的虚拟机”。\n\n在java虚拟机的发展历史上，曾经有很多的优秀的虚拟机实现。如随着jdk1.0一起发布的Classic VM，号称速度最快的JRockit VM，以及专精Windows平台的Microsoft JVM等。但我们普通程序员用的最多的也是“血统最纯正”虚拟机实现就是Sun公司发布的HotSpot VM，这个系列也以HotSpot虚拟机为蓝本进行讲述的。\n\n\nHotSpot虚拟机的组件结构如下：\n\n![HotSpot虚拟机组件结构](https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/jvm/post0/HotSpot-architecture.jpg) \n\nHotSpot虚拟机有三大主要模块：\n\n+ 类加载子系统，主要用来加载class文件，从中获取类信息。\n+ 虚拟机运行时数据区，主要存储程序运行时的各种对象信息和线程栈帧数据。\n+ 执行引擎，主要内存垃圾回收和运行时代码优化。\n\n本系列将会从实际应用、面试需要、饭后吹逼等三个角度分别讲解这三大主要模块。同时给自己立个flag到2020年6月能完成本系列文章的全部写作。\n\n> 有任何不懂或者质疑的地方，都欢迎大家积极留言讨论，留言必回，一起学习进步。\n\n\n\n<!-- \n参考文献 https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html\n-->","source":"_posts/java/jvm/post0/post0.md","raw":"---\ntitle: 00开篇\ndate: 2019-11-09 16:36:13\ncategories:\n    - jvm\n    - java虚拟机，说点不一样的\ntags:\n---\n\n有别于C/C++语言，java虚拟机解放了java程序员，使我们在开发过程中不必负责每个对象的出生和死亡，我们只管用new关键字创建对象，使用对象，对于不在使用的对象所占的内存空间的回收，完全交给java虚拟机来负责。在程序内存管理领域，java虚拟机即让我们避免成为分配对象内存，回收对象内存这样单调工作的奴隶；也让我们丧失了成为掌握对象内存空间管理“生杀大权”的皇帝，内存管理对我们越发的陌生和透明，一旦有内存泄露或者溢出以及涉及到虚拟机方面的性能调优，都会让我们手足无措。《也谈java虚拟机，说点不一样的》系列文章，力求用简单，生动，具体的讲述风格讲解java虚拟机的运作机制，让广大java开发人员得以管窥一二，在实际工作中、在面试找工作时、在饭后和同事吹逼时，都能得心应手，从容应对。鉴于java虚拟机知识体系的庞杂和深邃以及本员能力的限制，系列文章中难免有错误和不足，希望大家多多包涵。\n\njava虚拟机是一个抽象的计算机。对于程序开发人员来说，我们只需要编写好我们的程序，让不同平台上的java虚拟机完成java代码到不同操作系统计算机指令的转化，通过这种方式java语言实现了其夸平台特性。虽然名为java虚拟机，但是它并不是和java语言强绑定的，java虚拟机只能识别有特定语法格式的class文件，而所有能编译为class文件的语言，都可以在java虚拟机上运行，java虚拟机不是“java语言的虚拟机”而是“多语言的虚拟机”。\n\n在java虚拟机的发展历史上，曾经有很多的优秀的虚拟机实现。如随着jdk1.0一起发布的Classic VM，号称速度最快的JRockit VM，以及专精Windows平台的Microsoft JVM等。但我们普通程序员用的最多的也是“血统最纯正”虚拟机实现就是Sun公司发布的HotSpot VM，这个系列也以HotSpot虚拟机为蓝本进行讲述的。\n\n\nHotSpot虚拟机的组件结构如下：\n\n![HotSpot虚拟机组件结构](https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/jvm/post0/HotSpot-architecture.jpg) \n\nHotSpot虚拟机有三大主要模块：\n\n+ 类加载子系统，主要用来加载class文件，从中获取类信息。\n+ 虚拟机运行时数据区，主要存储程序运行时的各种对象信息和线程栈帧数据。\n+ 执行引擎，主要内存垃圾回收和运行时代码优化。\n\n本系列将会从实际应用、面试需要、饭后吹逼等三个角度分别讲解这三大主要模块。同时给自己立个flag到2020年6月能完成本系列文章的全部写作。\n\n> 有任何不懂或者质疑的地方，都欢迎大家积极留言讨论，留言必回，一起学习进步。\n\n\n\n<!-- \n参考文献 https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html\n-->","slug":"java/jvm/post0/post0","published":1,"updated":"2019-11-20T12:46:47.929Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5z3rh420002zgie89e7cr4r","content":"<p>有别于C/C++语言，java虚拟机解放了java程序员，使我们在开发过程中不必负责每个对象的出生和死亡，我们只管用new关键字创建对象，使用对象，对于不在使用的对象所占的内存空间的回收，完全交给java虚拟机来负责。在程序内存管理领域，java虚拟机即让我们避免成为分配对象内存，回收对象内存这样单调工作的奴隶；也让我们丧失了成为掌握对象内存空间管理“生杀大权”的皇帝，内存管理对我们越发的陌生和透明，一旦有内存泄露或者溢出以及涉及到虚拟机方面的性能调优，都会让我们手足无措。《也谈java虚拟机，说点不一样的》系列文章，力求用简单，生动，具体的讲述风格讲解java虚拟机的运作机制，让广大java开发人员得以管窥一二，在实际工作中、在面试找工作时、在饭后和同事吹逼时，都能得心应手，从容应对。鉴于java虚拟机知识体系的庞杂和深邃以及本员能力的限制，系列文章中难免有错误和不足，希望大家多多包涵。</p>\n<p>java虚拟机是一个抽象的计算机。对于程序开发人员来说，我们只需要编写好我们的程序，让不同平台上的java虚拟机完成java代码到不同操作系统计算机指令的转化，通过这种方式java语言实现了其夸平台特性。虽然名为java虚拟机，但是它并不是和java语言强绑定的，java虚拟机只能识别有特定语法格式的class文件，而所有能编译为class文件的语言，都可以在java虚拟机上运行，java虚拟机不是“java语言的虚拟机”而是“多语言的虚拟机”。</p>\n<p>在java虚拟机的发展历史上，曾经有很多的优秀的虚拟机实现。如随着jdk1.0一起发布的Classic VM，号称速度最快的JRockit VM，以及专精Windows平台的Microsoft JVM等。但我们普通程序员用的最多的也是“血统最纯正”虚拟机实现就是Sun公司发布的HotSpot VM，这个系列也以HotSpot虚拟机为蓝本进行讲述的。</p>\n<p>HotSpot虚拟机的组件结构如下：</p>\n<p><img src=\"https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/jvm/post0/HotSpot-architecture.jpg\" alt=\"HotSpot虚拟机组件结构\"> </p>\n<p>HotSpot虚拟机有三大主要模块：</p>\n<ul>\n<li>类加载子系统，主要用来加载class文件，从中获取类信息。</li>\n<li>虚拟机运行时数据区，主要存储程序运行时的各种对象信息和线程栈帧数据。</li>\n<li>执行引擎，主要内存垃圾回收和运行时代码优化。</li>\n</ul>\n<p>本系列将会从实际应用、面试需要、饭后吹逼等三个角度分别讲解这三大主要模块。同时给自己立个flag到2020年6月能完成本系列文章的全部写作。</p>\n<blockquote>\n<p>有任何不懂或者质疑的地方，都欢迎大家积极留言讨论，留言必回，一起学习进步。</p>\n</blockquote>\n<!-- \n参考文献 https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html\n-->","site":{"data":{}},"excerpt":"","more":"<p>有别于C/C++语言，java虚拟机解放了java程序员，使我们在开发过程中不必负责每个对象的出生和死亡，我们只管用new关键字创建对象，使用对象，对于不在使用的对象所占的内存空间的回收，完全交给java虚拟机来负责。在程序内存管理领域，java虚拟机即让我们避免成为分配对象内存，回收对象内存这样单调工作的奴隶；也让我们丧失了成为掌握对象内存空间管理“生杀大权”的皇帝，内存管理对我们越发的陌生和透明，一旦有内存泄露或者溢出以及涉及到虚拟机方面的性能调优，都会让我们手足无措。《也谈java虚拟机，说点不一样的》系列文章，力求用简单，生动，具体的讲述风格讲解java虚拟机的运作机制，让广大java开发人员得以管窥一二，在实际工作中、在面试找工作时、在饭后和同事吹逼时，都能得心应手，从容应对。鉴于java虚拟机知识体系的庞杂和深邃以及本员能力的限制，系列文章中难免有错误和不足，希望大家多多包涵。</p>\n<p>java虚拟机是一个抽象的计算机。对于程序开发人员来说，我们只需要编写好我们的程序，让不同平台上的java虚拟机完成java代码到不同操作系统计算机指令的转化，通过这种方式java语言实现了其夸平台特性。虽然名为java虚拟机，但是它并不是和java语言强绑定的，java虚拟机只能识别有特定语法格式的class文件，而所有能编译为class文件的语言，都可以在java虚拟机上运行，java虚拟机不是“java语言的虚拟机”而是“多语言的虚拟机”。</p>\n<p>在java虚拟机的发展历史上，曾经有很多的优秀的虚拟机实现。如随着jdk1.0一起发布的Classic VM，号称速度最快的JRockit VM，以及专精Windows平台的Microsoft JVM等。但我们普通程序员用的最多的也是“血统最纯正”虚拟机实现就是Sun公司发布的HotSpot VM，这个系列也以HotSpot虚拟机为蓝本进行讲述的。</p>\n<p>HotSpot虚拟机的组件结构如下：</p>\n<p><img src=\"https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/jvm/post0/HotSpot-architecture.jpg\" alt=\"HotSpot虚拟机组件结构\"> </p>\n<p>HotSpot虚拟机有三大主要模块：</p>\n<ul>\n<li>类加载子系统，主要用来加载class文件，从中获取类信息。</li>\n<li>虚拟机运行时数据区，主要存储程序运行时的各种对象信息和线程栈帧数据。</li>\n<li>执行引擎，主要内存垃圾回收和运行时代码优化。</li>\n</ul>\n<p>本系列将会从实际应用、面试需要、饭后吹逼等三个角度分别讲解这三大主要模块。同时给自己立个flag到2020年6月能完成本系列文章的全部写作。</p>\n<blockquote>\n<p>有任何不懂或者质疑的地方，都欢迎大家积极留言讨论，留言必回，一起学习进步。</p>\n</blockquote>\n<!-- \n参考文献 https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html\n-->"},{"title":"01最全面的jvm运行时数据区讲解","date":"2019-11-09T08:36:13.000Z","_content":"\n# 最全面的jvm运行时数据区讲解\n\n\n记得有位大佬曾经说过这样一句话：\n> 如欲征服java，必须征服java虚拟机，如欲征服java虚拟机，需先征服java虚拟机内存模型。\n\njava虚拟机内存，是java虚拟机进行对象内存空间分配、垃圾回收的活动室，只有先了解java虚拟机内存才能在此基础上进一步了解对象内存分配、垃圾回收等活动。有别于真实物理机硬盘、主存、缓存、寄存器的存储模型，java虚拟机内存模型按照其存储模块负责的数据类型将其划分为如下图所示的模型：\n\n![java虚拟机内存模型](https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/jvm/post1/jvm_memory_model.png)\n                    \n\n## 堆\n堆是各个线程共享的内存区域，是java对象内存分配和垃圾回收的主战场，几乎所有的对象都是在堆中创建的。根据*Java虚拟机规范（Java Virtual Machine Specification）* 的规则，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。如果在堆中没有内存空间完成Java对象的内存分配时，将会抛出OutOfMemoryError（一下简称OOM）。\n\n关于堆的最常见虚拟机参数：\n+ -Xms ：表示虚拟机堆的最小值，如 -Xms10M 表示堆的最小值为10MB\n+ -Xmx ：表示虚拟机堆的最大值，如果 -Xmx100M 表示堆的最大值为100MB\n\n\n```\n/**\n * 设置虚拟机参数为：-Xms5M -Xmx5M\n */\npublic class HeapOOM {\n    public static void main(String[] args) {\n        ArrayList<Byte[]> bytes = new ArrayList<>();\n        for (; ; ) {\n            Byte[] _1M = new Byte[1024 * 1024];\n            bytes.add(_1M);\n        }\n\n    }\n}\n```\n\n执行结果:\n\n```\nException in thread \"main\" java.lang.OutOfMemoryError: Java heap space\n\tat jvm.post1.HeapOOM.main(HeapOOM.java:15)\n```\n\n“Java heap space”类型的OOM表示堆中没有可用的内存空间，具体到本例子中就是在大小为5M的堆中没有可用空间分配给大小为1M的数组对象。再来看一个例子：\n\n```\n/**\n * @createtime 2019/11/2\n * 虚拟机参数 -Xms5M -Xmx5M \n*/ \npublic class HeapOOM1 {\n    public static void main(String[] args) {\n        ArrayList<Object> heapOOM1s = new ArrayList<>();\n        for (; ; ) {\n            heapOOM1s.add(new Object());\n        }\n    }\n}\n```\n\n执行结果:\n\n```\nException in thread \"main\" java.lang.OutOfMemoryError: GC overhead limit exceeded\n\tat jvm.post1.HeapOOM1.main(HeapOOM1.java:14)\n```\n\n“GC overhead limit exceeded” 类型的OOM是在jdk6后引入的一种新的错误类型。发生错误的原因是虚拟机用了大量的时间进行GC但是只释放了较小的空间，这是虚拟机的一种保护机制。具体到本例子中就是虚拟机在GC时没有能回收内存空间，浪费了时间却没有收获，所以就抛出了这个错误。可以用 *-XX:-UseGCOverheadLimit*参数禁用这个检查，但解决不了内存问题，只是把错误的信息延后，替换成 java.lang.OutOfMemoryError: Java heap space错误。\n\n## 方法区\n方法区和堆一样，也是各个线程共享的内存区域，它用来存储已经被虚拟机加载的类信息、常量池、静态变量等。方法区是jdk5到jdk8变化较大的java虚拟机内存区域。在jdk5和jdk6时，常量池是存在方法区的：\n\n![jdk5和jdk6](https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/jvm/post1/jvm_memory_model_1.5.png)\n\n\n而从jdk7及其以后的版本，常量池被放到了堆里面：\n\n![jdk7](https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/jvm/post1/jvm_memory_model_1.7.png)\n\n常量池就是java语言系统级别的缓存，目的是让程序在运行过程中速度更快，更节省内存空间，java的8种基本数据类型外加String类型，共9种类型都有对应的常量池。这些类型的对象不可能全都放到常量池中存储，因此不同的类型有不同的存储策略，具体到String类型的对象来说，有如下三条规则：\n\n+ 用双引号创建的对象放在常量池中，如 \"Hello\"，\"Jvm\"这种。\n+ 用双引号创建的对象相加产生的对象放在常量池，如 *String s = \"Hello\" + \"Jvm\";*，这里的s对象就是放在常量池中的。\n+ 调用String对象的intern方法会返回一个存放在常量池中的String对象,且两个对象内容相同。\n\n再回到本篇的主题上，因为常量池位置的变化，在不同的jdk版本下，下面代码的执行结果是不一样的：\n\n```\npublic class ConstantsPool {\n    public static void main(String[] args) {\n\n        String s = new String(\"Hello\") + new String(\"Jvm\"); //1\n        String s1 = s.intern();  //2\n        System.out.println(s == s1); //jdk5和jdk6中返回false，jdk7及其以上版本返回true。\n    }\n}\n\n```\n\n\n\n在jdk7之前，程序在执行//2处代码之前常量池中没有\"HelloJvm\"这个字符串常量，//2处代码执行时，程序会在常量池中创建一个\"HelloJvm\"的字符串对象s1并返回，而常量池是在方法区的。那一个在堆中的s对象和方法区中的s1对象比较地址是否相同，当然会得到false。\n在jdk7及其以后的版本，程序在执行//2出代码时，发现常量池中同样没有\"HelloJvm\"这个对象，但因为常量池已经迁移到堆中，常量池不需要存储一个对象了，程序只是简单的把s这个对象的引用在常量池中存储了，此时s和s1指向的是同一个对象，结果当然是true。\n\n上面简单介绍了jdk7中常量池的变化，而在jdk8中方法整个方法区被放到了物理机的本地内存,同时也更名为元空间（MetaSpace）：\n\n![jdk8](https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/jvm/post1/jvm_memory_model_1.8.png)\n\n\njdk8及其以后的版本，元空间直接使用物理机的本地内存，在不加限制的情况下其最大值为本地内存的最大可用值。考虑到物理机上可能部署其它的应用服务，通常会给元空间加一个大小限制。\n\n关于元空间最常见的虚拟机参数是：\n+ -XX:MetaspaceSize : 表示虚拟机元空间发生MetadataGC时的初始阈值,如 -XX:MetaspaceSize=10M 表示元空间在第一次到大10M时，会发生一次MetadataGC。\n+ -XX:MaxMetaspaceSize ： 表示虚拟机元空间的最大值为MaxMetaspaceSize，如 -XX:MaxMetaspaceSize=15M 表示元空间的最大值为15M，再大就会发生OOM异常。\n\n关于元空间的的内存溢出模拟，我们需要借助CGLib来动态的创建类，先引入如下maven依赖：\n\n```\n<dependency>\n    <groupId>cglib</groupId>\n    <artifactId>cglib-nodep</artifactId>\n    <version>3.3.0</version>\n</dependency>\n\n```\n\n具体代码如下：\n\n```\n/**\n * 虚拟机参数 -XX:MaxMetaspaceSize=10M \n * @description 元空间内存溢出\n */\npublic class MetaSpaceOOM {\n    public static void main(String[] args) {\n        BeanGenerator beanGenerator = new BeanGenerator();\n        List<Class> classes = new ArrayList<>();\n        for (int i=0; i<1000000000L;i++ ) {\n\n            beanGenerator.addProperty(\"id\"+i, Integer.class);\n            Object aClass = beanGenerator.createClass();\n            classes.add((Class) aClass);\n\n        }\n    }\n}\n```\n\n 执行结果为：\n\n```aidl\nException in thread \"main\" java.lang.IllegalStateException: Unable to load cache item\n\tat net.sf.cglib.core.internal.LoadingCache.createEntry(LoadingCache.java:79)\n\tat net.sf.cglib.core.internal.LoadingCache.get(LoadingCache.java:34)\n\tat net.sf.cglib.core.AbstractClassGenerator$ClassLoaderData.get(AbstractClassGenerator.java:119)\n\tat net.sf.cglib.core.AbstractClassGenerator.create(AbstractClassGenerator.java:294)\n\tat net.sf.cglib.beans.BeanGenerator.createHelper(BeanGenerator.java:94)\n\tat net.sf.cglib.beans.BeanGenerator.createClass(BeanGenerator.java:85)\n\tat jvm.post1.MetaSpaceOOM.main(MetaSpaceOOM.java:19)\nCaused by: java.lang.OutOfMemoryError: Metaspace\n\tat net.sf.cglib.core.AbstractClassGenerator.generate(AbstractClassGenerator.java:348)\n\tat net.sf.cglib.core.AbstractClassGenerator$ClassLoaderData$3.apply(AbstractClassGenerator.java:96)\n\tat net.sf.cglib.core.AbstractClassGenerator$ClassLoaderData$3.apply(AbstractClassGenerator.java:94)\n\tat net.sf.cglib.core.internal.LoadingCache$2.call(LoadingCache.java:54)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat net.sf.cglib.core.internal.LoadingCache.createEntry(LoadingCache.java:61)\n\t... 6 more\n```\n\n可以看到，引起IllegalStateException异常的正是因为\"Metaspace\"类型的OOM错误。具体原因为BeanGenerator对象通过createClass方法不断创建新的类，导致最大内存为10MB的元空间没办法存储类的信息而抛出异常。\n\n## 虚拟机栈和本地方法栈\n\n虚拟机栈和本地方法栈，都是线程私有的，主要用来存储在线程运行过程中的局部变量、操作数栈、方法出入口等信息，这些信息是以栈帧的形式存储的，虚拟机栈和本地方法栈的区别就是一个存储java方法运行时的栈帧数据一个存储本地方法（native 关键字修饰的方法）运行时的栈帧数据。由于都是存储栈帧数据，两种栈的区别不是很大，甚至在HotSpot虚拟机中，直接把这两个合二为一，所以本小节把这两种栈合起来说。java程序在运行时的栈数据结构如下图：\n\n![运行时栈结构](https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/jvm/post1/stack-model.jpg)  \n\n\n在介绍堆时，我们曾说过几乎所有的对象都是在堆中创建的，这几乎中的特例就来自于栈，对象是可以在栈上创建，我们称为栈上分配。\n\n```\n\n/**\n * 执行栈上分配的虚拟机参数  -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -Xmx10M\n * 不执行栈上分配的虚拟机参数  -XX:-DoEscapeAnalysis -XX:+EliminateAllocations -Xmx10M\n * \n * 参数说明：\n * DoEscapeAnalysis  ： 逃逸分析，对于本例来说逃逸分析可以判断出//1处创建的对象是否会被本方法外的方法获取到。\n * EliminateAllocations ： 标量替换，对于本例来说，在逃逸分析的帮助下发现//1出的User对象不会逃逸出方法allo，那么消除User对象的堆内存分配，把它的字段改为一个个独立的局部变量（本例中是int类型的标量）存储在线程的栈中。\n * 要模拟栈上分配，需要逃逸分析和标量替换两个功能都是开启的。\n * @description 栈上分配\n */\npublic class StackAllocation {\n    static class User{\n        int i;\n    }\n\n    public static void allo() {\n        User user = new User(); //1\n        user.i = 4;\n    }\n\n    public static void main(String[] args) {\n        long startTime = System.currentTimeMillis();\n        for (int i = 0; i < 100000000L; i++) {\n            allo();\n        }\n        long endTime = System.currentTimeMillis();\n        System.out.println(endTime - startTime);\n    }\n}\n\n```\n\n用不同的虚拟机参数执行上面的代码时，会发现同样执行1亿次方法调用，栈上分配的执行时间明显比非栈上分配的执行时间短。简单的解释就是1亿个的User对象不是被分配在堆上，这样就避免了频繁的GC，对性能自然有很大提升。\n\n与栈相关的虚拟机参数主要有：\n+ -Xss : 设置java线程栈的大小，如 -Xss100k 表示每个java线程栈的大小为100k。\n\n线程栈是用来存方法的栈帧的。线程栈越大其能调用的方法深度越大，运行如下代码可以印证此观点：\n\n```\n\n/**\n * 虚拟机参数 -Xss1000K\n * @description 模拟栈内存溢出\n */\npublic class StackOverFlowOOM {\n    private static int num = 0;\n\n    public static void loop(){\n        num++;\n        loop();\n    }\n\n    public static void main(String[] args) {\n        try {\n            loop();\n        } catch (Throwable e) {\n            e.printStackTrace();\n            System.out.println(num);\n        }\n    }\n}\n\n```\n\n当Xss的值越大时，程序中的num变量在栈溢出异常时的值越大。jdk8中如果不指定Xss参数的大小，那么其默认值为1MB，这也从内存角度印证线程是一种昂贵的资源，即使简单的创建一个线程而不分配给其处理任务，其也要占用一些内存空间。\n\n\n## 程序计数器\n\n程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器，因为操作系统会分配给各个线程一些时间片来运行，当时间片用完后，就需要有程序计数器记录线程执行的位置，用来在线程重新获得时间片时能恢复到原来的执行位置。从程序计数器的用途得知，程序程序计数器也是线程私有的，而且也是唯一一个不会有OOM异常的虚拟机内存区域。\n\n\n\n## 篇尾小节\n\n本篇主要简绍了java虚拟机在运行时的各个内存区域，简单介绍了它们的作用和内存溢出的方式。\n\n\n\n\n> 有任何不懂或者质疑的地方，都欢迎大家积极留言讨论，留言必回，一起学习进步。\n\n\n\n<!--\n参考文献 ：\nhttp://lovestblog.cn/blog/2016/10/29/metaspace/ \n-->","source":"_posts/java/jvm/post1/post1.md","raw":"---\ntitle: 01最全面的jvm运行时数据区讲解\ndate: 2019-11-09 16:36:13\ncategories:\n    - jvm\n    - java虚拟机，说点不一样的\ntags:\n---\n\n# 最全面的jvm运行时数据区讲解\n\n\n记得有位大佬曾经说过这样一句话：\n> 如欲征服java，必须征服java虚拟机，如欲征服java虚拟机，需先征服java虚拟机内存模型。\n\njava虚拟机内存，是java虚拟机进行对象内存空间分配、垃圾回收的活动室，只有先了解java虚拟机内存才能在此基础上进一步了解对象内存分配、垃圾回收等活动。有别于真实物理机硬盘、主存、缓存、寄存器的存储模型，java虚拟机内存模型按照其存储模块负责的数据类型将其划分为如下图所示的模型：\n\n![java虚拟机内存模型](https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/jvm/post1/jvm_memory_model.png)\n                    \n\n## 堆\n堆是各个线程共享的内存区域，是java对象内存分配和垃圾回收的主战场，几乎所有的对象都是在堆中创建的。根据*Java虚拟机规范（Java Virtual Machine Specification）* 的规则，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。如果在堆中没有内存空间完成Java对象的内存分配时，将会抛出OutOfMemoryError（一下简称OOM）。\n\n关于堆的最常见虚拟机参数：\n+ -Xms ：表示虚拟机堆的最小值，如 -Xms10M 表示堆的最小值为10MB\n+ -Xmx ：表示虚拟机堆的最大值，如果 -Xmx100M 表示堆的最大值为100MB\n\n\n```\n/**\n * 设置虚拟机参数为：-Xms5M -Xmx5M\n */\npublic class HeapOOM {\n    public static void main(String[] args) {\n        ArrayList<Byte[]> bytes = new ArrayList<>();\n        for (; ; ) {\n            Byte[] _1M = new Byte[1024 * 1024];\n            bytes.add(_1M);\n        }\n\n    }\n}\n```\n\n执行结果:\n\n```\nException in thread \"main\" java.lang.OutOfMemoryError: Java heap space\n\tat jvm.post1.HeapOOM.main(HeapOOM.java:15)\n```\n\n“Java heap space”类型的OOM表示堆中没有可用的内存空间，具体到本例子中就是在大小为5M的堆中没有可用空间分配给大小为1M的数组对象。再来看一个例子：\n\n```\n/**\n * @createtime 2019/11/2\n * 虚拟机参数 -Xms5M -Xmx5M \n*/ \npublic class HeapOOM1 {\n    public static void main(String[] args) {\n        ArrayList<Object> heapOOM1s = new ArrayList<>();\n        for (; ; ) {\n            heapOOM1s.add(new Object());\n        }\n    }\n}\n```\n\n执行结果:\n\n```\nException in thread \"main\" java.lang.OutOfMemoryError: GC overhead limit exceeded\n\tat jvm.post1.HeapOOM1.main(HeapOOM1.java:14)\n```\n\n“GC overhead limit exceeded” 类型的OOM是在jdk6后引入的一种新的错误类型。发生错误的原因是虚拟机用了大量的时间进行GC但是只释放了较小的空间，这是虚拟机的一种保护机制。具体到本例子中就是虚拟机在GC时没有能回收内存空间，浪费了时间却没有收获，所以就抛出了这个错误。可以用 *-XX:-UseGCOverheadLimit*参数禁用这个检查，但解决不了内存问题，只是把错误的信息延后，替换成 java.lang.OutOfMemoryError: Java heap space错误。\n\n## 方法区\n方法区和堆一样，也是各个线程共享的内存区域，它用来存储已经被虚拟机加载的类信息、常量池、静态变量等。方法区是jdk5到jdk8变化较大的java虚拟机内存区域。在jdk5和jdk6时，常量池是存在方法区的：\n\n![jdk5和jdk6](https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/jvm/post1/jvm_memory_model_1.5.png)\n\n\n而从jdk7及其以后的版本，常量池被放到了堆里面：\n\n![jdk7](https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/jvm/post1/jvm_memory_model_1.7.png)\n\n常量池就是java语言系统级别的缓存，目的是让程序在运行过程中速度更快，更节省内存空间，java的8种基本数据类型外加String类型，共9种类型都有对应的常量池。这些类型的对象不可能全都放到常量池中存储，因此不同的类型有不同的存储策略，具体到String类型的对象来说，有如下三条规则：\n\n+ 用双引号创建的对象放在常量池中，如 \"Hello\"，\"Jvm\"这种。\n+ 用双引号创建的对象相加产生的对象放在常量池，如 *String s = \"Hello\" + \"Jvm\";*，这里的s对象就是放在常量池中的。\n+ 调用String对象的intern方法会返回一个存放在常量池中的String对象,且两个对象内容相同。\n\n再回到本篇的主题上，因为常量池位置的变化，在不同的jdk版本下，下面代码的执行结果是不一样的：\n\n```\npublic class ConstantsPool {\n    public static void main(String[] args) {\n\n        String s = new String(\"Hello\") + new String(\"Jvm\"); //1\n        String s1 = s.intern();  //2\n        System.out.println(s == s1); //jdk5和jdk6中返回false，jdk7及其以上版本返回true。\n    }\n}\n\n```\n\n\n\n在jdk7之前，程序在执行//2处代码之前常量池中没有\"HelloJvm\"这个字符串常量，//2处代码执行时，程序会在常量池中创建一个\"HelloJvm\"的字符串对象s1并返回，而常量池是在方法区的。那一个在堆中的s对象和方法区中的s1对象比较地址是否相同，当然会得到false。\n在jdk7及其以后的版本，程序在执行//2出代码时，发现常量池中同样没有\"HelloJvm\"这个对象，但因为常量池已经迁移到堆中，常量池不需要存储一个对象了，程序只是简单的把s这个对象的引用在常量池中存储了，此时s和s1指向的是同一个对象，结果当然是true。\n\n上面简单介绍了jdk7中常量池的变化，而在jdk8中方法整个方法区被放到了物理机的本地内存,同时也更名为元空间（MetaSpace）：\n\n![jdk8](https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/jvm/post1/jvm_memory_model_1.8.png)\n\n\njdk8及其以后的版本，元空间直接使用物理机的本地内存，在不加限制的情况下其最大值为本地内存的最大可用值。考虑到物理机上可能部署其它的应用服务，通常会给元空间加一个大小限制。\n\n关于元空间最常见的虚拟机参数是：\n+ -XX:MetaspaceSize : 表示虚拟机元空间发生MetadataGC时的初始阈值,如 -XX:MetaspaceSize=10M 表示元空间在第一次到大10M时，会发生一次MetadataGC。\n+ -XX:MaxMetaspaceSize ： 表示虚拟机元空间的最大值为MaxMetaspaceSize，如 -XX:MaxMetaspaceSize=15M 表示元空间的最大值为15M，再大就会发生OOM异常。\n\n关于元空间的的内存溢出模拟，我们需要借助CGLib来动态的创建类，先引入如下maven依赖：\n\n```\n<dependency>\n    <groupId>cglib</groupId>\n    <artifactId>cglib-nodep</artifactId>\n    <version>3.3.0</version>\n</dependency>\n\n```\n\n具体代码如下：\n\n```\n/**\n * 虚拟机参数 -XX:MaxMetaspaceSize=10M \n * @description 元空间内存溢出\n */\npublic class MetaSpaceOOM {\n    public static void main(String[] args) {\n        BeanGenerator beanGenerator = new BeanGenerator();\n        List<Class> classes = new ArrayList<>();\n        for (int i=0; i<1000000000L;i++ ) {\n\n            beanGenerator.addProperty(\"id\"+i, Integer.class);\n            Object aClass = beanGenerator.createClass();\n            classes.add((Class) aClass);\n\n        }\n    }\n}\n```\n\n 执行结果为：\n\n```aidl\nException in thread \"main\" java.lang.IllegalStateException: Unable to load cache item\n\tat net.sf.cglib.core.internal.LoadingCache.createEntry(LoadingCache.java:79)\n\tat net.sf.cglib.core.internal.LoadingCache.get(LoadingCache.java:34)\n\tat net.sf.cglib.core.AbstractClassGenerator$ClassLoaderData.get(AbstractClassGenerator.java:119)\n\tat net.sf.cglib.core.AbstractClassGenerator.create(AbstractClassGenerator.java:294)\n\tat net.sf.cglib.beans.BeanGenerator.createHelper(BeanGenerator.java:94)\n\tat net.sf.cglib.beans.BeanGenerator.createClass(BeanGenerator.java:85)\n\tat jvm.post1.MetaSpaceOOM.main(MetaSpaceOOM.java:19)\nCaused by: java.lang.OutOfMemoryError: Metaspace\n\tat net.sf.cglib.core.AbstractClassGenerator.generate(AbstractClassGenerator.java:348)\n\tat net.sf.cglib.core.AbstractClassGenerator$ClassLoaderData$3.apply(AbstractClassGenerator.java:96)\n\tat net.sf.cglib.core.AbstractClassGenerator$ClassLoaderData$3.apply(AbstractClassGenerator.java:94)\n\tat net.sf.cglib.core.internal.LoadingCache$2.call(LoadingCache.java:54)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat net.sf.cglib.core.internal.LoadingCache.createEntry(LoadingCache.java:61)\n\t... 6 more\n```\n\n可以看到，引起IllegalStateException异常的正是因为\"Metaspace\"类型的OOM错误。具体原因为BeanGenerator对象通过createClass方法不断创建新的类，导致最大内存为10MB的元空间没办法存储类的信息而抛出异常。\n\n## 虚拟机栈和本地方法栈\n\n虚拟机栈和本地方法栈，都是线程私有的，主要用来存储在线程运行过程中的局部变量、操作数栈、方法出入口等信息，这些信息是以栈帧的形式存储的，虚拟机栈和本地方法栈的区别就是一个存储java方法运行时的栈帧数据一个存储本地方法（native 关键字修饰的方法）运行时的栈帧数据。由于都是存储栈帧数据，两种栈的区别不是很大，甚至在HotSpot虚拟机中，直接把这两个合二为一，所以本小节把这两种栈合起来说。java程序在运行时的栈数据结构如下图：\n\n![运行时栈结构](https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/jvm/post1/stack-model.jpg)  \n\n\n在介绍堆时，我们曾说过几乎所有的对象都是在堆中创建的，这几乎中的特例就来自于栈，对象是可以在栈上创建，我们称为栈上分配。\n\n```\n\n/**\n * 执行栈上分配的虚拟机参数  -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -Xmx10M\n * 不执行栈上分配的虚拟机参数  -XX:-DoEscapeAnalysis -XX:+EliminateAllocations -Xmx10M\n * \n * 参数说明：\n * DoEscapeAnalysis  ： 逃逸分析，对于本例来说逃逸分析可以判断出//1处创建的对象是否会被本方法外的方法获取到。\n * EliminateAllocations ： 标量替换，对于本例来说，在逃逸分析的帮助下发现//1出的User对象不会逃逸出方法allo，那么消除User对象的堆内存分配，把它的字段改为一个个独立的局部变量（本例中是int类型的标量）存储在线程的栈中。\n * 要模拟栈上分配，需要逃逸分析和标量替换两个功能都是开启的。\n * @description 栈上分配\n */\npublic class StackAllocation {\n    static class User{\n        int i;\n    }\n\n    public static void allo() {\n        User user = new User(); //1\n        user.i = 4;\n    }\n\n    public static void main(String[] args) {\n        long startTime = System.currentTimeMillis();\n        for (int i = 0; i < 100000000L; i++) {\n            allo();\n        }\n        long endTime = System.currentTimeMillis();\n        System.out.println(endTime - startTime);\n    }\n}\n\n```\n\n用不同的虚拟机参数执行上面的代码时，会发现同样执行1亿次方法调用，栈上分配的执行时间明显比非栈上分配的执行时间短。简单的解释就是1亿个的User对象不是被分配在堆上，这样就避免了频繁的GC，对性能自然有很大提升。\n\n与栈相关的虚拟机参数主要有：\n+ -Xss : 设置java线程栈的大小，如 -Xss100k 表示每个java线程栈的大小为100k。\n\n线程栈是用来存方法的栈帧的。线程栈越大其能调用的方法深度越大，运行如下代码可以印证此观点：\n\n```\n\n/**\n * 虚拟机参数 -Xss1000K\n * @description 模拟栈内存溢出\n */\npublic class StackOverFlowOOM {\n    private static int num = 0;\n\n    public static void loop(){\n        num++;\n        loop();\n    }\n\n    public static void main(String[] args) {\n        try {\n            loop();\n        } catch (Throwable e) {\n            e.printStackTrace();\n            System.out.println(num);\n        }\n    }\n}\n\n```\n\n当Xss的值越大时，程序中的num变量在栈溢出异常时的值越大。jdk8中如果不指定Xss参数的大小，那么其默认值为1MB，这也从内存角度印证线程是一种昂贵的资源，即使简单的创建一个线程而不分配给其处理任务，其也要占用一些内存空间。\n\n\n## 程序计数器\n\n程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器，因为操作系统会分配给各个线程一些时间片来运行，当时间片用完后，就需要有程序计数器记录线程执行的位置，用来在线程重新获得时间片时能恢复到原来的执行位置。从程序计数器的用途得知，程序程序计数器也是线程私有的，而且也是唯一一个不会有OOM异常的虚拟机内存区域。\n\n\n\n## 篇尾小节\n\n本篇主要简绍了java虚拟机在运行时的各个内存区域，简单介绍了它们的作用和内存溢出的方式。\n\n\n\n\n> 有任何不懂或者质疑的地方，都欢迎大家积极留言讨论，留言必回，一起学习进步。\n\n\n\n<!--\n参考文献 ：\nhttp://lovestblog.cn/blog/2016/10/29/metaspace/ \n-->","slug":"java/jvm/post1/post1","published":1,"updated":"2019-11-20T12:46:47.936Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5z3rh440003zgie5r6scaqf","content":"<h1 id=\"最全面的jvm运行时数据区讲解\"><a href=\"#最全面的jvm运行时数据区讲解\" class=\"headerlink\" title=\"最全面的jvm运行时数据区讲解\"></a>最全面的jvm运行时数据区讲解</h1><p>记得有位大佬曾经说过这样一句话：</p>\n<blockquote>\n<p>如欲征服java，必须征服java虚拟机，如欲征服java虚拟机，需先征服java虚拟机内存模型。</p>\n</blockquote>\n<p>java虚拟机内存，是java虚拟机进行对象内存空间分配、垃圾回收的活动室，只有先了解java虚拟机内存才能在此基础上进一步了解对象内存分配、垃圾回收等活动。有别于真实物理机硬盘、主存、缓存、寄存器的存储模型，java虚拟机内存模型按照其存储模块负责的数据类型将其划分为如下图所示的模型：</p>\n<p><img src=\"https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/jvm/post1/jvm_memory_model.png\" alt=\"java虚拟机内存模型\"></p>\n<h2 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h2><p>堆是各个线程共享的内存区域，是java对象内存分配和垃圾回收的主战场，几乎所有的对象都是在堆中创建的。根据<em>Java虚拟机规范（Java Virtual Machine Specification）</em> 的规则，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。如果在堆中没有内存空间完成Java对象的内存分配时，将会抛出OutOfMemoryError（一下简称OOM）。</p>\n<p>关于堆的最常见虚拟机参数：</p>\n<ul>\n<li>-Xms ：表示虚拟机堆的最小值，如 -Xms10M 表示堆的最小值为10MB</li>\n<li>-Xmx ：表示虚拟机堆的最大值，如果 -Xmx100M 表示堆的最大值为100MB</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * 设置虚拟机参数为：-Xms5M -Xmx5M</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">public class HeapOOM &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        ArrayList&lt;Byte[]&gt; bytes &#x3D; new ArrayList&lt;&gt;();</span><br><span class=\"line\">        for (; ; ) &#123;</span><br><span class=\"line\">            Byte[] _1M &#x3D; new Byte[1024 * 1024];</span><br><span class=\"line\">            bytes.add(_1M);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>执行结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br><span class=\"line\">\tat jvm.post1.HeapOOM.main(HeapOOM.java:15)</span><br></pre></td></tr></table></figure>\n\n<p>“Java heap space”类型的OOM表示堆中没有可用的内存空间，具体到本例子中就是在大小为5M的堆中没有可用空间分配给大小为1M的数组对象。再来看一个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * @createtime 2019&#x2F;11&#x2F;2</span><br><span class=\"line\"> * 虚拟机参数 -Xms5M -Xmx5M </span><br><span class=\"line\">*&#x2F; </span><br><span class=\"line\">public class HeapOOM1 &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        ArrayList&lt;Object&gt; heapOOM1s &#x3D; new ArrayList&lt;&gt;();</span><br><span class=\"line\">        for (; ; ) &#123;</span><br><span class=\"line\">            heapOOM1s.add(new Object());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>执行结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: GC overhead limit exceeded</span><br><span class=\"line\">\tat jvm.post1.HeapOOM1.main(HeapOOM1.java:14)</span><br></pre></td></tr></table></figure>\n\n<p>“GC overhead limit exceeded” 类型的OOM是在jdk6后引入的一种新的错误类型。发生错误的原因是虚拟机用了大量的时间进行GC但是只释放了较小的空间，这是虚拟机的一种保护机制。具体到本例子中就是虚拟机在GC时没有能回收内存空间，浪费了时间却没有收获，所以就抛出了这个错误。可以用 <em>-XX:-UseGCOverheadLimit</em>参数禁用这个检查，但解决不了内存问题，只是把错误的信息延后，替换成 java.lang.OutOfMemoryError: Java heap space错误。</p>\n<h2 id=\"方法区\"><a href=\"#方法区\" class=\"headerlink\" title=\"方法区\"></a>方法区</h2><p>方法区和堆一样，也是各个线程共享的内存区域，它用来存储已经被虚拟机加载的类信息、常量池、静态变量等。方法区是jdk5到jdk8变化较大的java虚拟机内存区域。在jdk5和jdk6时，常量池是存在方法区的：</p>\n<p><img src=\"https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/jvm/post1/jvm_memory_model_1.5.png\" alt=\"jdk5和jdk6\"></p>\n<p>而从jdk7及其以后的版本，常量池被放到了堆里面：</p>\n<p><img src=\"https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/jvm/post1/jvm_memory_model_1.7.png\" alt=\"jdk7\"></p>\n<p>常量池就是java语言系统级别的缓存，目的是让程序在运行过程中速度更快，更节省内存空间，java的8种基本数据类型外加String类型，共9种类型都有对应的常量池。这些类型的对象不可能全都放到常量池中存储，因此不同的类型有不同的存储策略，具体到String类型的对象来说，有如下三条规则：</p>\n<ul>\n<li>用双引号创建的对象放在常量池中，如 “Hello”，”Jvm”这种。</li>\n<li>用双引号创建的对象相加产生的对象放在常量池，如 <em>String s = “Hello” + “Jvm”;</em>，这里的s对象就是放在常量池中的。</li>\n<li>调用String对象的intern方法会返回一个存放在常量池中的String对象,且两个对象内容相同。</li>\n</ul>\n<p>再回到本篇的主题上，因为常量池位置的变化，在不同的jdk版本下，下面代码的执行结果是不一样的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ConstantsPool &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        String s &#x3D; new String(&quot;Hello&quot;) + new String(&quot;Jvm&quot;); &#x2F;&#x2F;1</span><br><span class=\"line\">        String s1 &#x3D; s.intern();  &#x2F;&#x2F;2</span><br><span class=\"line\">        System.out.println(s &#x3D;&#x3D; s1); &#x2F;&#x2F;jdk5和jdk6中返回false，jdk7及其以上版本返回true。</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>在jdk7之前，程序在执行//2处代码之前常量池中没有”HelloJvm”这个字符串常量，//2处代码执行时，程序会在常量池中创建一个”HelloJvm”的字符串对象s1并返回，而常量池是在方法区的。那一个在堆中的s对象和方法区中的s1对象比较地址是否相同，当然会得到false。<br>在jdk7及其以后的版本，程序在执行//2出代码时，发现常量池中同样没有”HelloJvm”这个对象，但因为常量池已经迁移到堆中，常量池不需要存储一个对象了，程序只是简单的把s这个对象的引用在常量池中存储了，此时s和s1指向的是同一个对象，结果当然是true。</p>\n<p>上面简单介绍了jdk7中常量池的变化，而在jdk8中方法整个方法区被放到了物理机的本地内存,同时也更名为元空间（MetaSpace）：</p>\n<p><img src=\"https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/jvm/post1/jvm_memory_model_1.8.png\" alt=\"jdk8\"></p>\n<p>jdk8及其以后的版本，元空间直接使用物理机的本地内存，在不加限制的情况下其最大值为本地内存的最大可用值。考虑到物理机上可能部署其它的应用服务，通常会给元空间加一个大小限制。</p>\n<p>关于元空间最常见的虚拟机参数是：</p>\n<ul>\n<li>-XX:MetaspaceSize : 表示虚拟机元空间发生MetadataGC时的初始阈值,如 -XX:MetaspaceSize=10M 表示元空间在第一次到大10M时，会发生一次MetadataGC。</li>\n<li>-XX:MaxMetaspaceSize ： 表示虚拟机元空间的最大值为MaxMetaspaceSize，如 -XX:MaxMetaspaceSize=15M 表示元空间的最大值为15M，再大就会发生OOM异常。</li>\n</ul>\n<p>关于元空间的的内存溢出模拟，我们需要借助CGLib来动态的创建类，先引入如下maven依赖：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;cglib&lt;&#x2F;groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;cglib-nodep&lt;&#x2F;artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;3.3.0&lt;&#x2F;version&gt;</span><br><span class=\"line\">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>\n\n<p>具体代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * 虚拟机参数 -XX:MaxMetaspaceSize&#x3D;10M </span><br><span class=\"line\"> * @description 元空间内存溢出</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">public class MetaSpaceOOM &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        BeanGenerator beanGenerator &#x3D; new BeanGenerator();</span><br><span class=\"line\">        List&lt;Class&gt; classes &#x3D; new ArrayList&lt;&gt;();</span><br><span class=\"line\">        for (int i&#x3D;0; i&lt;1000000000L;i++ ) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            beanGenerator.addProperty(&quot;id&quot;+i, Integer.class);</span><br><span class=\"line\">            Object aClass &#x3D; beanGenerator.createClass();</span><br><span class=\"line\">            classes.add((Class) aClass);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> 执行结果为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Exception in thread &quot;main&quot; java.lang.IllegalStateException: Unable to load cache item</span><br><span class=\"line\">\tat net.sf.cglib.core.internal.LoadingCache.createEntry(LoadingCache.java:79)</span><br><span class=\"line\">\tat net.sf.cglib.core.internal.LoadingCache.get(LoadingCache.java:34)</span><br><span class=\"line\">\tat net.sf.cglib.core.AbstractClassGenerator$ClassLoaderData.get(AbstractClassGenerator.java:119)</span><br><span class=\"line\">\tat net.sf.cglib.core.AbstractClassGenerator.create(AbstractClassGenerator.java:294)</span><br><span class=\"line\">\tat net.sf.cglib.beans.BeanGenerator.createHelper(BeanGenerator.java:94)</span><br><span class=\"line\">\tat net.sf.cglib.beans.BeanGenerator.createClass(BeanGenerator.java:85)</span><br><span class=\"line\">\tat jvm.post1.MetaSpaceOOM.main(MetaSpaceOOM.java:19)</span><br><span class=\"line\">Caused by: java.lang.OutOfMemoryError: Metaspace</span><br><span class=\"line\">\tat net.sf.cglib.core.AbstractClassGenerator.generate(AbstractClassGenerator.java:348)</span><br><span class=\"line\">\tat net.sf.cglib.core.AbstractClassGenerator$ClassLoaderData$3.apply(AbstractClassGenerator.java:96)</span><br><span class=\"line\">\tat net.sf.cglib.core.AbstractClassGenerator$ClassLoaderData$3.apply(AbstractClassGenerator.java:94)</span><br><span class=\"line\">\tat net.sf.cglib.core.internal.LoadingCache$2.call(LoadingCache.java:54)</span><br><span class=\"line\">\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)</span><br><span class=\"line\">\tat net.sf.cglib.core.internal.LoadingCache.createEntry(LoadingCache.java:61)</span><br><span class=\"line\">\t... 6 more</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，引起IllegalStateException异常的正是因为”Metaspace”类型的OOM错误。具体原因为BeanGenerator对象通过createClass方法不断创建新的类，导致最大内存为10MB的元空间没办法存储类的信息而抛出异常。</p>\n<h2 id=\"虚拟机栈和本地方法栈\"><a href=\"#虚拟机栈和本地方法栈\" class=\"headerlink\" title=\"虚拟机栈和本地方法栈\"></a>虚拟机栈和本地方法栈</h2><p>虚拟机栈和本地方法栈，都是线程私有的，主要用来存储在线程运行过程中的局部变量、操作数栈、方法出入口等信息，这些信息是以栈帧的形式存储的，虚拟机栈和本地方法栈的区别就是一个存储java方法运行时的栈帧数据一个存储本地方法（native 关键字修饰的方法）运行时的栈帧数据。由于都是存储栈帧数据，两种栈的区别不是很大，甚至在HotSpot虚拟机中，直接把这两个合二为一，所以本小节把这两种栈合起来说。java程序在运行时的栈数据结构如下图：</p>\n<p><img src=\"https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/jvm/post1/stack-model.jpg\" alt=\"运行时栈结构\">  </p>\n<p>在介绍堆时，我们曾说过几乎所有的对象都是在堆中创建的，这几乎中的特例就来自于栈，对象是可以在栈上创建，我们称为栈上分配。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * 执行栈上分配的虚拟机参数  -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -Xmx10M</span><br><span class=\"line\"> * 不执行栈上分配的虚拟机参数  -XX:-DoEscapeAnalysis -XX:+EliminateAllocations -Xmx10M</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * 参数说明：</span><br><span class=\"line\"> * DoEscapeAnalysis  ： 逃逸分析，对于本例来说逃逸分析可以判断出&#x2F;&#x2F;1处创建的对象是否会被本方法外的方法获取到。</span><br><span class=\"line\"> * EliminateAllocations ： 标量替换，对于本例来说，在逃逸分析的帮助下发现&#x2F;&#x2F;1出的User对象不会逃逸出方法allo，那么消除User对象的堆内存分配，把它的字段改为一个个独立的局部变量（本例中是int类型的标量）存储在线程的栈中。</span><br><span class=\"line\"> * 要模拟栈上分配，需要逃逸分析和标量替换两个功能都是开启的。</span><br><span class=\"line\"> * @description 栈上分配</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">public class StackAllocation &#123;</span><br><span class=\"line\">    static class User&#123;</span><br><span class=\"line\">        int i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void allo() &#123;</span><br><span class=\"line\">        User user &#x3D; new User(); &#x2F;&#x2F;1</span><br><span class=\"line\">        user.i &#x3D; 4;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        long startTime &#x3D; System.currentTimeMillis();</span><br><span class=\"line\">        for (int i &#x3D; 0; i &lt; 100000000L; i++) &#123;</span><br><span class=\"line\">            allo();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        long endTime &#x3D; System.currentTimeMillis();</span><br><span class=\"line\">        System.out.println(endTime - startTime);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>用不同的虚拟机参数执行上面的代码时，会发现同样执行1亿次方法调用，栈上分配的执行时间明显比非栈上分配的执行时间短。简单的解释就是1亿个的User对象不是被分配在堆上，这样就避免了频繁的GC，对性能自然有很大提升。</p>\n<p>与栈相关的虚拟机参数主要有：</p>\n<ul>\n<li>-Xss : 设置java线程栈的大小，如 -Xss100k 表示每个java线程栈的大小为100k。</li>\n</ul>\n<p>线程栈是用来存方法的栈帧的。线程栈越大其能调用的方法深度越大，运行如下代码可以印证此观点：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * 虚拟机参数 -Xss1000K</span><br><span class=\"line\"> * @description 模拟栈内存溢出</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">public class StackOverFlowOOM &#123;</span><br><span class=\"line\">    private static int num &#x3D; 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void loop()&#123;</span><br><span class=\"line\">        num++;</span><br><span class=\"line\">        loop();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            loop();</span><br><span class=\"line\">        &#125; catch (Throwable e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            System.out.println(num);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当Xss的值越大时，程序中的num变量在栈溢出异常时的值越大。jdk8中如果不指定Xss参数的大小，那么其默认值为1MB，这也从内存角度印证线程是一种昂贵的资源，即使简单的创建一个线程而不分配给其处理任务，其也要占用一些内存空间。</p>\n<h2 id=\"程序计数器\"><a href=\"#程序计数器\" class=\"headerlink\" title=\"程序计数器\"></a>程序计数器</h2><p>程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器，因为操作系统会分配给各个线程一些时间片来运行，当时间片用完后，就需要有程序计数器记录线程执行的位置，用来在线程重新获得时间片时能恢复到原来的执行位置。从程序计数器的用途得知，程序程序计数器也是线程私有的，而且也是唯一一个不会有OOM异常的虚拟机内存区域。</p>\n<h2 id=\"篇尾小节\"><a href=\"#篇尾小节\" class=\"headerlink\" title=\"篇尾小节\"></a>篇尾小节</h2><p>本篇主要简绍了java虚拟机在运行时的各个内存区域，简单介绍了它们的作用和内存溢出的方式。</p>\n<blockquote>\n<p>有任何不懂或者质疑的地方，都欢迎大家积极留言讨论，留言必回，一起学习进步。</p>\n</blockquote>\n<!--\n参考文献 ：\nhttp://lovestblog.cn/blog/2016/10/29/metaspace/ \n-->","site":{"data":{}},"excerpt":"","more":"<h1 id=\"最全面的jvm运行时数据区讲解\"><a href=\"#最全面的jvm运行时数据区讲解\" class=\"headerlink\" title=\"最全面的jvm运行时数据区讲解\"></a>最全面的jvm运行时数据区讲解</h1><p>记得有位大佬曾经说过这样一句话：</p>\n<blockquote>\n<p>如欲征服java，必须征服java虚拟机，如欲征服java虚拟机，需先征服java虚拟机内存模型。</p>\n</blockquote>\n<p>java虚拟机内存，是java虚拟机进行对象内存空间分配、垃圾回收的活动室，只有先了解java虚拟机内存才能在此基础上进一步了解对象内存分配、垃圾回收等活动。有别于真实物理机硬盘、主存、缓存、寄存器的存储模型，java虚拟机内存模型按照其存储模块负责的数据类型将其划分为如下图所示的模型：</p>\n<p><img src=\"https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/jvm/post1/jvm_memory_model.png\" alt=\"java虚拟机内存模型\"></p>\n<h2 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h2><p>堆是各个线程共享的内存区域，是java对象内存分配和垃圾回收的主战场，几乎所有的对象都是在堆中创建的。根据<em>Java虚拟机规范（Java Virtual Machine Specification）</em> 的规则，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。如果在堆中没有内存空间完成Java对象的内存分配时，将会抛出OutOfMemoryError（一下简称OOM）。</p>\n<p>关于堆的最常见虚拟机参数：</p>\n<ul>\n<li>-Xms ：表示虚拟机堆的最小值，如 -Xms10M 表示堆的最小值为10MB</li>\n<li>-Xmx ：表示虚拟机堆的最大值，如果 -Xmx100M 表示堆的最大值为100MB</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * 设置虚拟机参数为：-Xms5M -Xmx5M</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">public class HeapOOM &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        ArrayList&lt;Byte[]&gt; bytes &#x3D; new ArrayList&lt;&gt;();</span><br><span class=\"line\">        for (; ; ) &#123;</span><br><span class=\"line\">            Byte[] _1M &#x3D; new Byte[1024 * 1024];</span><br><span class=\"line\">            bytes.add(_1M);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>执行结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br><span class=\"line\">\tat jvm.post1.HeapOOM.main(HeapOOM.java:15)</span><br></pre></td></tr></table></figure>\n\n<p>“Java heap space”类型的OOM表示堆中没有可用的内存空间，具体到本例子中就是在大小为5M的堆中没有可用空间分配给大小为1M的数组对象。再来看一个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * @createtime 2019&#x2F;11&#x2F;2</span><br><span class=\"line\"> * 虚拟机参数 -Xms5M -Xmx5M </span><br><span class=\"line\">*&#x2F; </span><br><span class=\"line\">public class HeapOOM1 &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        ArrayList&lt;Object&gt; heapOOM1s &#x3D; new ArrayList&lt;&gt;();</span><br><span class=\"line\">        for (; ; ) &#123;</span><br><span class=\"line\">            heapOOM1s.add(new Object());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>执行结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: GC overhead limit exceeded</span><br><span class=\"line\">\tat jvm.post1.HeapOOM1.main(HeapOOM1.java:14)</span><br></pre></td></tr></table></figure>\n\n<p>“GC overhead limit exceeded” 类型的OOM是在jdk6后引入的一种新的错误类型。发生错误的原因是虚拟机用了大量的时间进行GC但是只释放了较小的空间，这是虚拟机的一种保护机制。具体到本例子中就是虚拟机在GC时没有能回收内存空间，浪费了时间却没有收获，所以就抛出了这个错误。可以用 <em>-XX:-UseGCOverheadLimit</em>参数禁用这个检查，但解决不了内存问题，只是把错误的信息延后，替换成 java.lang.OutOfMemoryError: Java heap space错误。</p>\n<h2 id=\"方法区\"><a href=\"#方法区\" class=\"headerlink\" title=\"方法区\"></a>方法区</h2><p>方法区和堆一样，也是各个线程共享的内存区域，它用来存储已经被虚拟机加载的类信息、常量池、静态变量等。方法区是jdk5到jdk8变化较大的java虚拟机内存区域。在jdk5和jdk6时，常量池是存在方法区的：</p>\n<p><img src=\"https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/jvm/post1/jvm_memory_model_1.5.png\" alt=\"jdk5和jdk6\"></p>\n<p>而从jdk7及其以后的版本，常量池被放到了堆里面：</p>\n<p><img src=\"https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/jvm/post1/jvm_memory_model_1.7.png\" alt=\"jdk7\"></p>\n<p>常量池就是java语言系统级别的缓存，目的是让程序在运行过程中速度更快，更节省内存空间，java的8种基本数据类型外加String类型，共9种类型都有对应的常量池。这些类型的对象不可能全都放到常量池中存储，因此不同的类型有不同的存储策略，具体到String类型的对象来说，有如下三条规则：</p>\n<ul>\n<li>用双引号创建的对象放在常量池中，如 “Hello”，”Jvm”这种。</li>\n<li>用双引号创建的对象相加产生的对象放在常量池，如 <em>String s = “Hello” + “Jvm”;</em>，这里的s对象就是放在常量池中的。</li>\n<li>调用String对象的intern方法会返回一个存放在常量池中的String对象,且两个对象内容相同。</li>\n</ul>\n<p>再回到本篇的主题上，因为常量池位置的变化，在不同的jdk版本下，下面代码的执行结果是不一样的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ConstantsPool &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        String s &#x3D; new String(&quot;Hello&quot;) + new String(&quot;Jvm&quot;); &#x2F;&#x2F;1</span><br><span class=\"line\">        String s1 &#x3D; s.intern();  &#x2F;&#x2F;2</span><br><span class=\"line\">        System.out.println(s &#x3D;&#x3D; s1); &#x2F;&#x2F;jdk5和jdk6中返回false，jdk7及其以上版本返回true。</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>在jdk7之前，程序在执行//2处代码之前常量池中没有”HelloJvm”这个字符串常量，//2处代码执行时，程序会在常量池中创建一个”HelloJvm”的字符串对象s1并返回，而常量池是在方法区的。那一个在堆中的s对象和方法区中的s1对象比较地址是否相同，当然会得到false。<br>在jdk7及其以后的版本，程序在执行//2出代码时，发现常量池中同样没有”HelloJvm”这个对象，但因为常量池已经迁移到堆中，常量池不需要存储一个对象了，程序只是简单的把s这个对象的引用在常量池中存储了，此时s和s1指向的是同一个对象，结果当然是true。</p>\n<p>上面简单介绍了jdk7中常量池的变化，而在jdk8中方法整个方法区被放到了物理机的本地内存,同时也更名为元空间（MetaSpace）：</p>\n<p><img src=\"https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/jvm/post1/jvm_memory_model_1.8.png\" alt=\"jdk8\"></p>\n<p>jdk8及其以后的版本，元空间直接使用物理机的本地内存，在不加限制的情况下其最大值为本地内存的最大可用值。考虑到物理机上可能部署其它的应用服务，通常会给元空间加一个大小限制。</p>\n<p>关于元空间最常见的虚拟机参数是：</p>\n<ul>\n<li>-XX:MetaspaceSize : 表示虚拟机元空间发生MetadataGC时的初始阈值,如 -XX:MetaspaceSize=10M 表示元空间在第一次到大10M时，会发生一次MetadataGC。</li>\n<li>-XX:MaxMetaspaceSize ： 表示虚拟机元空间的最大值为MaxMetaspaceSize，如 -XX:MaxMetaspaceSize=15M 表示元空间的最大值为15M，再大就会发生OOM异常。</li>\n</ul>\n<p>关于元空间的的内存溢出模拟，我们需要借助CGLib来动态的创建类，先引入如下maven依赖：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;cglib&lt;&#x2F;groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;cglib-nodep&lt;&#x2F;artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;3.3.0&lt;&#x2F;version&gt;</span><br><span class=\"line\">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>\n\n<p>具体代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * 虚拟机参数 -XX:MaxMetaspaceSize&#x3D;10M </span><br><span class=\"line\"> * @description 元空间内存溢出</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">public class MetaSpaceOOM &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        BeanGenerator beanGenerator &#x3D; new BeanGenerator();</span><br><span class=\"line\">        List&lt;Class&gt; classes &#x3D; new ArrayList&lt;&gt;();</span><br><span class=\"line\">        for (int i&#x3D;0; i&lt;1000000000L;i++ ) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            beanGenerator.addProperty(&quot;id&quot;+i, Integer.class);</span><br><span class=\"line\">            Object aClass &#x3D; beanGenerator.createClass();</span><br><span class=\"line\">            classes.add((Class) aClass);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> 执行结果为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Exception in thread &quot;main&quot; java.lang.IllegalStateException: Unable to load cache item</span><br><span class=\"line\">\tat net.sf.cglib.core.internal.LoadingCache.createEntry(LoadingCache.java:79)</span><br><span class=\"line\">\tat net.sf.cglib.core.internal.LoadingCache.get(LoadingCache.java:34)</span><br><span class=\"line\">\tat net.sf.cglib.core.AbstractClassGenerator$ClassLoaderData.get(AbstractClassGenerator.java:119)</span><br><span class=\"line\">\tat net.sf.cglib.core.AbstractClassGenerator.create(AbstractClassGenerator.java:294)</span><br><span class=\"line\">\tat net.sf.cglib.beans.BeanGenerator.createHelper(BeanGenerator.java:94)</span><br><span class=\"line\">\tat net.sf.cglib.beans.BeanGenerator.createClass(BeanGenerator.java:85)</span><br><span class=\"line\">\tat jvm.post1.MetaSpaceOOM.main(MetaSpaceOOM.java:19)</span><br><span class=\"line\">Caused by: java.lang.OutOfMemoryError: Metaspace</span><br><span class=\"line\">\tat net.sf.cglib.core.AbstractClassGenerator.generate(AbstractClassGenerator.java:348)</span><br><span class=\"line\">\tat net.sf.cglib.core.AbstractClassGenerator$ClassLoaderData$3.apply(AbstractClassGenerator.java:96)</span><br><span class=\"line\">\tat net.sf.cglib.core.AbstractClassGenerator$ClassLoaderData$3.apply(AbstractClassGenerator.java:94)</span><br><span class=\"line\">\tat net.sf.cglib.core.internal.LoadingCache$2.call(LoadingCache.java:54)</span><br><span class=\"line\">\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)</span><br><span class=\"line\">\tat net.sf.cglib.core.internal.LoadingCache.createEntry(LoadingCache.java:61)</span><br><span class=\"line\">\t... 6 more</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，引起IllegalStateException异常的正是因为”Metaspace”类型的OOM错误。具体原因为BeanGenerator对象通过createClass方法不断创建新的类，导致最大内存为10MB的元空间没办法存储类的信息而抛出异常。</p>\n<h2 id=\"虚拟机栈和本地方法栈\"><a href=\"#虚拟机栈和本地方法栈\" class=\"headerlink\" title=\"虚拟机栈和本地方法栈\"></a>虚拟机栈和本地方法栈</h2><p>虚拟机栈和本地方法栈，都是线程私有的，主要用来存储在线程运行过程中的局部变量、操作数栈、方法出入口等信息，这些信息是以栈帧的形式存储的，虚拟机栈和本地方法栈的区别就是一个存储java方法运行时的栈帧数据一个存储本地方法（native 关键字修饰的方法）运行时的栈帧数据。由于都是存储栈帧数据，两种栈的区别不是很大，甚至在HotSpot虚拟机中，直接把这两个合二为一，所以本小节把这两种栈合起来说。java程序在运行时的栈数据结构如下图：</p>\n<p><img src=\"https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/jvm/post1/stack-model.jpg\" alt=\"运行时栈结构\">  </p>\n<p>在介绍堆时，我们曾说过几乎所有的对象都是在堆中创建的，这几乎中的特例就来自于栈，对象是可以在栈上创建，我们称为栈上分配。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * 执行栈上分配的虚拟机参数  -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -Xmx10M</span><br><span class=\"line\"> * 不执行栈上分配的虚拟机参数  -XX:-DoEscapeAnalysis -XX:+EliminateAllocations -Xmx10M</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * 参数说明：</span><br><span class=\"line\"> * DoEscapeAnalysis  ： 逃逸分析，对于本例来说逃逸分析可以判断出&#x2F;&#x2F;1处创建的对象是否会被本方法外的方法获取到。</span><br><span class=\"line\"> * EliminateAllocations ： 标量替换，对于本例来说，在逃逸分析的帮助下发现&#x2F;&#x2F;1出的User对象不会逃逸出方法allo，那么消除User对象的堆内存分配，把它的字段改为一个个独立的局部变量（本例中是int类型的标量）存储在线程的栈中。</span><br><span class=\"line\"> * 要模拟栈上分配，需要逃逸分析和标量替换两个功能都是开启的。</span><br><span class=\"line\"> * @description 栈上分配</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">public class StackAllocation &#123;</span><br><span class=\"line\">    static class User&#123;</span><br><span class=\"line\">        int i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void allo() &#123;</span><br><span class=\"line\">        User user &#x3D; new User(); &#x2F;&#x2F;1</span><br><span class=\"line\">        user.i &#x3D; 4;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        long startTime &#x3D; System.currentTimeMillis();</span><br><span class=\"line\">        for (int i &#x3D; 0; i &lt; 100000000L; i++) &#123;</span><br><span class=\"line\">            allo();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        long endTime &#x3D; System.currentTimeMillis();</span><br><span class=\"line\">        System.out.println(endTime - startTime);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>用不同的虚拟机参数执行上面的代码时，会发现同样执行1亿次方法调用，栈上分配的执行时间明显比非栈上分配的执行时间短。简单的解释就是1亿个的User对象不是被分配在堆上，这样就避免了频繁的GC，对性能自然有很大提升。</p>\n<p>与栈相关的虚拟机参数主要有：</p>\n<ul>\n<li>-Xss : 设置java线程栈的大小，如 -Xss100k 表示每个java线程栈的大小为100k。</li>\n</ul>\n<p>线程栈是用来存方法的栈帧的。线程栈越大其能调用的方法深度越大，运行如下代码可以印证此观点：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * 虚拟机参数 -Xss1000K</span><br><span class=\"line\"> * @description 模拟栈内存溢出</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">public class StackOverFlowOOM &#123;</span><br><span class=\"line\">    private static int num &#x3D; 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void loop()&#123;</span><br><span class=\"line\">        num++;</span><br><span class=\"line\">        loop();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            loop();</span><br><span class=\"line\">        &#125; catch (Throwable e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            System.out.println(num);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当Xss的值越大时，程序中的num变量在栈溢出异常时的值越大。jdk8中如果不指定Xss参数的大小，那么其默认值为1MB，这也从内存角度印证线程是一种昂贵的资源，即使简单的创建一个线程而不分配给其处理任务，其也要占用一些内存空间。</p>\n<h2 id=\"程序计数器\"><a href=\"#程序计数器\" class=\"headerlink\" title=\"程序计数器\"></a>程序计数器</h2><p>程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器，因为操作系统会分配给各个线程一些时间片来运行，当时间片用完后，就需要有程序计数器记录线程执行的位置，用来在线程重新获得时间片时能恢复到原来的执行位置。从程序计数器的用途得知，程序程序计数器也是线程私有的，而且也是唯一一个不会有OOM异常的虚拟机内存区域。</p>\n<h2 id=\"篇尾小节\"><a href=\"#篇尾小节\" class=\"headerlink\" title=\"篇尾小节\"></a>篇尾小节</h2><p>本篇主要简绍了java虚拟机在运行时的各个内存区域，简单介绍了它们的作用和内存溢出的方式。</p>\n<blockquote>\n<p>有任何不懂或者质疑的地方，都欢迎大家积极留言讨论，留言必回，一起学习进步。</p>\n</blockquote>\n<!--\n参考文献 ：\nhttp://lovestblog.cn/blog/2016/10/29/metaspace/ \n-->"}],"PostAsset":[],"PostCategory":[{"post_id":"ck5z3rh420002zgie89e7cr4r","category_id":"ck5z3rh450004zgiegjz9audd","_id":"ck5z3rh4a0008zgiebm59grr4"},{"post_id":"ck5z3rh420002zgie89e7cr4r","category_id":"ck5z3rh490006zgie37wx0czu","_id":"ck5z3rh4a0009zgieddeeghw2"},{"post_id":"ck5z3rh440003zgie5r6scaqf","category_id":"ck5z3rh450004zgiegjz9audd","_id":"ck5z3rh4a000azgieh6qk102v"},{"post_id":"ck5z3rh440003zgie5r6scaqf","category_id":"ck5z3rh490006zgie37wx0czu","_id":"ck5z3rh4a000bzgie5hpy3uq0"}],"PostTag":[],"Tag":[]}}