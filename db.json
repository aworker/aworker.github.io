{"meta":{"version":1,"warehouse":"3.0.1"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"themes/3-hexo/source/css/gitalk.css","path":"css/gitalk.css","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/mobile.styl","path":"css/mobile.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/img/alipay.jpg","path":"img/alipay.jpg","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/img/avatar.jpg","path":"img/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/img/weixin.jpg","path":"img/weixin.jpg","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/img/school-book.png","path":"img/school-book.png","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/js/iconfont.js","path":"js/iconfont.js","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/js/jquery.autocomplete.min.js","path":"js/jquery.autocomplete.min.js","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/img/article-list-background.jpeg","path":"img/article-list-background.jpeg","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/img/brown-papersq.png","path":"img/brown-papersq.png","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/js/jquery.pjax.js","path":"js/jquery.pjax.js","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.ttf","path":"css/fonts/icomoon.ttf","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.eot","path":"css/fonts/icomoon.eot","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.svg","path":"css/fonts/icomoon.svg","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.woff","path":"css/fonts/icomoon.woff","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/iconfont.svg","path":"css/fonts/iconfont.svg","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/iconfont.ttf","path":"css/fonts/iconfont.ttf","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/iconfont.eot","path":"css/fonts/iconfont.eot","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/iconfont.woff","path":"css/fonts/iconfont.woff","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/selection.json","path":"css/fonts/selection.json","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/brown-paper.styl","path":"css/hl_theme/brown-paper.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/github-gist.styl","path":"css/hl_theme/github-gist.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/atom-dark.styl","path":"css/hl_theme/atom-dark.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/atom-light.styl","path":"css/hl_theme/atom-light.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/darcula.styl","path":"css/hl_theme/darcula.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/github.styl","path":"css/hl_theme/github.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-dark.styl","path":"css/hl_theme/kimbie-dark.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-dark.styl","path":"css/hl_theme/gruvbox-dark.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-light.styl","path":"css/hl_theme/kimbie-light.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-light.styl","path":"css/hl_theme/gruvbox-light.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/railscasts.styl","path":"css/hl_theme/railscasts.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/rainbow.styl","path":"css/hl_theme/rainbow.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/school-book.styl","path":"css/hl_theme/school-book.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/sublime.styl","path":"css/hl_theme/sublime.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/sunburst.styl","path":"css/hl_theme/sunburst.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/zenbum.styl","path":"css/hl_theme/zenbum.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/js/gitment.js","path":"js/gitment.js","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/js/gitalk.js","path":"js/gitalk.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"f5367a984ed6b614412786e8434452fab61cf9e9","modified":1574254007926},{"_id":"themes/3-hexo/.gitignore","hash":"560a43fddfe4559ed1a17e7362874454519f189b","modified":1574254007940},{"_id":"themes/3-hexo/README.md","hash":"754d6f873d73f4a7faf5530fa4062e9a696a8fd4","modified":1574254007940},{"_id":"themes/3-hexo/_config.yml","hash":"55ae74e5614051cd470705d5efd50a03f9796dbd","modified":1574254007940},{"_id":"themes/3-hexo/layout/index.ejs","hash":"a5c464897e7dc9d45d03d8b61e742b1ac4173a95","modified":1574254007949},{"_id":"themes/3-hexo/layout/indexs.md","hash":"4dbd2094fff1e3146e67b33aa0326b193d0496c7","modified":1574254007949},{"_id":"themes/3-hexo/layout/post.ejs","hash":"aeda285031ba8d4e94225e82b364bcf5f79fce1d","modified":1574254007949},{"_id":"source/about/index.md","hash":"43b0945986d61f77c62ca7910a212989b5162b19","modified":1574254007939},{"_id":"source/categories/index.md","hash":"f8aea921bd9f768398e8fdbe9565830ce77da537","modified":1574254007939},{"_id":"themes/3-hexo/layout/_partial/comment.ejs","hash":"d18f94e04ef0cf7abb432a8e707ccb3abc7fe435","modified":1574254007943},{"_id":"themes/3-hexo/layout/_partial/article.ejs","hash":"d3c928954057bcebdf3fc294b2123885b08396d3","modified":1574254007942},{"_id":"themes/3-hexo/layout/_partial/article_copyright.ejs","hash":"05d3cddf5f3a53577452db4efa811bd361f7c0c4","modified":1574254007942},{"_id":"themes/3-hexo/layout/_partial/copyright.ejs","hash":"faffe25aec33936fa2ec9d8f0e34e16ef3d90c25","modified":1574254007944},{"_id":"themes/3-hexo/layout/_partial/dashang.ejs","hash":"6eab1e5fae6bd60928325d026a1bed61c43d11a9","modified":1574254007945},{"_id":"themes/3-hexo/layout/_partial/friends.ejs","hash":"558a3d4bad578819fb07729fe1b50d9b81da8b93","modified":1574254007946},{"_id":"themes/3-hexo/layout/_partial/full-toc.ejs","hash":"0e976208d79b0396eb51ca1af5016c963c6e4618","modified":1574254007946},{"_id":"themes/3-hexo/layout/_partial/header.ejs","hash":"915d5f10dd8f3dcd19cb75010e23689e8f385caf","modified":1574254007947},{"_id":"themes/3-hexo/layout/_partial/footer.ejs","hash":"311489fe2050ada8a0eaad3d0c57e5d5012f470e","modified":1574254007946},{"_id":"themes/3-hexo/layout/_partial/meta.ejs","hash":"ef387e80043b62e1925a068267f2377cac64adc7","modified":1574254007947},{"_id":"themes/3-hexo/layout/_partial/mathjax.ejs","hash":"e2be0e37f3d48e63e65a47d819bfb800b9aa3784","modified":1574254007947},{"_id":"themes/3-hexo/layout/_partial/tag.ejs","hash":"87e932476754f27424f9ec397ed66a4ab8a59ad8","modified":1574254007948},{"_id":"themes/3-hexo/layout/_partial/nav-left.ejs","hash":"c14bc1393f779dff7854089621804dceea236d82","modified":1574254007948},{"_id":"themes/3-hexo/layout/_partial/nav-right.ejs","hash":"98326675546fc6828a45e8b95250899b4ee2d821","modified":1574254007948},{"_id":"themes/3-hexo/layout/_partial/toc-ref.ejs","hash":"33f7a4bfca1bb9835ec8f0d1e73188d1f56cc8b9","modified":1574254007948},{"_id":"themes/3-hexo/source/css/gitalk.css","hash":"3dc58e9a3fd63a3144d5fe850eb55e3dc885c9fb","modified":1574254007958},{"_id":"themes/3-hexo/source/css/mobile.styl","hash":"d10bdd736aa343f38fe15cba4c81d45d3d259de4","modified":1574254007964},{"_id":"themes/3-hexo/source/css/style.styl","hash":"322abe325d5fe9ff37347bdd19e772315a8ebfed","modified":1574254007964},{"_id":"themes/3-hexo/source/img/alipay.jpg","hash":"c4a96cc935740fb2db5b5db401747401f90a74d1","modified":1574254007965},{"_id":"themes/3-hexo/source/img/avatar.jpg","hash":"a42360089bfa892d803cf5747eab359d90f337f1","modified":1574254007967},{"_id":"themes/3-hexo/source/img/weixin.jpg","hash":"bb917845578c38ad291a18186225d566b58b0fcc","modified":1574254007968},{"_id":"themes/3-hexo/source/img/school-book.png","hash":"711ec983c874e093bb89eb77afcbdf6741fa61ee","modified":1574254007967},{"_id":"themes/3-hexo/source/js/iconfont.js","hash":"3a0869ca1b09af07d82987e343a3bc4cb9558ecb","modified":1574254007972},{"_id":"themes/3-hexo/source/js/jquery.autocomplete.min.js","hash":"2462169ad7f4a8ae9f9f4063995cbe7fed45cd77","modified":1574254007972},{"_id":"themes/3-hexo/source/img/article-list-background.jpeg","hash":"4fdf8b3e53dd02d6ee6360aebfadb0cba1fb5633","modified":1574254007966},{"_id":"themes/3-hexo/source/img/brown-papersq.png","hash":"3a1332ede3a75a3d24f60b6ed69035b72da5e182","modified":1574254007967},{"_id":"themes/3-hexo/source/js/jquery.pjax.js","hash":"8c2a4f10a4da3d9615a3a81542494c6d21479b3d","modified":1574254007973},{"_id":"themes/3-hexo/source/js/script.js","hash":"14772b08b9c3d5c99a4b54748be9666deaae2778","modified":1574254007973},{"_id":"themes/3-hexo/source/js/search.js","hash":"788c610149a5f9361295f9f0207c8523f37ddb8b","modified":1574254007974},{"_id":"themes/3-hexo/layout/_partial/comments/click2show.ejs","hash":"8a3a175c2da956366ce91bfc4f4012a487f4bdfc","modified":1574254007943},{"_id":"themes/3-hexo/layout/_partial/comments/disqus.ejs","hash":"32ce7b48d366b9c888ff2ceb911a3cd82f864537","modified":1574254007943},{"_id":"themes/3-hexo/layout/_partial/comments/gentie.ejs","hash":"908d9046502612d24780ca354bd9392a009b4d7b","modified":1574254007944},{"_id":"themes/3-hexo/layout/_partial/comments/gitment.ejs","hash":"eaf2b6f297282606b630ad55fb9e38af7e2829dc","modified":1574254007944},{"_id":"themes/3-hexo/layout/_partial/comments/gitalk.ejs","hash":"01567e010cf4f2dd141fe2019490d3f0d5aa2529","modified":1574254007944},{"_id":"themes/3-hexo/source/css/_partial/autocomplete.styl","hash":"1ffe51e3b77afefcd94d386a718506d5b055ad94","modified":1574254007950},{"_id":"themes/3-hexo/source/css/_partial/comment.styl","hash":"fe00fb1269b4fe1f3d5ab917891926222ce47275","modified":1574254007950},{"_id":"themes/3-hexo/source/css/_partial/dashang.styl","hash":"f0eac1dc1f5dbed1769d032bb5fd5f002faaee26","modified":1574254007951},{"_id":"themes/3-hexo/source/css/_partial/fade.styl","hash":"02c7510a26f306e240f23ddbf772a69be2c890dd","modified":1574254007951},{"_id":"themes/3-hexo/source/css/_partial/font.styl","hash":"c200f3fabcfe83f3e45746e186b4bb111e73ad47","modified":1574254007952},{"_id":"themes/3-hexo/source/css/_partial/full-toc.styl","hash":"4102753dad0cc1ee9ed673f7253ba097a960c3b7","modified":1574254007952},{"_id":"themes/3-hexo/source/css/_partial/nav-left.styl","hash":"bf29eab9ea75fa191d678b6eefec440505ddf6e3","modified":1574254007952},{"_id":"themes/3-hexo/source/css/_partial/nav-right.styl","hash":"1d01247f974b059d9ef6a2178a724b4f72acd659","modified":1574254007953},{"_id":"themes/3-hexo/source/css/_partial/nprogress.styl","hash":"2620a02169a6aeb75137fd368eac2c36423d8498","modified":1574254007953},{"_id":"themes/3-hexo/source/css/_partial/num-load.styl","hash":"f7ef35459ece22e1da950b86126be1c2bfe97fcf","modified":1574254007953},{"_id":"themes/3-hexo/source/css/fonts/icomoon.ttf","hash":"eb976d8b8559fcddfc2658a03a4350cb566fc06b","modified":1574254007955},{"_id":"themes/3-hexo/source/css/_partial/post.styl","hash":"8a462cf9b0b026e71eda9e704c0fbb952b4615c5","modified":1574254007954},{"_id":"themes/3-hexo/source/css/fonts/icomoon.eot","hash":"b6195bedc1cb2f9cfcb26cc27021f2e94be2ab0a","modified":1574254007954},{"_id":"themes/3-hexo/source/css/fonts/icomoon.svg","hash":"b5e7562c8494b0ddb3a70ecc5545ef7340d8e971","modified":1574254007955},{"_id":"themes/3-hexo/source/css/fonts/icomoon.woff","hash":"3985d29416bb9b19f50a2f20f2bbbce47f10af8d","modified":1574254007955},{"_id":"themes/3-hexo/source/css/fonts/iconfont.svg","hash":"7e54ae44c02faa319c4fe128e1e6bda38eae5c9d","modified":1574254007956},{"_id":"themes/3-hexo/source/css/fonts/iconfont.ttf","hash":"aa087561480fb9c2cfd541e33d1e99d5ac1a56bb","modified":1574254007957},{"_id":"themes/3-hexo/source/css/fonts/iconfont.eot","hash":"3dfe8e557d9dfaf39bca088a02b76deb82dbaa3d","modified":1574254007956},{"_id":"themes/3-hexo/source/css/fonts/iconfont.woff","hash":"f8ed131ccf13f4bdd3ec11fc3e997339dd7b66ba","modified":1574254007957},{"_id":"themes/3-hexo/source/css/fonts/selection.json","hash":"b6456a4eabcffd95e822d1d7adce96da524d481a","modified":1574254007958},{"_id":"themes/3-hexo/source/css/hl_theme/brown-paper.styl","hash":"03af387edcc1cf8c18d12e9c440fd51b6cf425b6","modified":1574254007960},{"_id":"themes/3-hexo/source/css/hl_theme/github-gist.styl","hash":"5e05b19832c1099bd9d284bc3ed00dc8a3d7ee23","modified":1574254007960},{"_id":"themes/3-hexo/source/css/hl_theme/atom-dark.styl","hash":"f3eb4e5feda9cbd6242ccf44ca064e2979b5d719","modified":1574254007959},{"_id":"themes/3-hexo/source/css/hl_theme/atom-light.styl","hash":"69d184a682bcaeba2b180b437dc4431bc3be38aa","modified":1574254007959},{"_id":"themes/3-hexo/source/css/hl_theme/darcula.styl","hash":"2bfc14f27ccca108b4b3755782de8366e8bd001e","modified":1574254007960},{"_id":"themes/3-hexo/source/css/hl_theme/github.styl","hash":"53276ff1f224f691dfe811e82c0af7f4476abf5d","modified":1574254007960},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-dark.styl","hash":"e9c190f9ffc37a13cac430512e4e0c760205be4a","modified":1574254007961},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-dark.styl","hash":"315ad610d303caba9eac80a7d51002193a15478a","modified":1574254007961},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-light.styl","hash":"0c3ccd0d64e7504c7061d246dc32737f502f64e4","modified":1574254007962},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-light.styl","hash":"1bece084b1dbbbd4af064f05feffd8c332b96a48","modified":1574254007961},{"_id":"themes/3-hexo/source/css/hl_theme/railscasts.styl","hash":"a6e8cfd2202afd7893f5268f3437421e35066e7b","modified":1574254007962},{"_id":"themes/3-hexo/source/css/hl_theme/rainbow.styl","hash":"e5c37646a9d9c1094f9aab7a7c65a4b242e8db00","modified":1574254007962},{"_id":"themes/3-hexo/source/css/hl_theme/school-book.styl","hash":"51659351b391a2be5c68728bb51b7ad467c5e0db","modified":1574254007962},{"_id":"themes/3-hexo/source/css/hl_theme/sublime.styl","hash":"501d75ef0f4385bea24d9b9b4cc434ba68d4be27","modified":1574254007963},{"_id":"themes/3-hexo/source/css/hl_theme/sunburst.styl","hash":"2aa9817e68fb2ed216781ea04b733039ebe18214","modified":1574254007963},{"_id":"themes/3-hexo/source/css/hl_theme/zenbum.styl","hash":"92941a6ae73b74f44ad7c559c5548c44073c644a","modified":1574254007963},{"_id":"source/_posts/java/book/20200130.md","hash":"570806f2b8d6fc2ffc0bcf9c0280cf044d34297b","modified":1580458748616},{"_id":"source/_posts/java/book/readme.md","hash":"9e4a217537b67db47f9be3953b34d57c1b54d8f0","modified":1580701473604},{"_id":"themes/3-hexo/source/js/gitment.js","hash":"67984b83cd46ff4300d4fd959bf6c17dd66b4136","modified":1574254007971},{"_id":"themes/3-hexo/source/js/gitalk.js","hash":"536f28c4354a13582af826d9d9b2cb27cec07dc6","modified":1574254007970},{"_id":"source/_posts/java/jvm/post1/ConstantsPool.java","hash":"7eea4b872f6c126fb69bef08e57c6ce13d938ec5","modified":1580375056376},{"_id":"source/_posts/java/jvm/post1/HeapOOM.java","hash":"c20ca6a4b82843307743d44abdf0b79a873554b7","modified":1580375056376},{"_id":"source/_posts/java/jvm/post1/HeapOOM1.java","hash":"2b607db8590bec16abdefaf81b7e0fb7e53af815","modified":1580375056377},{"_id":"source/_posts/java/jvm/post0/post0.md","hash":"209cc1ed95b15bd9688ef89f0cfb2547be26abe9","modified":1580375056375},{"_id":"source/_posts/java/jvm/post1/MetaSpaceOOM.java","hash":"2f938b421196d473b33b96e7cef9243aef96cbe6","modified":1580375056381},{"_id":"source/_posts/java/jvm/post1/StackOverFlowOOM.java","hash":"5384e1e835fbe4b66ae4755a9776f3b09dc9ec31","modified":1580375056383},{"_id":"source/_posts/java/jvm/post1/StackAllocation.java","hash":"2d6f7c952abb176e7dd2fd433caa5540a438e9ba","modified":1580375056382},{"_id":"source/_posts/java/jvm/post1/jvm_memory_model.png","hash":"457d528d6e7085a77bc05c616e6d47600d926521","modified":1580375056385},{"_id":"source/_posts/java/spring/post0/post0.md","hash":"3428c2236142adc2886142850063f32d33576e92","modified":1588926015469},{"_id":"source/_posts/java/jvm/post1/jvm_memory_model_1.5.png","hash":"00f81e6613147b382d0f835214066541fd736f6b","modified":1580375056386},{"_id":"source/_posts/java/jvm/post1/jvm_memory_model_1.8.png","hash":"e5e0a2798a065b161ff3064687d3b516f86e051a","modified":1580375056388},{"_id":"source/_posts/java/jvm/post1/jvm_memory_model_1.7.png","hash":"9f029d55a0f81bb72c39070bd55ac7c85c0ea33f","modified":1580375056387},{"_id":"source/_posts/java/spring/post1/post1.md","hash":"7c7b9b23f7b1488c15316d72ff73444ac7af3997","modified":1588929298886},{"_id":"source/_posts/java/jvm/post1/stack-model.jpg","hash":"a4ef01cc6abdcd5a1f546c780337e395dd744371","modified":1580375056390},{"_id":"source/_posts/java/jvm/post1/post1.md","hash":"6f48d02bd549eb82660c8de38a1e6d0982875f91","modified":1580375056389},{"_id":"source/_posts/java/jvm/post0/HotSpot-architecture.jpg","hash":"c6be406d9ede267e76ab3d34544313c7c677f9ab","modified":1580375056372},{"_id":"source/_posts/java/jvm/post0/HotSpot虚拟机组件结构.pos","hash":"6122612c9ac6a86ea4639c43bcd88771f15d661c","modified":1580375056374},{"_id":"source/_posts/java/jvm/post1/栈帧信息.pos","hash":"e2aa655f4634b88ddfac2be666433d30d7031f7d","modified":1580375056391},{"_id":"source/_posts/java/jvm/post1/JAVA运行时数据划分.pos","hash":"5fa8983b220ed70b210eef04c5a83a5992b0aace","modified":1580375056380},{"_id":"public/categories/index.html","hash":"bc86fa342b25df99a264c6e0ad98750d479b2dc9","modified":1588928837572},{"_id":"public/about/index.html","hash":"94f41e6475f22e3333ba17d11c885bc0a1fe70c4","modified":1588928837572},{"_id":"public/2020/01/30/java/book/readme/index.html","hash":"b6932dee8d58fbe48eb32a2c90196082d5090c8f","modified":1588928837572},{"_id":"public/categories/book/index.html","hash":"1c42215cf9631b6ac4fc85abded580e947f71bf7","modified":1588928837572},{"_id":"public/2019/11/09/java/jvm/post0/post0/index.html","hash":"1d459b76aa60380a3155ae197f11ab0244e36c1f","modified":1588928837572},{"_id":"public/2019/11/09/java/jvm/post1/post1/index.html","hash":"4af8f52f3f4bc2f8ea2d7bf1fc1c6a97f70af3f4","modified":1588928837572},{"_id":"public/categories/jvm/index.html","hash":"1c42215cf9631b6ac4fc85abded580e947f71bf7","modified":1588928837572},{"_id":"public/archives/index.html","hash":"1c42215cf9631b6ac4fc85abded580e947f71bf7","modified":1588928837572},{"_id":"public/categories/jvm/java虚拟机，说点不一样的/index.html","hash":"1c42215cf9631b6ac4fc85abded580e947f71bf7","modified":1588928837572},{"_id":"public/archives/2019/index.html","hash":"1c42215cf9631b6ac4fc85abded580e947f71bf7","modified":1588928837572},{"_id":"public/archives/2020/index.html","hash":"1c42215cf9631b6ac4fc85abded580e947f71bf7","modified":1588928837572},{"_id":"public/archives/2019/11/index.html","hash":"1c42215cf9631b6ac4fc85abded580e947f71bf7","modified":1588928837572},{"_id":"public/archives/2020/01/index.html","hash":"1c42215cf9631b6ac4fc85abded580e947f71bf7","modified":1588928837572},{"_id":"public/index.html","hash":"1c42215cf9631b6ac4fc85abded580e947f71bf7","modified":1588928837572},{"_id":"public/2020/05/08/java/spring/post1/post1/index.html","hash":"d1b744196832ba1e0d47881308fc428d2b4df1e5","modified":1588928837572},{"_id":"public/2020/05/07/java/spring/post0/post0/index.html","hash":"b48c4b3688332cbf3e7a0ce9ed0f101479ea7dcf","modified":1588928837572},{"_id":"public/2020/01/30/java/book/20200130/index.html","hash":"1d7ba6c2fd3bc2932ec011182096a9d30de8656e","modified":1588928837572},{"_id":"public/categories/spring/index.html","hash":"1c42215cf9631b6ac4fc85abded580e947f71bf7","modified":1588928837572},{"_id":"public/categories/spring/spring源码剖析系列/index.html","hash":"1c42215cf9631b6ac4fc85abded580e947f71bf7","modified":1588928837572},{"_id":"public/archives/2020/05/index.html","hash":"1c42215cf9631b6ac4fc85abded580e947f71bf7","modified":1588928837572},{"_id":"public/CNAME","hash":"f5367a984ed6b614412786e8434452fab61cf9e9","modified":1588928782859},{"_id":"public/img/school-book.png","hash":"711ec983c874e093bb89eb77afcbdf6741fa61ee","modified":1588928782859},{"_id":"public/img/brown-papersq.png","hash":"3a1332ede3a75a3d24f60b6ed69035b72da5e182","modified":1588928782859},{"_id":"public/css/fonts/icomoon.ttf","hash":"eb976d8b8559fcddfc2658a03a4350cb566fc06b","modified":1588928782859},{"_id":"public/css/fonts/icomoon.eot","hash":"b6195bedc1cb2f9cfcb26cc27021f2e94be2ab0a","modified":1588928782859},{"_id":"public/css/fonts/icomoon.svg","hash":"b5e7562c8494b0ddb3a70ecc5545ef7340d8e971","modified":1588928782859},{"_id":"public/css/fonts/icomoon.woff","hash":"3985d29416bb9b19f50a2f20f2bbbce47f10af8d","modified":1588928782859},{"_id":"public/css/fonts/iconfont.ttf","hash":"aa087561480fb9c2cfd541e33d1e99d5ac1a56bb","modified":1588928782859},{"_id":"public/css/fonts/iconfont.woff","hash":"f8ed131ccf13f4bdd3ec11fc3e997339dd7b66ba","modified":1588928782859},{"_id":"public/css/fonts/iconfont.eot","hash":"3dfe8e557d9dfaf39bca088a02b76deb82dbaa3d","modified":1588928782859},{"_id":"public/img/alipay.jpg","hash":"c4a96cc935740fb2db5b5db401747401f90a74d1","modified":1588928782859},{"_id":"public/img/avatar.jpg","hash":"a42360089bfa892d803cf5747eab359d90f337f1","modified":1588928782859},{"_id":"public/img/weixin.jpg","hash":"bb917845578c38ad291a18186225d566b58b0fcc","modified":1588928782859},{"_id":"public/img/article-list-background.jpeg","hash":"4fdf8b3e53dd02d6ee6360aebfadb0cba1fb5633","modified":1588928782859},{"_id":"public/css/fonts/iconfont.svg","hash":"7e54ae44c02faa319c4fe128e1e6bda38eae5c9d","modified":1588928782859},{"_id":"public/css/mobile.css","hash":"79ab291be160e0ca753512a96c5198f7477f13be","modified":1588928782859},{"_id":"public/js/jquery.autocomplete.min.js","hash":"7b8ac4d06c9e763963832529f44a56ad42a81e5f","modified":1588928782859},{"_id":"public/js/search.js","hash":"c80c9a231ee040c7adc07a477793873fb85ce8bc","modified":1588928782859},{"_id":"public/css/hl_theme/brown-paper.css","hash":"500c8e750373f6656ff49a7857c871ceedcf8777","modified":1588928782859},{"_id":"public/css/hl_theme/atom-dark.css","hash":"88d11052a24e8100af6248eb4dbe1ce7b0e96408","modified":1588928782859},{"_id":"public/css/hl_theme/github-gist.css","hash":"7a41c1c479d09df875f99f1f6d94aac42e9e2ad0","modified":1588928782859},{"_id":"public/css/hl_theme/darcula.css","hash":"4341074bae4bc9f0b86e32b623e27babc0159b6e","modified":1588928782859},{"_id":"public/css/hl_theme/github.css","hash":"e05a0806a508a26b9f3f3794b6b588ec6504ad3f","modified":1588928782859},{"_id":"public/css/hl_theme/atom-light.css","hash":"a3c8f3ee9a655594eff7ac545cb2e6914c1abcc2","modified":1588928782859},{"_id":"public/css/hl_theme/kimbie-dark.css","hash":"728527fcc308da454722c119b89e6da3025bd1e3","modified":1588928782859},{"_id":"public/css/hl_theme/gruvbox-dark.css","hash":"8c440d9b4ee19ac03eaee3c6af78ba52e5ba5535","modified":1588928782859},{"_id":"public/css/hl_theme/kimbie-light.css","hash":"0c61926c989163faefb031d27bce3e287d6e10f2","modified":1588928782859},{"_id":"public/css/style.css","hash":"07df7b0c130e9965b1ff10e98351e923178883d4","modified":1588928782859},{"_id":"public/css/gitalk.css","hash":"58177ce227c50ee359fbf99a4fdd26058887afc5","modified":1588928782859},{"_id":"public/js/iconfont.js","hash":"3a0869ca1b09af07d82987e343a3bc4cb9558ecb","modified":1588928782859},{"_id":"public/js/script.js","hash":"7502191e29366a11323dc72ae365b1aed254e6f2","modified":1588928782859},{"_id":"public/js/jquery.pjax.js","hash":"191c49fdb40dff115a49cfd2b30dffb888d86550","modified":1588928782859},{"_id":"public/css/fonts/selection.json","hash":"047b615ea32dc48dae5b964061427d41feaaafdf","modified":1588928782859},{"_id":"public/css/hl_theme/rainbow.css","hash":"7ff4251938076ddb7e4e49413db82653e5b61321","modified":1588928782859},{"_id":"public/css/hl_theme/railscasts.css","hash":"511f2fd2a84d426e5da5cb17880cc08f73beb002","modified":1588928782859},{"_id":"public/css/hl_theme/school-book.css","hash":"ffbbcd13a74ac2404262c50b7a43053dfd0096ff","modified":1588928782859},{"_id":"public/css/hl_theme/gruvbox-light.css","hash":"30514aaa242a34647aa666cfca4fc74c595ea8f2","modified":1588928782859},{"_id":"public/css/hl_theme/sunburst.css","hash":"8a135abac1512cf430d1d1ad2304b79afa1a4d6e","modified":1588928782859},{"_id":"public/css/hl_theme/zenbum.css","hash":"0a78f74a93568e20b32ca7427c719e9bae9a0b55","modified":1588928782859},{"_id":"public/css/hl_theme/sublime.css","hash":"f65c5b116d9213afb9c324384a2f3bc86cb71121","modified":1588928782859},{"_id":"public/js/gitment.js","hash":"59a1e03f2b0ce61dd9bd405d3c52d3e07cc10dec","modified":1588928782859},{"_id":"public/js/gitalk.js","hash":"d1eb82a3280981bd652d9a8e323060e4311c547b","modified":1588928782859},{"_id":"source/_posts/java/spring/post1/spring_post1_code_struct.png","hash":"a9e2bed479fe692e74cb588a6239427b1b444d8a","modified":1588927699172}],"Category":[{"name":"book","_id":"ck9xz686200042kie1awgd3s7"},{"name":"spring","_id":"ck9xz686b000a2kie30002cpw"},{"name":"jvm","_id":"ck9xz686c000c2kie5p2e1c7m"},{"name":"spring源码剖析系列","parent":"ck9xz686b000a2kie30002cpw","_id":"ck9xz686d000e2kie64cu3vat"},{"name":"java虚拟机，说点不一样的","parent":"ck9xz686c000c2kie5p2e1c7m","_id":"ck9xz686d000f2kie2203934s"}],"Data":[],"Page":[{"title":"关于作者","date":"2017-09-27T02:27:42.000Z","_content":"### 个人简介\naworker，\n\n毕业于[东北哪所大学](http://www.neu.edu.cn/)，目前在贝壳找房从事java后端开发工作。\n\n喜欢研究新兴技术和未来发展方向，有任何疑问都欢迎你留言，留言必回。\n\n### 最近\n最近在写java虚拟机方面的文章\n\n\n### 联系方式\n- 邮箱 : lmyuanwork@163.com\n\n","source":"about/index.md","raw":"---\ntitle: 关于作者\ndate: 2017-09-27 10:27:42\n---\n### 个人简介\naworker，\n\n毕业于[东北哪所大学](http://www.neu.edu.cn/)，目前在贝壳找房从事java后端开发工作。\n\n喜欢研究新兴技术和未来发展方向，有任何疑问都欢迎你留言，留言必回。\n\n### 最近\n最近在写java虚拟机方面的文章\n\n\n### 联系方式\n- 邮箱 : lmyuanwork@163.com\n\n","updated":"2019-11-20T12:46:47.939Z","path":"about/index.html","comments":1,"layout":"page","_id":"ck9xz684n00002kie2smz1s0e","content":"<h3 id=\"个人简介\"><a href=\"#个人简介\" class=\"headerlink\" title=\"个人简介\"></a>个人简介</h3><p>aworker，</p>\n<p>毕业于<a href=\"http://www.neu.edu.cn/\" target=\"_blank\" rel=\"noopener\">东北哪所大学</a>，目前在贝壳找房从事java后端开发工作。</p>\n<p>喜欢研究新兴技术和未来发展方向，有任何疑问都欢迎你留言，留言必回。</p>\n<h3 id=\"最近\"><a href=\"#最近\" class=\"headerlink\" title=\"最近\"></a>最近</h3><p>最近在写java虚拟机方面的文章</p>\n<h3 id=\"联系方式\"><a href=\"#联系方式\" class=\"headerlink\" title=\"联系方式\"></a>联系方式</h3><ul>\n<li>邮箱 : <a href=\"mailto:lmyuanwork@163.com\" target=\"_blank\" rel=\"noopener\">lmyuanwork@163.com</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"个人简介\"><a href=\"#个人简介\" class=\"headerlink\" title=\"个人简介\"></a>个人简介</h3><p>aworker，</p>\n<p>毕业于<a href=\"http://www.neu.edu.cn/\" target=\"_blank\" rel=\"noopener\">东北哪所大学</a>，目前在贝壳找房从事java后端开发工作。</p>\n<p>喜欢研究新兴技术和未来发展方向，有任何疑问都欢迎你留言，留言必回。</p>\n<h3 id=\"最近\"><a href=\"#最近\" class=\"headerlink\" title=\"最近\"></a>最近</h3><p>最近在写java虚拟机方面的文章</p>\n<h3 id=\"联系方式\"><a href=\"#联系方式\" class=\"headerlink\" title=\"联系方式\"></a>联系方式</h3><ul>\n<li>邮箱 : <a href=\"mailto:lmyuanwork@163.com\" target=\"_blank\" rel=\"noopener\">lmyuanwork@163.com</a></li>\n</ul>\n"},{"title":"categories","date":"2019-11-04T09:43:11.000Z","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2019-11-04 17:43:11\n---\n","updated":"2019-11-20T12:46:47.939Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ck9xz685c00012kieahnm33o2","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"绑架游戏","date":"2020-01-30T09:36:13.000Z","_content":"\n《绑架游戏》是我读的东野圭吾的第一篇小说，在这之前我是很少有看小说的爱好的。印象中最早接触的小说是自己在上小学亦或是初中的时候读的一本叫《说岳飞通俗演义》的书，当时家里的住房翻新借宿在自己的一个叔叔家里，刚好叔叔家里有这本小说，因为住的地方发生了变化，和儿时的伙伴接触的机会不是太多了，加上当时比物质生活更加贫瘠的精神生活，导致自己放学，放假后没有什么娱乐活动。这让自己在折磨完地里的蚂蚁和蟋蟀后，开始在饭后有机会看这本书。自己本来就比较喜欢历史类的书籍，所以很快就把这本书读完了。再后来接触到小说就是在上高中的时候，我的同位特别喜欢小说，印象中常常在上自习时，或者上课时他抱着一本砖头厚（参考《think in java》）的大书看，偶尔在课间他也会和我聊小说中的内容，我也在那个时候了解到《星辰变》、《神墓》、《小兵传奇》这类玄幻类小说，加上高中时候都是一些学习上不太上进的学生看小说，小说给我的印象就不太好，这种印象从高中持续到大学，研究生（研究生阶段我读完了 路遥的《平凡的世界》），和工作以后，直到2020年1月份的某个一天，在通往火车站的地铁上，我无意间在阅读app扫到这本《绑架游戏》。早在2018年就曾听过东野圭吾，当时有个同事非常喜欢他的作品，然后简单百度了下知道其是日本的一位比较有名的推理小说作家。然而真正让我感兴趣并且开始有意读其作品，就始于这部《绑架游戏》。\n\n《绑架游戏》介绍的是一位叫佐久间俊介的广告公司资深策划，在其策划案被甲方的副社长葛城胜俊否定后，心意阑珊之下去葛城府邸溜达时而引发的一场“绑架游戏”。俊介和葛城家的千金葛城树理演义一场被绑架人和绑架人一起谋划的绑架游戏，俊介通过细致的计算和高超的演技成功的报复了葛城胜俊——赢得了赎金且全身而退。但在随后的日子里发现真相可能并不是想他想的那样简单：情妇生养的葛城树理因为琐事和正妻生养的葛城千春发生口角而离家出走，俊介恰巧偶遇逃跑的树理，树理因为在家受尽歧视想报复葛城家，和恰好想报复葛城胜俊的俊介不谋而合，于是二人导演了这出绑架游戏。真相是出逃的并不是葛城树理，而是冒名葛城树理的葛城千春，而千春出逃的真实原因是自己因为琐事意外杀害了葛城树理，俊介以为自己是这出绑架大戏的导演，没想到自己只不过是千春和胜俊为掩盖千春杀人真相的一个棋子。在绑架游戏的过程中有好多意外和可疑事情发生，但都因为俊介的盲目自信与好强而没有及时收手，来终结这场游戏。当然如果仅仅是这样，这顶多会是一场被警察识破的恶作剧，但是俊介在绑架过程中爱上了千春导致了致命性的结果——俊介被千春和胜俊有意刻画成一个索要赎金得逞后还强奸并杀害树理的凶手。但也正是因为自己爱上了千春后无意拍摄的一张照片让自己和葛城家保持着一种动态平衡，自己才免于遭人杀害...\n\n目前阅读过东野圭吾两部作品，其写作风格都是前期平淡无奇的叙述和后期真相的急剧翻转，作者通过前期看似无意的“无心插柳”般的伏笔到后期的“串线成林”让人不禁惊叹于作者精细秒的构思和强大的文字功力，希望2020年能有时间阅读其大作《白夜行》。武汉加油！天佑中华！\n\n\n","source":"_posts/java/book/20200130.md","raw":"---\ntitle: 绑架游戏\ndate: 2020-01-30 17:36:13\ncategories:\n    - book\ntags:\n---\n\n《绑架游戏》是我读的东野圭吾的第一篇小说，在这之前我是很少有看小说的爱好的。印象中最早接触的小说是自己在上小学亦或是初中的时候读的一本叫《说岳飞通俗演义》的书，当时家里的住房翻新借宿在自己的一个叔叔家里，刚好叔叔家里有这本小说，因为住的地方发生了变化，和儿时的伙伴接触的机会不是太多了，加上当时比物质生活更加贫瘠的精神生活，导致自己放学，放假后没有什么娱乐活动。这让自己在折磨完地里的蚂蚁和蟋蟀后，开始在饭后有机会看这本书。自己本来就比较喜欢历史类的书籍，所以很快就把这本书读完了。再后来接触到小说就是在上高中的时候，我的同位特别喜欢小说，印象中常常在上自习时，或者上课时他抱着一本砖头厚（参考《think in java》）的大书看，偶尔在课间他也会和我聊小说中的内容，我也在那个时候了解到《星辰变》、《神墓》、《小兵传奇》这类玄幻类小说，加上高中时候都是一些学习上不太上进的学生看小说，小说给我的印象就不太好，这种印象从高中持续到大学，研究生（研究生阶段我读完了 路遥的《平凡的世界》），和工作以后，直到2020年1月份的某个一天，在通往火车站的地铁上，我无意间在阅读app扫到这本《绑架游戏》。早在2018年就曾听过东野圭吾，当时有个同事非常喜欢他的作品，然后简单百度了下知道其是日本的一位比较有名的推理小说作家。然而真正让我感兴趣并且开始有意读其作品，就始于这部《绑架游戏》。\n\n《绑架游戏》介绍的是一位叫佐久间俊介的广告公司资深策划，在其策划案被甲方的副社长葛城胜俊否定后，心意阑珊之下去葛城府邸溜达时而引发的一场“绑架游戏”。俊介和葛城家的千金葛城树理演义一场被绑架人和绑架人一起谋划的绑架游戏，俊介通过细致的计算和高超的演技成功的报复了葛城胜俊——赢得了赎金且全身而退。但在随后的日子里发现真相可能并不是想他想的那样简单：情妇生养的葛城树理因为琐事和正妻生养的葛城千春发生口角而离家出走，俊介恰巧偶遇逃跑的树理，树理因为在家受尽歧视想报复葛城家，和恰好想报复葛城胜俊的俊介不谋而合，于是二人导演了这出绑架游戏。真相是出逃的并不是葛城树理，而是冒名葛城树理的葛城千春，而千春出逃的真实原因是自己因为琐事意外杀害了葛城树理，俊介以为自己是这出绑架大戏的导演，没想到自己只不过是千春和胜俊为掩盖千春杀人真相的一个棋子。在绑架游戏的过程中有好多意外和可疑事情发生，但都因为俊介的盲目自信与好强而没有及时收手，来终结这场游戏。当然如果仅仅是这样，这顶多会是一场被警察识破的恶作剧，但是俊介在绑架过程中爱上了千春导致了致命性的结果——俊介被千春和胜俊有意刻画成一个索要赎金得逞后还强奸并杀害树理的凶手。但也正是因为自己爱上了千春后无意拍摄的一张照片让自己和葛城家保持着一种动态平衡，自己才免于遭人杀害...\n\n目前阅读过东野圭吾两部作品，其写作风格都是前期平淡无奇的叙述和后期真相的急剧翻转，作者通过前期看似无意的“无心插柳”般的伏笔到后期的“串线成林”让人不禁惊叹于作者精细秒的构思和强大的文字功力，希望2020年能有时间阅读其大作《白夜行》。武汉加油！天佑中华！\n\n\n","slug":"java/book/20200130","published":1,"updated":"2020-01-31T08:19:08.616Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9xz685y00022kie50159e2x","content":"<p>《绑架游戏》是我读的东野圭吾的第一篇小说，在这之前我是很少有看小说的爱好的。印象中最早接触的小说是自己在上小学亦或是初中的时候读的一本叫《说岳飞通俗演义》的书，当时家里的住房翻新借宿在自己的一个叔叔家里，刚好叔叔家里有这本小说，因为住的地方发生了变化，和儿时的伙伴接触的机会不是太多了，加上当时比物质生活更加贫瘠的精神生活，导致自己放学，放假后没有什么娱乐活动。这让自己在折磨完地里的蚂蚁和蟋蟀后，开始在饭后有机会看这本书。自己本来就比较喜欢历史类的书籍，所以很快就把这本书读完了。再后来接触到小说就是在上高中的时候，我的同位特别喜欢小说，印象中常常在上自习时，或者上课时他抱着一本砖头厚（参考《think in java》）的大书看，偶尔在课间他也会和我聊小说中的内容，我也在那个时候了解到《星辰变》、《神墓》、《小兵传奇》这类玄幻类小说，加上高中时候都是一些学习上不太上进的学生看小说，小说给我的印象就不太好，这种印象从高中持续到大学，研究生（研究生阶段我读完了 路遥的《平凡的世界》），和工作以后，直到2020年1月份的某个一天，在通往火车站的地铁上，我无意间在阅读app扫到这本《绑架游戏》。早在2018年就曾听过东野圭吾，当时有个同事非常喜欢他的作品，然后简单百度了下知道其是日本的一位比较有名的推理小说作家。然而真正让我感兴趣并且开始有意读其作品，就始于这部《绑架游戏》。</p>\n<p>《绑架游戏》介绍的是一位叫佐久间俊介的广告公司资深策划，在其策划案被甲方的副社长葛城胜俊否定后，心意阑珊之下去葛城府邸溜达时而引发的一场“绑架游戏”。俊介和葛城家的千金葛城树理演义一场被绑架人和绑架人一起谋划的绑架游戏，俊介通过细致的计算和高超的演技成功的报复了葛城胜俊——赢得了赎金且全身而退。但在随后的日子里发现真相可能并不是想他想的那样简单：情妇生养的葛城树理因为琐事和正妻生养的葛城千春发生口角而离家出走，俊介恰巧偶遇逃跑的树理，树理因为在家受尽歧视想报复葛城家，和恰好想报复葛城胜俊的俊介不谋而合，于是二人导演了这出绑架游戏。真相是出逃的并不是葛城树理，而是冒名葛城树理的葛城千春，而千春出逃的真实原因是自己因为琐事意外杀害了葛城树理，俊介以为自己是这出绑架大戏的导演，没想到自己只不过是千春和胜俊为掩盖千春杀人真相的一个棋子。在绑架游戏的过程中有好多意外和可疑事情发生，但都因为俊介的盲目自信与好强而没有及时收手，来终结这场游戏。当然如果仅仅是这样，这顶多会是一场被警察识破的恶作剧，但是俊介在绑架过程中爱上了千春导致了致命性的结果——俊介被千春和胜俊有意刻画成一个索要赎金得逞后还强奸并杀害树理的凶手。但也正是因为自己爱上了千春后无意拍摄的一张照片让自己和葛城家保持着一种动态平衡，自己才免于遭人杀害…</p>\n<p>目前阅读过东野圭吾两部作品，其写作风格都是前期平淡无奇的叙述和后期真相的急剧翻转，作者通过前期看似无意的“无心插柳”般的伏笔到后期的“串线成林”让人不禁惊叹于作者精细秒的构思和强大的文字功力，希望2020年能有时间阅读其大作《白夜行》。武汉加油！天佑中华！</p>\n","site":{"data":{}},"excerpt":"","more":"<p>《绑架游戏》是我读的东野圭吾的第一篇小说，在这之前我是很少有看小说的爱好的。印象中最早接触的小说是自己在上小学亦或是初中的时候读的一本叫《说岳飞通俗演义》的书，当时家里的住房翻新借宿在自己的一个叔叔家里，刚好叔叔家里有这本小说，因为住的地方发生了变化，和儿时的伙伴接触的机会不是太多了，加上当时比物质生活更加贫瘠的精神生活，导致自己放学，放假后没有什么娱乐活动。这让自己在折磨完地里的蚂蚁和蟋蟀后，开始在饭后有机会看这本书。自己本来就比较喜欢历史类的书籍，所以很快就把这本书读完了。再后来接触到小说就是在上高中的时候，我的同位特别喜欢小说，印象中常常在上自习时，或者上课时他抱着一本砖头厚（参考《think in java》）的大书看，偶尔在课间他也会和我聊小说中的内容，我也在那个时候了解到《星辰变》、《神墓》、《小兵传奇》这类玄幻类小说，加上高中时候都是一些学习上不太上进的学生看小说，小说给我的印象就不太好，这种印象从高中持续到大学，研究生（研究生阶段我读完了 路遥的《平凡的世界》），和工作以后，直到2020年1月份的某个一天，在通往火车站的地铁上，我无意间在阅读app扫到这本《绑架游戏》。早在2018年就曾听过东野圭吾，当时有个同事非常喜欢他的作品，然后简单百度了下知道其是日本的一位比较有名的推理小说作家。然而真正让我感兴趣并且开始有意读其作品，就始于这部《绑架游戏》。</p>\n<p>《绑架游戏》介绍的是一位叫佐久间俊介的广告公司资深策划，在其策划案被甲方的副社长葛城胜俊否定后，心意阑珊之下去葛城府邸溜达时而引发的一场“绑架游戏”。俊介和葛城家的千金葛城树理演义一场被绑架人和绑架人一起谋划的绑架游戏，俊介通过细致的计算和高超的演技成功的报复了葛城胜俊——赢得了赎金且全身而退。但在随后的日子里发现真相可能并不是想他想的那样简单：情妇生养的葛城树理因为琐事和正妻生养的葛城千春发生口角而离家出走，俊介恰巧偶遇逃跑的树理，树理因为在家受尽歧视想报复葛城家，和恰好想报复葛城胜俊的俊介不谋而合，于是二人导演了这出绑架游戏。真相是出逃的并不是葛城树理，而是冒名葛城树理的葛城千春，而千春出逃的真实原因是自己因为琐事意外杀害了葛城树理，俊介以为自己是这出绑架大戏的导演，没想到自己只不过是千春和胜俊为掩盖千春杀人真相的一个棋子。在绑架游戏的过程中有好多意外和可疑事情发生，但都因为俊介的盲目自信与好强而没有及时收手，来终结这场游戏。当然如果仅仅是这样，这顶多会是一场被警察识破的恶作剧，但是俊介在绑架过程中爱上了千春导致了致命性的结果——俊介被千春和胜俊有意刻画成一个索要赎金得逞后还强奸并杀害树理的凶手。但也正是因为自己爱上了千春后无意拍摄的一张照片让自己和葛城家保持着一种动态平衡，自己才免于遭人杀害…</p>\n<p>目前阅读过东野圭吾两部作品，其写作风格都是前期平淡无奇的叙述和后期真相的急剧翻转，作者通过前期看似无意的“无心插柳”般的伏笔到后期的“串线成林”让人不禁惊叹于作者精细秒的构思和强大的文字功力，希望2020年能有时间阅读其大作《白夜行》。武汉加油！天佑中华！</p>\n"},{"title":"我的读书清单","date":"2020-01-30T07:36:13.000Z","_content":"\n# 为什么要读书\n\n2019年，对我来说是一个有重大变革的一年。自己倒了三十而立的年龄，却没有“而立”的能力，回想起自己从2017年2月份开始工作到现在，竟然依旧过的浑浑噩噩，事业上没有多少进步，感情生活还是毫无起色，本以为自己就这样乐知天命的过下去，但是每每听到和自己一样的草根阶层在通过自己的努力实现阶层跨越时内心总有一些除去羡慕以外情愫；每每浏览别人的技术博客看到许多大牛在比自己厉害还比自己努力的时候心中也总有除惭愧以外的思绪。可是自己总是缺少一些来自心底的“呐喊”来唤醒自己，告诉我这到底是什么。直到有一天听到这样一条宣传标语：“人为什么要读书？读书代表着你对现实生活的不甘，代表着你对诗和远方的向往”。一种醍醐灌顶的感觉油然而生，我想自己那么飘忽不定的情愫和思绪就是 **不甘**。自己从小学的门门一百分，梦想成为科学家；到中学的年级名列前茅，立志做对生活有重大影响之人；在到大学时代的中等上游，奢望毕业能拿到12k的月薪...。《论语》里面有句话说的特别好“取乎其上，得乎其中；取乎其中，得乎其下；取乎其下，则无所得矣。”，说的就是人们在制定标准时一定要高于自己的需求，且努力实现高于需求的标准，而只有这样，才能得到自己本想得到需求。自己并不是愚笨到无可救药的程度，而是自己指定的目标并不高于自己的需求，也不严格执行自己的目标。“读书万卷书”就是自己从青年时，从心底就有的一个目标。但是从大学到工作以来，自己做的差强人意。倒不是说自己从毕业到现在没有读过书，只不过很少有计划的读书，也没能将自己读过的书罗列出来存底来填充自己的底气。而对于书籍中的知识这样的抽象慰藉，是缺少一种可以度量的标准的，这将导致自己在读书方面的付出没办法具化，难易形成正向激励，这对自己实现未来的读书标准显然是不利的，为此在自己的个人技术博客上列一个小小读书清单，希望能帮助自己养成有计划读书的好习惯，来抚平自己不甘的心。2020，必将自强。\n\n# 我的读书清单\n\n## 2020年书单\n\n1、[绑架游戏](http://aworker.cn/2020/01/30/java/book/20200130/)\n\n2、[恶意]()\n\n## 2019年书单\n\n1、[Java Concurrency In Practice]()","source":"_posts/java/book/readme.md","raw":"---\ntitle: 我的读书清单\ndate: 2020-01-30 15:36:13\ncategories:\n    - book\ntags:\n---\n\n# 为什么要读书\n\n2019年，对我来说是一个有重大变革的一年。自己倒了三十而立的年龄，却没有“而立”的能力，回想起自己从2017年2月份开始工作到现在，竟然依旧过的浑浑噩噩，事业上没有多少进步，感情生活还是毫无起色，本以为自己就这样乐知天命的过下去，但是每每听到和自己一样的草根阶层在通过自己的努力实现阶层跨越时内心总有一些除去羡慕以外情愫；每每浏览别人的技术博客看到许多大牛在比自己厉害还比自己努力的时候心中也总有除惭愧以外的思绪。可是自己总是缺少一些来自心底的“呐喊”来唤醒自己，告诉我这到底是什么。直到有一天听到这样一条宣传标语：“人为什么要读书？读书代表着你对现实生活的不甘，代表着你对诗和远方的向往”。一种醍醐灌顶的感觉油然而生，我想自己那么飘忽不定的情愫和思绪就是 **不甘**。自己从小学的门门一百分，梦想成为科学家；到中学的年级名列前茅，立志做对生活有重大影响之人；在到大学时代的中等上游，奢望毕业能拿到12k的月薪...。《论语》里面有句话说的特别好“取乎其上，得乎其中；取乎其中，得乎其下；取乎其下，则无所得矣。”，说的就是人们在制定标准时一定要高于自己的需求，且努力实现高于需求的标准，而只有这样，才能得到自己本想得到需求。自己并不是愚笨到无可救药的程度，而是自己指定的目标并不高于自己的需求，也不严格执行自己的目标。“读书万卷书”就是自己从青年时，从心底就有的一个目标。但是从大学到工作以来，自己做的差强人意。倒不是说自己从毕业到现在没有读过书，只不过很少有计划的读书，也没能将自己读过的书罗列出来存底来填充自己的底气。而对于书籍中的知识这样的抽象慰藉，是缺少一种可以度量的标准的，这将导致自己在读书方面的付出没办法具化，难易形成正向激励，这对自己实现未来的读书标准显然是不利的，为此在自己的个人技术博客上列一个小小读书清单，希望能帮助自己养成有计划读书的好习惯，来抚平自己不甘的心。2020，必将自强。\n\n# 我的读书清单\n\n## 2020年书单\n\n1、[绑架游戏](http://aworker.cn/2020/01/30/java/book/20200130/)\n\n2、[恶意]()\n\n## 2019年书单\n\n1、[Java Concurrency In Practice]()","slug":"java/book/readme","published":1,"updated":"2020-02-03T03:44:33.604Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9xz686000032kie645aeu6z","content":"<h1 id=\"为什么要读书\"><a href=\"#为什么要读书\" class=\"headerlink\" title=\"为什么要读书\"></a>为什么要读书</h1><p>2019年，对我来说是一个有重大变革的一年。自己倒了三十而立的年龄，却没有“而立”的能力，回想起自己从2017年2月份开始工作到现在，竟然依旧过的浑浑噩噩，事业上没有多少进步，感情生活还是毫无起色，本以为自己就这样乐知天命的过下去，但是每每听到和自己一样的草根阶层在通过自己的努力实现阶层跨越时内心总有一些除去羡慕以外情愫；每每浏览别人的技术博客看到许多大牛在比自己厉害还比自己努力的时候心中也总有除惭愧以外的思绪。可是自己总是缺少一些来自心底的“呐喊”来唤醒自己，告诉我这到底是什么。直到有一天听到这样一条宣传标语：“人为什么要读书？读书代表着你对现实生活的不甘，代表着你对诗和远方的向往”。一种醍醐灌顶的感觉油然而生，我想自己那么飘忽不定的情愫和思绪就是 <strong>不甘</strong>。自己从小学的门门一百分，梦想成为科学家；到中学的年级名列前茅，立志做对生活有重大影响之人；在到大学时代的中等上游，奢望毕业能拿到12k的月薪…。《论语》里面有句话说的特别好“取乎其上，得乎其中；取乎其中，得乎其下；取乎其下，则无所得矣。”，说的就是人们在制定标准时一定要高于自己的需求，且努力实现高于需求的标准，而只有这样，才能得到自己本想得到需求。自己并不是愚笨到无可救药的程度，而是自己指定的目标并不高于自己的需求，也不严格执行自己的目标。“读书万卷书”就是自己从青年时，从心底就有的一个目标。但是从大学到工作以来，自己做的差强人意。倒不是说自己从毕业到现在没有读过书，只不过很少有计划的读书，也没能将自己读过的书罗列出来存底来填充自己的底气。而对于书籍中的知识这样的抽象慰藉，是缺少一种可以度量的标准的，这将导致自己在读书方面的付出没办法具化，难易形成正向激励，这对自己实现未来的读书标准显然是不利的，为此在自己的个人技术博客上列一个小小读书清单，希望能帮助自己养成有计划读书的好习惯，来抚平自己不甘的心。2020，必将自强。</p>\n<h1 id=\"我的读书清单\"><a href=\"#我的读书清单\" class=\"headerlink\" title=\"我的读书清单\"></a>我的读书清单</h1><h2 id=\"2020年书单\"><a href=\"#2020年书单\" class=\"headerlink\" title=\"2020年书单\"></a>2020年书单</h2><p>1、<a href=\"http://aworker.cn/2020/01/30/java/book/20200130/\">绑架游戏</a></p>\n<p>2、<a href=\"\">恶意</a></p>\n<h2 id=\"2019年书单\"><a href=\"#2019年书单\" class=\"headerlink\" title=\"2019年书单\"></a>2019年书单</h2><p>1、<a href=\"\">Java Concurrency In Practice</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"为什么要读书\"><a href=\"#为什么要读书\" class=\"headerlink\" title=\"为什么要读书\"></a>为什么要读书</h1><p>2019年，对我来说是一个有重大变革的一年。自己倒了三十而立的年龄，却没有“而立”的能力，回想起自己从2017年2月份开始工作到现在，竟然依旧过的浑浑噩噩，事业上没有多少进步，感情生活还是毫无起色，本以为自己就这样乐知天命的过下去，但是每每听到和自己一样的草根阶层在通过自己的努力实现阶层跨越时内心总有一些除去羡慕以外情愫；每每浏览别人的技术博客看到许多大牛在比自己厉害还比自己努力的时候心中也总有除惭愧以外的思绪。可是自己总是缺少一些来自心底的“呐喊”来唤醒自己，告诉我这到底是什么。直到有一天听到这样一条宣传标语：“人为什么要读书？读书代表着你对现实生活的不甘，代表着你对诗和远方的向往”。一种醍醐灌顶的感觉油然而生，我想自己那么飘忽不定的情愫和思绪就是 <strong>不甘</strong>。自己从小学的门门一百分，梦想成为科学家；到中学的年级名列前茅，立志做对生活有重大影响之人；在到大学时代的中等上游，奢望毕业能拿到12k的月薪…。《论语》里面有句话说的特别好“取乎其上，得乎其中；取乎其中，得乎其下；取乎其下，则无所得矣。”，说的就是人们在制定标准时一定要高于自己的需求，且努力实现高于需求的标准，而只有这样，才能得到自己本想得到需求。自己并不是愚笨到无可救药的程度，而是自己指定的目标并不高于自己的需求，也不严格执行自己的目标。“读书万卷书”就是自己从青年时，从心底就有的一个目标。但是从大学到工作以来，自己做的差强人意。倒不是说自己从毕业到现在没有读过书，只不过很少有计划的读书，也没能将自己读过的书罗列出来存底来填充自己的底气。而对于书籍中的知识这样的抽象慰藉，是缺少一种可以度量的标准的，这将导致自己在读书方面的付出没办法具化，难易形成正向激励，这对自己实现未来的读书标准显然是不利的，为此在自己的个人技术博客上列一个小小读书清单，希望能帮助自己养成有计划读书的好习惯，来抚平自己不甘的心。2020，必将自强。</p>\n<h1 id=\"我的读书清单\"><a href=\"#我的读书清单\" class=\"headerlink\" title=\"我的读书清单\"></a>我的读书清单</h1><h2 id=\"2020年书单\"><a href=\"#2020年书单\" class=\"headerlink\" title=\"2020年书单\"></a>2020年书单</h2><p>1、<a href=\"http://aworker.cn/2020/01/30/java/book/20200130/\">绑架游戏</a></p>\n<p>2、<a href=\"\">恶意</a></p>\n<h2 id=\"2019年书单\"><a href=\"#2019年书单\" class=\"headerlink\" title=\"2019年书单\"></a>2019年书单</h2><p>1、<a href=\"\">Java Concurrency In Practice</a></p>\n"},{"title":"01 spring解决循环源码分析","date":"2020-05-08T08:46:13.000Z","_content":"\n# 1、什么是循环依赖\n\n循环依赖在spring框架中有一个专有名词叫 *Circular dependencies*，其具体是指受spring管理的两个bean对象 Bean1和Bean2，Bean1中有成员变量Bean2；Bean2中有成员变量Bean1。具体代码case如下：\n\n代码结构如图：\n\n![代码结构图](https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/spring/post1/spring_post1_code_struct.png)\n\n\n\n\n\n\n# 参考资料\n\n[1、Spring Circular Dependencies](https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-dependency-resolution)","source":"_posts/java/spring/post1/post1.md","raw":"---\ntitle: 01 spring解决循环源码分析\ndate: 2020-05-08 16:46:13\ncategories:\n    - spring\n    - spring源码剖析系列\ntags:\n---\n\n# 1、什么是循环依赖\n\n循环依赖在spring框架中有一个专有名词叫 *Circular dependencies*，其具体是指受spring管理的两个bean对象 Bean1和Bean2，Bean1中有成员变量Bean2；Bean2中有成员变量Bean1。具体代码case如下：\n\n代码结构如图：\n\n![代码结构图](https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/spring/post1/spring_post1_code_struct.png)\n\n\n\n\n\n\n# 参考资料\n\n[1、Spring Circular Dependencies](https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-dependency-resolution)","slug":"java/spring/post1/post1","published":1,"updated":"2020-05-08T09:14:58.886Z","_id":"ck9xz686900082kie5dfm3ciq","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"1、什么是循环依赖\"><a href=\"#1、什么是循环依赖\" class=\"headerlink\" title=\"1、什么是循环依赖\"></a>1、什么是循环依赖</h1><p>循环依赖在spring框架中有一个专有名词叫 <em>Circular dependencies</em>，其具体是指受spring管理的两个bean对象 Bean1和Bean2，Bean1中有成员变量Bean2；Bean2中有成员变量Bean1。具体代码case如下：</p>\n<p>代码结构如图：</p>\n<p><img src=\"https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/spring/post1/spring_post1_code_struct.png\" alt=\"代码结构图\"></p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><a href=\"https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-dependency-resolution\" target=\"_blank\" rel=\"noopener\">1、Spring Circular Dependencies</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1、什么是循环依赖\"><a href=\"#1、什么是循环依赖\" class=\"headerlink\" title=\"1、什么是循环依赖\"></a>1、什么是循环依赖</h1><p>循环依赖在spring框架中有一个专有名词叫 <em>Circular dependencies</em>，其具体是指受spring管理的两个bean对象 Bean1和Bean2，Bean1中有成员变量Bean2；Bean2中有成员变量Bean1。具体代码case如下：</p>\n<p>代码结构如图：</p>\n<p><img src=\"https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/spring/post1/spring_post1_code_struct.png\" alt=\"代码结构图\"></p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><a href=\"https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-dependency-resolution\" target=\"_blank\" rel=\"noopener\">1、Spring Circular Dependencies</a></p>\n"},{"title":"00开篇","date":"2019-11-09T08:36:13.000Z","_content":"\n有别于C/C++语言，java虚拟机解放了java程序员，使我们在开发过程中不必负责每个对象的出生和死亡，我们只管用new关键字创建对象，使用对象，对于不在使用的对象所占的内存空间的回收，完全交给java虚拟机来负责。在程序内存管理领域，java虚拟机即让我们避免成为分配对象内存，回收对象内存这样单调工作的奴隶；也让我们丧失了成为掌握对象内存空间管理“生杀大权”的皇帝，内存管理对我们越发的陌生和透明，一旦有内存泄露或者溢出以及涉及到虚拟机方面的性能调优，都会让我们手足无措。《也谈java虚拟机，说点不一样的》系列文章，力求用简单，生动，具体的讲述风格讲解java虚拟机的运作机制，让广大java开发人员得以管窥一二，在实际工作中、在面试找工作时、在饭后和同事吹逼时，都能得心应手，从容应对。鉴于java虚拟机知识体系的庞杂和深邃以及本员能力的限制，系列文章中难免有错误和不足，希望大家多多包涵。\n\njava虚拟机是一个抽象的计算机。对于程序开发人员来说，我们只需要编写好我们的程序，让不同平台上的java虚拟机完成java代码到不同操作系统计算机指令的转化，通过这种方式java语言实现了其夸平台特性。虽然名为java虚拟机，但是它并不是和java语言强绑定的，java虚拟机只能识别有特定语法格式的class文件，而所有能编译为class文件的语言，都可以在java虚拟机上运行，java虚拟机不是“java语言的虚拟机”而是“多语言的虚拟机”。\n\n在java虚拟机的发展历史上，曾经有很多的优秀的虚拟机实现。如随着jdk1.0一起发布的Classic VM，号称速度最快的JRockit VM，以及专精Windows平台的Microsoft JVM等。但我们普通程序员用的最多的也是“血统最纯正”虚拟机实现就是Sun公司发布的HotSpot VM，这个系列也以HotSpot虚拟机为蓝本进行讲述的。\n\n\nHotSpot虚拟机的组件结构如下：\n\n![HotSpot虚拟机组件结构](https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/jvm/post0/HotSpot-architecture.jpg) \n\nHotSpot虚拟机有三大主要模块：\n\n+ 类加载子系统，主要用来加载class文件，从中获取类信息。\n+ 虚拟机运行时数据区，主要存储程序运行时的各种对象信息和线程栈帧数据。\n+ 执行引擎，主要内存垃圾回收和运行时代码优化。\n\n本系列将会从实际应用、面试需要、饭后吹逼等三个角度分别讲解这三大主要模块。同时给自己立个flag到2020年6月能完成本系列文章的全部写作。\n\n> 有任何不懂或者质疑的地方，都欢迎大家积极留言讨论，留言必回，一起学习进步。\n\n\n\n<!-- \n参考文献 https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html\n-->","source":"_posts/java/jvm/post0/post0.md","raw":"---\ntitle: 00开篇\ndate: 2019-11-09 16:36:13\ncategories:\n    - jvm\n    - java虚拟机，说点不一样的\ntags:\n---\n\n有别于C/C++语言，java虚拟机解放了java程序员，使我们在开发过程中不必负责每个对象的出生和死亡，我们只管用new关键字创建对象，使用对象，对于不在使用的对象所占的内存空间的回收，完全交给java虚拟机来负责。在程序内存管理领域，java虚拟机即让我们避免成为分配对象内存，回收对象内存这样单调工作的奴隶；也让我们丧失了成为掌握对象内存空间管理“生杀大权”的皇帝，内存管理对我们越发的陌生和透明，一旦有内存泄露或者溢出以及涉及到虚拟机方面的性能调优，都会让我们手足无措。《也谈java虚拟机，说点不一样的》系列文章，力求用简单，生动，具体的讲述风格讲解java虚拟机的运作机制，让广大java开发人员得以管窥一二，在实际工作中、在面试找工作时、在饭后和同事吹逼时，都能得心应手，从容应对。鉴于java虚拟机知识体系的庞杂和深邃以及本员能力的限制，系列文章中难免有错误和不足，希望大家多多包涵。\n\njava虚拟机是一个抽象的计算机。对于程序开发人员来说，我们只需要编写好我们的程序，让不同平台上的java虚拟机完成java代码到不同操作系统计算机指令的转化，通过这种方式java语言实现了其夸平台特性。虽然名为java虚拟机，但是它并不是和java语言强绑定的，java虚拟机只能识别有特定语法格式的class文件，而所有能编译为class文件的语言，都可以在java虚拟机上运行，java虚拟机不是“java语言的虚拟机”而是“多语言的虚拟机”。\n\n在java虚拟机的发展历史上，曾经有很多的优秀的虚拟机实现。如随着jdk1.0一起发布的Classic VM，号称速度最快的JRockit VM，以及专精Windows平台的Microsoft JVM等。但我们普通程序员用的最多的也是“血统最纯正”虚拟机实现就是Sun公司发布的HotSpot VM，这个系列也以HotSpot虚拟机为蓝本进行讲述的。\n\n\nHotSpot虚拟机的组件结构如下：\n\n![HotSpot虚拟机组件结构](https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/jvm/post0/HotSpot-architecture.jpg) \n\nHotSpot虚拟机有三大主要模块：\n\n+ 类加载子系统，主要用来加载class文件，从中获取类信息。\n+ 虚拟机运行时数据区，主要存储程序运行时的各种对象信息和线程栈帧数据。\n+ 执行引擎，主要内存垃圾回收和运行时代码优化。\n\n本系列将会从实际应用、面试需要、饭后吹逼等三个角度分别讲解这三大主要模块。同时给自己立个flag到2020年6月能完成本系列文章的全部写作。\n\n> 有任何不懂或者质疑的地方，都欢迎大家积极留言讨论，留言必回，一起学习进步。\n\n\n\n<!-- \n参考文献 https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html\n-->","slug":"java/jvm/post0/post0","published":1,"updated":"2020-01-30T09:04:16.375Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9xz686a00092kieco8xbc9m","content":"<p>有别于C/C++语言，java虚拟机解放了java程序员，使我们在开发过程中不必负责每个对象的出生和死亡，我们只管用new关键字创建对象，使用对象，对于不在使用的对象所占的内存空间的回收，完全交给java虚拟机来负责。在程序内存管理领域，java虚拟机即让我们避免成为分配对象内存，回收对象内存这样单调工作的奴隶；也让我们丧失了成为掌握对象内存空间管理“生杀大权”的皇帝，内存管理对我们越发的陌生和透明，一旦有内存泄露或者溢出以及涉及到虚拟机方面的性能调优，都会让我们手足无措。《也谈java虚拟机，说点不一样的》系列文章，力求用简单，生动，具体的讲述风格讲解java虚拟机的运作机制，让广大java开发人员得以管窥一二，在实际工作中、在面试找工作时、在饭后和同事吹逼时，都能得心应手，从容应对。鉴于java虚拟机知识体系的庞杂和深邃以及本员能力的限制，系列文章中难免有错误和不足，希望大家多多包涵。</p>\n<p>java虚拟机是一个抽象的计算机。对于程序开发人员来说，我们只需要编写好我们的程序，让不同平台上的java虚拟机完成java代码到不同操作系统计算机指令的转化，通过这种方式java语言实现了其夸平台特性。虽然名为java虚拟机，但是它并不是和java语言强绑定的，java虚拟机只能识别有特定语法格式的class文件，而所有能编译为class文件的语言，都可以在java虚拟机上运行，java虚拟机不是“java语言的虚拟机”而是“多语言的虚拟机”。</p>\n<p>在java虚拟机的发展历史上，曾经有很多的优秀的虚拟机实现。如随着jdk1.0一起发布的Classic VM，号称速度最快的JRockit VM，以及专精Windows平台的Microsoft JVM等。但我们普通程序员用的最多的也是“血统最纯正”虚拟机实现就是Sun公司发布的HotSpot VM，这个系列也以HotSpot虚拟机为蓝本进行讲述的。</p>\n<p>HotSpot虚拟机的组件结构如下：</p>\n<p><img src=\"https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/jvm/post0/HotSpot-architecture.jpg\" alt=\"HotSpot虚拟机组件结构\"> </p>\n<p>HotSpot虚拟机有三大主要模块：</p>\n<ul>\n<li>类加载子系统，主要用来加载class文件，从中获取类信息。</li>\n<li>虚拟机运行时数据区，主要存储程序运行时的各种对象信息和线程栈帧数据。</li>\n<li>执行引擎，主要内存垃圾回收和运行时代码优化。</li>\n</ul>\n<p>本系列将会从实际应用、面试需要、饭后吹逼等三个角度分别讲解这三大主要模块。同时给自己立个flag到2020年6月能完成本系列文章的全部写作。</p>\n<blockquote>\n<p>有任何不懂或者质疑的地方，都欢迎大家积极留言讨论，留言必回，一起学习进步。</p>\n</blockquote>\n<!-- \n参考文献 https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html\n-->","site":{"data":{}},"excerpt":"","more":"<p>有别于C/C++语言，java虚拟机解放了java程序员，使我们在开发过程中不必负责每个对象的出生和死亡，我们只管用new关键字创建对象，使用对象，对于不在使用的对象所占的内存空间的回收，完全交给java虚拟机来负责。在程序内存管理领域，java虚拟机即让我们避免成为分配对象内存，回收对象内存这样单调工作的奴隶；也让我们丧失了成为掌握对象内存空间管理“生杀大权”的皇帝，内存管理对我们越发的陌生和透明，一旦有内存泄露或者溢出以及涉及到虚拟机方面的性能调优，都会让我们手足无措。《也谈java虚拟机，说点不一样的》系列文章，力求用简单，生动，具体的讲述风格讲解java虚拟机的运作机制，让广大java开发人员得以管窥一二，在实际工作中、在面试找工作时、在饭后和同事吹逼时，都能得心应手，从容应对。鉴于java虚拟机知识体系的庞杂和深邃以及本员能力的限制，系列文章中难免有错误和不足，希望大家多多包涵。</p>\n<p>java虚拟机是一个抽象的计算机。对于程序开发人员来说，我们只需要编写好我们的程序，让不同平台上的java虚拟机完成java代码到不同操作系统计算机指令的转化，通过这种方式java语言实现了其夸平台特性。虽然名为java虚拟机，但是它并不是和java语言强绑定的，java虚拟机只能识别有特定语法格式的class文件，而所有能编译为class文件的语言，都可以在java虚拟机上运行，java虚拟机不是“java语言的虚拟机”而是“多语言的虚拟机”。</p>\n<p>在java虚拟机的发展历史上，曾经有很多的优秀的虚拟机实现。如随着jdk1.0一起发布的Classic VM，号称速度最快的JRockit VM，以及专精Windows平台的Microsoft JVM等。但我们普通程序员用的最多的也是“血统最纯正”虚拟机实现就是Sun公司发布的HotSpot VM，这个系列也以HotSpot虚拟机为蓝本进行讲述的。</p>\n<p>HotSpot虚拟机的组件结构如下：</p>\n<p><img src=\"https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/jvm/post0/HotSpot-architecture.jpg\" alt=\"HotSpot虚拟机组件结构\"> </p>\n<p>HotSpot虚拟机有三大主要模块：</p>\n<ul>\n<li>类加载子系统，主要用来加载class文件，从中获取类信息。</li>\n<li>虚拟机运行时数据区，主要存储程序运行时的各种对象信息和线程栈帧数据。</li>\n<li>执行引擎，主要内存垃圾回收和运行时代码优化。</li>\n</ul>\n<p>本系列将会从实际应用、面试需要、饭后吹逼等三个角度分别讲解这三大主要模块。同时给自己立个flag到2020年6月能完成本系列文章的全部写作。</p>\n<blockquote>\n<p>有任何不懂或者质疑的地方，都欢迎大家积极留言讨论，留言必回，一起学习进步。</p>\n</blockquote>\n<!-- \n参考文献 https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html\n-->"},{"title":"00 spring源码剖析系列说明","date":"2020-05-07T08:46:13.000Z","_content":"\nspring可以说是在web1.0时代java最流行的ssh框架（Struts，Spring，Hibernate) 中三元老的一员，追溯历史也有20年之久了。\n而时至今日只有spring框架以及衍生的项目的开源社区还非常活跃，而且spring框架已经成为企业级 java web项目的标准框架。在其基础上衍生的springboot项目和springcloud更是最近几年非常火爆的web框架。废话不多说，如果想在java技术栈企业级开发走的更深更远，spring源码的阅读和理解是必不可少的一环。\n\n但是spring的知识又是非常庞杂的。盘根错节的功能依赖，犬牙交错接口的调用让即使在web开发多年的老司机在遇到稍微深入一点的spring问题时，如果没有源码阅读经验也很难全身而退！对于小白来说如果遇到问题更是一头雾水。对于老司机和小白来说，源码的阅读都是必不可少的。\n\n博主认为源码阅读无外乎有两种方式:\n\n+ 横向死磕，new 一个ClassPathXmlApplicationContext对象，一行一行的刷代码，debug代码一步一步的走，博主曾经这样尝试过。刷的过程中非常的痛苦，需要极大的耐心和毅力。刷完后没有和业务相结合导致学完了无的放矢，最后投入大量时间，产出比却非常的低。\n\n+ 纵向死磕，spring中帮我们实现了很多功能，拿DI和AOP这两个核心功能来说其每个功能点的实现又可以拆分好多小功能点的实现。比如DI的实现：需要spring能读取classpath中的xml文件或者扫描加载指定包中的特定注解类、需要解决Bean的循环依赖问题、需要解决Bean生命周期管理问题等等，而这些问题还可以继续拆分。拿Bean的循环依赖问题来举例，spring创建Bean的方式有xml文件配置和注解配置两种，Bean1依赖的Bean2的注入方式也有构造器注入和Setter方法注入两种，Setter方法注入的Bean也有@Resource和@Autowired两种方式，Bean1依赖的Bean2和Bean1的类型可能是同一个类型也可能是不同的类型。具体化一个case来说就是spring是如何解决基于@Autowired注解的Setter方法Bean注入（注入的Bean和被注入的Bean类型不同）的循环依赖问题的？我们可以把这个特别具化的case通过阅读源码来解决。而通过源码了解这一个case的运作原理的过程中，我们会多多少少的了解spring其它部分的代码。通过多个具化case的纵向分析，潜移默化的情况下就会对spring有一个整体的把我和了解。但是纵向死磕也有个问题，面对spring庞杂的代码海洋，小白要想找到其具化case相关的代码就如大海捞针一样，最后相关的核心代码没有找到，自己却被淹个半死。\n\n看博主对两种源码阅读方法的着墨程度，也可以知道博主比较推荐第二种 **纵向死磕** 的方式。而本系列文章的目的就是做读者在spring源码这片汪洋大海中航行的灯塔——指明具化case的相关代码所在，同时对其做必要的分析。在此我想说下阅读过程中的一些小经验：\n\n1. 源码阅读要多debug，多思考。显而易见的道理，但也是最重要的原则。\n2. 源码阅读要“心无旁骛”。本系列的每篇文章会针对一个很具化的case做相关源码的分析。在这个过程中难免会涉及到一些不相关的代码，比如源码中某类的A方法的第189行代码到200行代码和一个具化的case相关，读者就不要在A方法的前189行代码做过多研究。spring源码枝繁叶茂，稍微偏离一点主干就会迷失在代码海洋中。可能有读者会有这样的疑惑，不仔细看前189行代码，能理解的了189行到200行代码的意思吗？这个大可放心，对代码的抽离过程由博主给读者做，保证大家能彻彻底底的了解一个具化case的相关源码。通过多个具化case源码的分析，你会不经意间发现，A方法的全部作用你都了解了。\n3. 做难事必有所得。最近在看金一南教授的《苦难辉煌》，感觉其中最让我深刻明白的一个道理就是：做难事必有所得。希望大家在阅读过程中有困难时咬咬牙坚持下来，最后一定会有所收获。\n\n最后，博主也不是spring大神，系列文章难免有瑕疵和纰漏，希望和积极留言讨论，愿诸君共同进步。本系列文章使用的spring的maven坐标如下：\n\n```aidl\n<dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-context</artifactId>\n        <version>5.2.1.RELEASE</version>\n</dependency>\n```\n\n","source":"_posts/java/spring/post0/post0.md","raw":"---\ntitle: 00 spring源码剖析系列说明\ndate: 2020-05-07 16:46:13\ncategories:\n    - spring\n    - spring源码剖析系列\ntags:\n---\n\nspring可以说是在web1.0时代java最流行的ssh框架（Struts，Spring，Hibernate) 中三元老的一员，追溯历史也有20年之久了。\n而时至今日只有spring框架以及衍生的项目的开源社区还非常活跃，而且spring框架已经成为企业级 java web项目的标准框架。在其基础上衍生的springboot项目和springcloud更是最近几年非常火爆的web框架。废话不多说，如果想在java技术栈企业级开发走的更深更远，spring源码的阅读和理解是必不可少的一环。\n\n但是spring的知识又是非常庞杂的。盘根错节的功能依赖，犬牙交错接口的调用让即使在web开发多年的老司机在遇到稍微深入一点的spring问题时，如果没有源码阅读经验也很难全身而退！对于小白来说如果遇到问题更是一头雾水。对于老司机和小白来说，源码的阅读都是必不可少的。\n\n博主认为源码阅读无外乎有两种方式:\n\n+ 横向死磕，new 一个ClassPathXmlApplicationContext对象，一行一行的刷代码，debug代码一步一步的走，博主曾经这样尝试过。刷的过程中非常的痛苦，需要极大的耐心和毅力。刷完后没有和业务相结合导致学完了无的放矢，最后投入大量时间，产出比却非常的低。\n\n+ 纵向死磕，spring中帮我们实现了很多功能，拿DI和AOP这两个核心功能来说其每个功能点的实现又可以拆分好多小功能点的实现。比如DI的实现：需要spring能读取classpath中的xml文件或者扫描加载指定包中的特定注解类、需要解决Bean的循环依赖问题、需要解决Bean生命周期管理问题等等，而这些问题还可以继续拆分。拿Bean的循环依赖问题来举例，spring创建Bean的方式有xml文件配置和注解配置两种，Bean1依赖的Bean2的注入方式也有构造器注入和Setter方法注入两种，Setter方法注入的Bean也有@Resource和@Autowired两种方式，Bean1依赖的Bean2和Bean1的类型可能是同一个类型也可能是不同的类型。具体化一个case来说就是spring是如何解决基于@Autowired注解的Setter方法Bean注入（注入的Bean和被注入的Bean类型不同）的循环依赖问题的？我们可以把这个特别具化的case通过阅读源码来解决。而通过源码了解这一个case的运作原理的过程中，我们会多多少少的了解spring其它部分的代码。通过多个具化case的纵向分析，潜移默化的情况下就会对spring有一个整体的把我和了解。但是纵向死磕也有个问题，面对spring庞杂的代码海洋，小白要想找到其具化case相关的代码就如大海捞针一样，最后相关的核心代码没有找到，自己却被淹个半死。\n\n看博主对两种源码阅读方法的着墨程度，也可以知道博主比较推荐第二种 **纵向死磕** 的方式。而本系列文章的目的就是做读者在spring源码这片汪洋大海中航行的灯塔——指明具化case的相关代码所在，同时对其做必要的分析。在此我想说下阅读过程中的一些小经验：\n\n1. 源码阅读要多debug，多思考。显而易见的道理，但也是最重要的原则。\n2. 源码阅读要“心无旁骛”。本系列的每篇文章会针对一个很具化的case做相关源码的分析。在这个过程中难免会涉及到一些不相关的代码，比如源码中某类的A方法的第189行代码到200行代码和一个具化的case相关，读者就不要在A方法的前189行代码做过多研究。spring源码枝繁叶茂，稍微偏离一点主干就会迷失在代码海洋中。可能有读者会有这样的疑惑，不仔细看前189行代码，能理解的了189行到200行代码的意思吗？这个大可放心，对代码的抽离过程由博主给读者做，保证大家能彻彻底底的了解一个具化case的相关源码。通过多个具化case源码的分析，你会不经意间发现，A方法的全部作用你都了解了。\n3. 做难事必有所得。最近在看金一南教授的《苦难辉煌》，感觉其中最让我深刻明白的一个道理就是：做难事必有所得。希望大家在阅读过程中有困难时咬咬牙坚持下来，最后一定会有所收获。\n\n最后，博主也不是spring大神，系列文章难免有瑕疵和纰漏，希望和积极留言讨论，愿诸君共同进步。本系列文章使用的spring的maven坐标如下：\n\n```aidl\n<dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-context</artifactId>\n        <version>5.2.1.RELEASE</version>\n</dependency>\n```\n\n","slug":"java/spring/post0/post0","published":1,"updated":"2020-05-08T08:20:15.469Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9xz686b000b2kie2efldlag","content":"<p>spring可以说是在web1.0时代java最流行的ssh框架（Struts，Spring，Hibernate) 中三元老的一员，追溯历史也有20年之久了。<br>而时至今日只有spring框架以及衍生的项目的开源社区还非常活跃，而且spring框架已经成为企业级 java web项目的标准框架。在其基础上衍生的springboot项目和springcloud更是最近几年非常火爆的web框架。废话不多说，如果想在java技术栈企业级开发走的更深更远，spring源码的阅读和理解是必不可少的一环。</p>\n<p>但是spring的知识又是非常庞杂的。盘根错节的功能依赖，犬牙交错接口的调用让即使在web开发多年的老司机在遇到稍微深入一点的spring问题时，如果没有源码阅读经验也很难全身而退！对于小白来说如果遇到问题更是一头雾水。对于老司机和小白来说，源码的阅读都是必不可少的。</p>\n<p>博主认为源码阅读无外乎有两种方式:</p>\n<ul>\n<li><p>横向死磕，new 一个ClassPathXmlApplicationContext对象，一行一行的刷代码，debug代码一步一步的走，博主曾经这样尝试过。刷的过程中非常的痛苦，需要极大的耐心和毅力。刷完后没有和业务相结合导致学完了无的放矢，最后投入大量时间，产出比却非常的低。</p>\n</li>\n<li><p>纵向死磕，spring中帮我们实现了很多功能，拿DI和AOP这两个核心功能来说其每个功能点的实现又可以拆分好多小功能点的实现。比如DI的实现：需要spring能读取classpath中的xml文件或者扫描加载指定包中的特定注解类、需要解决Bean的循环依赖问题、需要解决Bean生命周期管理问题等等，而这些问题还可以继续拆分。拿Bean的循环依赖问题来举例，spring创建Bean的方式有xml文件配置和注解配置两种，Bean1依赖的Bean2的注入方式也有构造器注入和Setter方法注入两种，Setter方法注入的Bean也有@Resource和@Autowired两种方式，Bean1依赖的Bean2和Bean1的类型可能是同一个类型也可能是不同的类型。具体化一个case来说就是spring是如何解决基于@Autowired注解的Setter方法Bean注入（注入的Bean和被注入的Bean类型不同）的循环依赖问题的？我们可以把这个特别具化的case通过阅读源码来解决。而通过源码了解这一个case的运作原理的过程中，我们会多多少少的了解spring其它部分的代码。通过多个具化case的纵向分析，潜移默化的情况下就会对spring有一个整体的把我和了解。但是纵向死磕也有个问题，面对spring庞杂的代码海洋，小白要想找到其具化case相关的代码就如大海捞针一样，最后相关的核心代码没有找到，自己却被淹个半死。</p>\n</li>\n</ul>\n<p>看博主对两种源码阅读方法的着墨程度，也可以知道博主比较推荐第二种 <strong>纵向死磕</strong> 的方式。而本系列文章的目的就是做读者在spring源码这片汪洋大海中航行的灯塔——指明具化case的相关代码所在，同时对其做必要的分析。在此我想说下阅读过程中的一些小经验：</p>\n<ol>\n<li>源码阅读要多debug，多思考。显而易见的道理，但也是最重要的原则。</li>\n<li>源码阅读要“心无旁骛”。本系列的每篇文章会针对一个很具化的case做相关源码的分析。在这个过程中难免会涉及到一些不相关的代码，比如源码中某类的A方法的第189行代码到200行代码和一个具化的case相关，读者就不要在A方法的前189行代码做过多研究。spring源码枝繁叶茂，稍微偏离一点主干就会迷失在代码海洋中。可能有读者会有这样的疑惑，不仔细看前189行代码，能理解的了189行到200行代码的意思吗？这个大可放心，对代码的抽离过程由博主给读者做，保证大家能彻彻底底的了解一个具化case的相关源码。通过多个具化case源码的分析，你会不经意间发现，A方法的全部作用你都了解了。</li>\n<li>做难事必有所得。最近在看金一南教授的《苦难辉煌》，感觉其中最让我深刻明白的一个道理就是：做难事必有所得。希望大家在阅读过程中有困难时咬咬牙坚持下来，最后一定会有所收获。</li>\n</ol>\n<p>最后，博主也不是spring大神，系列文章难免有瑕疵和纰漏，希望和积极留言讨论，愿诸君共同进步。本系列文章使用的spring的maven坐标如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class=\"line\">        &lt;version&gt;5.2.1.RELEASE&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<p>spring可以说是在web1.0时代java最流行的ssh框架（Struts，Spring，Hibernate) 中三元老的一员，追溯历史也有20年之久了。<br>而时至今日只有spring框架以及衍生的项目的开源社区还非常活跃，而且spring框架已经成为企业级 java web项目的标准框架。在其基础上衍生的springboot项目和springcloud更是最近几年非常火爆的web框架。废话不多说，如果想在java技术栈企业级开发走的更深更远，spring源码的阅读和理解是必不可少的一环。</p>\n<p>但是spring的知识又是非常庞杂的。盘根错节的功能依赖，犬牙交错接口的调用让即使在web开发多年的老司机在遇到稍微深入一点的spring问题时，如果没有源码阅读经验也很难全身而退！对于小白来说如果遇到问题更是一头雾水。对于老司机和小白来说，源码的阅读都是必不可少的。</p>\n<p>博主认为源码阅读无外乎有两种方式:</p>\n<ul>\n<li><p>横向死磕，new 一个ClassPathXmlApplicationContext对象，一行一行的刷代码，debug代码一步一步的走，博主曾经这样尝试过。刷的过程中非常的痛苦，需要极大的耐心和毅力。刷完后没有和业务相结合导致学完了无的放矢，最后投入大量时间，产出比却非常的低。</p>\n</li>\n<li><p>纵向死磕，spring中帮我们实现了很多功能，拿DI和AOP这两个核心功能来说其每个功能点的实现又可以拆分好多小功能点的实现。比如DI的实现：需要spring能读取classpath中的xml文件或者扫描加载指定包中的特定注解类、需要解决Bean的循环依赖问题、需要解决Bean生命周期管理问题等等，而这些问题还可以继续拆分。拿Bean的循环依赖问题来举例，spring创建Bean的方式有xml文件配置和注解配置两种，Bean1依赖的Bean2的注入方式也有构造器注入和Setter方法注入两种，Setter方法注入的Bean也有@Resource和@Autowired两种方式，Bean1依赖的Bean2和Bean1的类型可能是同一个类型也可能是不同的类型。具体化一个case来说就是spring是如何解决基于@Autowired注解的Setter方法Bean注入（注入的Bean和被注入的Bean类型不同）的循环依赖问题的？我们可以把这个特别具化的case通过阅读源码来解决。而通过源码了解这一个case的运作原理的过程中，我们会多多少少的了解spring其它部分的代码。通过多个具化case的纵向分析，潜移默化的情况下就会对spring有一个整体的把我和了解。但是纵向死磕也有个问题，面对spring庞杂的代码海洋，小白要想找到其具化case相关的代码就如大海捞针一样，最后相关的核心代码没有找到，自己却被淹个半死。</p>\n</li>\n</ul>\n<p>看博主对两种源码阅读方法的着墨程度，也可以知道博主比较推荐第二种 <strong>纵向死磕</strong> 的方式。而本系列文章的目的就是做读者在spring源码这片汪洋大海中航行的灯塔——指明具化case的相关代码所在，同时对其做必要的分析。在此我想说下阅读过程中的一些小经验：</p>\n<ol>\n<li>源码阅读要多debug，多思考。显而易见的道理，但也是最重要的原则。</li>\n<li>源码阅读要“心无旁骛”。本系列的每篇文章会针对一个很具化的case做相关源码的分析。在这个过程中难免会涉及到一些不相关的代码，比如源码中某类的A方法的第189行代码到200行代码和一个具化的case相关，读者就不要在A方法的前189行代码做过多研究。spring源码枝繁叶茂，稍微偏离一点主干就会迷失在代码海洋中。可能有读者会有这样的疑惑，不仔细看前189行代码，能理解的了189行到200行代码的意思吗？这个大可放心，对代码的抽离过程由博主给读者做，保证大家能彻彻底底的了解一个具化case的相关源码。通过多个具化case源码的分析，你会不经意间发现，A方法的全部作用你都了解了。</li>\n<li>做难事必有所得。最近在看金一南教授的《苦难辉煌》，感觉其中最让我深刻明白的一个道理就是：做难事必有所得。希望大家在阅读过程中有困难时咬咬牙坚持下来，最后一定会有所收获。</li>\n</ol>\n<p>最后，博主也不是spring大神，系列文章难免有瑕疵和纰漏，希望和积极留言讨论，愿诸君共同进步。本系列文章使用的spring的maven坐标如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class=\"line\">        &lt;version&gt;5.2.1.RELEASE&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"01最全面的jvm运行时数据区讲解","date":"2019-11-09T08:36:13.000Z","_content":"\n# 最全面的jvm运行时数据区讲解\n\n\n记得有位大佬曾经说过这样一句话：\n> 如欲征服java，必须征服java虚拟机，如欲征服java虚拟机，需先征服java虚拟机内存模型。\n\njava虚拟机内存，是java虚拟机进行对象内存空间分配、垃圾回收的活动室，只有先了解java虚拟机内存才能在此基础上进一步了解对象内存分配、垃圾回收等活动。有别于真实物理机硬盘、主存、缓存、寄存器的存储模型，java虚拟机内存模型按照其存储模块负责的数据类型将其划分为如下图所示的模型：\n\n![java虚拟机内存模型](https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/jvm/post1/jvm_memory_model.png)\n                    \n\n## 堆\n堆是各个线程共享的内存区域，是java对象内存分配和垃圾回收的主战场，几乎所有的对象都是在堆中创建的。根据*Java虚拟机规范（Java Virtual Machine Specification）* 的规则，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。如果在堆中没有内存空间完成Java对象的内存分配时，将会抛出OutOfMemoryError（一下简称OOM）。\n\n关于堆的最常见虚拟机参数：\n+ -Xms ：表示虚拟机堆的最小值，如 -Xms10M 表示堆的最小值为10MB\n+ -Xmx ：表示虚拟机堆的最大值，如果 -Xmx100M 表示堆的最大值为100MB\n\n\n```\n/**\n * 设置虚拟机参数为：-Xms5M -Xmx5M\n */\npublic class HeapOOM {\n    public static void main(String[] args) {\n        ArrayList<Byte[]> bytes = new ArrayList<>();\n        for (; ; ) {\n            Byte[] _1M = new Byte[1024 * 1024];\n            bytes.add(_1M);\n        }\n\n    }\n}\n```\n\n执行结果:\n\n```\nException in thread \"main\" java.lang.OutOfMemoryError: Java heap space\n\tat jvm.post1.HeapOOM.main(HeapOOM.java:15)\n```\n\n“Java heap space”类型的OOM表示堆中没有可用的内存空间，具体到本例子中就是在大小为5M的堆中没有可用空间分配给大小为1M的数组对象。再来看一个例子：\n\n```\n/**\n * @createtime 2019/11/2\n * 虚拟机参数 -Xms5M -Xmx5M \n*/ \npublic class HeapOOM1 {\n    public static void main(String[] args) {\n        ArrayList<Object> heapOOM1s = new ArrayList<>();\n        for (; ; ) {\n            heapOOM1s.add(new Object());\n        }\n    }\n}\n```\n\n执行结果:\n\n```\nException in thread \"main\" java.lang.OutOfMemoryError: GC overhead limit exceeded\n\tat jvm.post1.HeapOOM1.main(HeapOOM1.java:14)\n```\n\n“GC overhead limit exceeded” 类型的OOM是在jdk6后引入的一种新的错误类型。发生错误的原因是虚拟机用了大量的时间进行GC但是只释放了较小的空间，这是虚拟机的一种保护机制。具体到本例子中就是虚拟机在GC时没有能回收内存空间，浪费了时间却没有收获，所以就抛出了这个错误。可以用 *-XX:-UseGCOverheadLimit*参数禁用这个检查，但解决不了内存问题，只是把错误的信息延后，替换成 java.lang.OutOfMemoryError: Java heap space错误。\n\n## 方法区\n方法区和堆一样，也是各个线程共享的内存区域，它用来存储已经被虚拟机加载的类信息、常量池、静态变量等。方法区是jdk5到jdk8变化较大的java虚拟机内存区域。在jdk5和jdk6时，常量池是存在方法区的：\n\n![jdk5和jdk6](https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/jvm/post1/jvm_memory_model_1.5.png)\n\n\n而从jdk7及其以后的版本，常量池被放到了堆里面：\n\n![jdk7](https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/jvm/post1/jvm_memory_model_1.7.png)\n\n常量池就是java语言系统级别的缓存，目的是让程序在运行过程中速度更快，更节省内存空间，java的8种基本数据类型外加String类型，共9种类型都有对应的常量池。这些类型的对象不可能全都放到常量池中存储，因此不同的类型有不同的存储策略，具体到String类型的对象来说，有如下三条规则：\n\n+ 用双引号创建的对象放在常量池中，如 \"Hello\"，\"Jvm\"这种。\n+ 用双引号创建的对象相加产生的对象放在常量池，如 *String s = \"Hello\" + \"Jvm\";*，这里的s对象就是放在常量池中的。\n+ 调用String对象的intern方法会返回一个存放在常量池中的String对象,且两个对象内容相同。\n\n再回到本篇的主题上，因为常量池位置的变化，在不同的jdk版本下，下面代码的执行结果是不一样的：\n\n```\npublic class ConstantsPool {\n    public static void main(String[] args) {\n\n        String s = new String(\"Hello\") + new String(\"Jvm\"); //1\n        String s1 = s.intern();  //2\n        System.out.println(s == s1); //jdk5和jdk6中返回false，jdk7及其以上版本返回true。\n    }\n}\n\n```\n\n\n\n在jdk7之前，程序在执行//2处代码之前常量池中没有\"HelloJvm\"这个字符串常量，//2处代码执行时，程序会在常量池中创建一个\"HelloJvm\"的字符串对象s1并返回，而常量池是在方法区的。那一个在堆中的s对象和方法区中的s1对象比较地址是否相同，当然会得到false。\n在jdk7及其以后的版本，程序在执行//2出代码时，发现常量池中同样没有\"HelloJvm\"这个对象，但因为常量池已经迁移到堆中，常量池不需要存储一个对象了，程序只是简单的把s这个对象的引用在常量池中存储了，此时s和s1指向的是同一个对象，结果当然是true。\n\n上面简单介绍了jdk7中常量池的变化，而在jdk8中方法整个方法区被放到了物理机的本地内存,同时也更名为元空间（MetaSpace）：\n\n![jdk8](https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/jvm/post1/jvm_memory_model_1.8.png)\n\n\njdk8及其以后的版本，元空间直接使用物理机的本地内存，在不加限制的情况下其最大值为本地内存的最大可用值。考虑到物理机上可能部署其它的应用服务，通常会给元空间加一个大小限制。\n\n关于元空间最常见的虚拟机参数是：\n+ -XX:MetaspaceSize : 表示虚拟机元空间发生MetadataGC时的初始阈值,如 -XX:MetaspaceSize=10M 表示元空间在第一次到大10M时，会发生一次MetadataGC。\n+ -XX:MaxMetaspaceSize ： 表示虚拟机元空间的最大值为MaxMetaspaceSize，如 -XX:MaxMetaspaceSize=15M 表示元空间的最大值为15M，再大就会发生OOM异常。\n\n关于元空间的的内存溢出模拟，我们需要借助CGLib来动态的创建类，先引入如下maven依赖：\n\n```\n<dependency>\n    <groupId>cglib</groupId>\n    <artifactId>cglib-nodep</artifactId>\n    <version>3.3.0</version>\n</dependency>\n\n```\n\n具体代码如下：\n\n```\n/**\n * 虚拟机参数 -XX:MaxMetaspaceSize=10M \n * @description 元空间内存溢出\n */\npublic class MetaSpaceOOM {\n    public static void main(String[] args) {\n        BeanGenerator beanGenerator = new BeanGenerator();\n        List<Class> classes = new ArrayList<>();\n        for (int i=0; i<1000000000L;i++ ) {\n\n            beanGenerator.addProperty(\"id\"+i, Integer.class);\n            Object aClass = beanGenerator.createClass();\n            classes.add((Class) aClass);\n\n        }\n    }\n}\n```\n\n 执行结果为：\n\n```aidl\nException in thread \"main\" java.lang.IllegalStateException: Unable to load cache item\n\tat net.sf.cglib.core.internal.LoadingCache.createEntry(LoadingCache.java:79)\n\tat net.sf.cglib.core.internal.LoadingCache.get(LoadingCache.java:34)\n\tat net.sf.cglib.core.AbstractClassGenerator$ClassLoaderData.get(AbstractClassGenerator.java:119)\n\tat net.sf.cglib.core.AbstractClassGenerator.create(AbstractClassGenerator.java:294)\n\tat net.sf.cglib.beans.BeanGenerator.createHelper(BeanGenerator.java:94)\n\tat net.sf.cglib.beans.BeanGenerator.createClass(BeanGenerator.java:85)\n\tat jvm.post1.MetaSpaceOOM.main(MetaSpaceOOM.java:19)\nCaused by: java.lang.OutOfMemoryError: Metaspace\n\tat net.sf.cglib.core.AbstractClassGenerator.generate(AbstractClassGenerator.java:348)\n\tat net.sf.cglib.core.AbstractClassGenerator$ClassLoaderData$3.apply(AbstractClassGenerator.java:96)\n\tat net.sf.cglib.core.AbstractClassGenerator$ClassLoaderData$3.apply(AbstractClassGenerator.java:94)\n\tat net.sf.cglib.core.internal.LoadingCache$2.call(LoadingCache.java:54)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat net.sf.cglib.core.internal.LoadingCache.createEntry(LoadingCache.java:61)\n\t... 6 more\n```\n\n可以看到，引起IllegalStateException异常的正是因为\"Metaspace\"类型的OOM错误。具体原因为BeanGenerator对象通过createClass方法不断创建新的类，导致最大内存为10MB的元空间没办法存储类的信息而抛出异常。\n\n## 虚拟机栈和本地方法栈\n\n虚拟机栈和本地方法栈，都是线程私有的，主要用来存储在线程运行过程中的局部变量、操作数栈、方法出入口等信息，这些信息是以栈帧的形式存储的，虚拟机栈和本地方法栈的区别就是一个存储java方法运行时的栈帧数据一个存储本地方法（native 关键字修饰的方法）运行时的栈帧数据。由于都是存储栈帧数据，两种栈的区别不是很大，甚至在HotSpot虚拟机中，直接把这两个合二为一，所以本小节把这两种栈合起来说。java程序在运行时的栈数据结构如下图：\n\n![运行时栈结构](https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/jvm/post1/stack-model.jpg)  \n\n\n在介绍堆时，我们曾说过几乎所有的对象都是在堆中创建的，这几乎中的特例就来自于栈，对象是可以在栈上创建，我们称为栈上分配。\n\n```\n\n/**\n * 执行栈上分配的虚拟机参数  -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -Xmx10M\n * 不执行栈上分配的虚拟机参数  -XX:-DoEscapeAnalysis -XX:+EliminateAllocations -Xmx10M\n * \n * 参数说明：\n * DoEscapeAnalysis  ： 逃逸分析，对于本例来说逃逸分析可以判断出//1处创建的对象是否会被本方法外的方法获取到。\n * EliminateAllocations ： 标量替换，对于本例来说，在逃逸分析的帮助下发现//1出的User对象不会逃逸出方法allo，那么消除User对象的堆内存分配，把它的字段改为一个个独立的局部变量（本例中是int类型的标量）存储在线程的栈中。\n * 要模拟栈上分配，需要逃逸分析和标量替换两个功能都是开启的。\n * @description 栈上分配\n */\npublic class StackAllocation {\n    static class User{\n        int i;\n    }\n\n    public static void allo() {\n        User user = new User(); //1\n        user.i = 4;\n    }\n\n    public static void main(String[] args) {\n        long startTime = System.currentTimeMillis();\n        for (int i = 0; i < 100000000L; i++) {\n            allo();\n        }\n        long endTime = System.currentTimeMillis();\n        System.out.println(endTime - startTime);\n    }\n}\n\n```\n\n用不同的虚拟机参数执行上面的代码时，会发现同样执行1亿次方法调用，栈上分配的执行时间明显比非栈上分配的执行时间短。简单的解释就是1亿个的User对象不是被分配在堆上，这样就避免了频繁的GC，对性能自然有很大提升。\n\n与栈相关的虚拟机参数主要有：\n+ -Xss : 设置java线程栈的大小，如 -Xss100k 表示每个java线程栈的大小为100k。\n\n线程栈是用来存方法的栈帧的。线程栈越大其能调用的方法深度越大，运行如下代码可以印证此观点：\n\n```\n\n/**\n * 虚拟机参数 -Xss1000K\n * @description 模拟栈内存溢出\n */\npublic class StackOverFlowOOM {\n    private static int num = 0;\n\n    public static void loop(){\n        num++;\n        loop();\n    }\n\n    public static void main(String[] args) {\n        try {\n            loop();\n        } catch (Throwable e) {\n            e.printStackTrace();\n            System.out.println(num);\n        }\n    }\n}\n\n```\n\n当Xss的值越大时，程序中的num变量在栈溢出异常时的值越大。jdk8中如果不指定Xss参数的大小，那么其默认值为1MB，这也从内存角度印证线程是一种昂贵的资源，即使简单的创建一个线程而不分配给其处理任务，其也要占用一些内存空间。\n\n\n## 程序计数器\n\n程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器，因为操作系统会分配给各个线程一些时间片来运行，当时间片用完后，就需要有程序计数器记录线程执行的位置，用来在线程重新获得时间片时能恢复到原来的执行位置。从程序计数器的用途得知，程序程序计数器也是线程私有的，而且也是唯一一个不会有OOM异常的虚拟机内存区域。\n\n\n\n## 篇尾小节\n\n本篇主要简绍了java虚拟机在运行时的各个内存区域，简单介绍了它们的作用和内存溢出的方式。\n\n\n\n\n> 有任何不懂或者质疑的地方，都欢迎大家积极留言讨论，留言必回，一起学习进步。\n\n\n\n<!--\n参考文献 ：\nhttp://lovestblog.cn/blog/2016/10/29/metaspace/ \n-->","source":"_posts/java/jvm/post1/post1.md","raw":"---\ntitle: 01最全面的jvm运行时数据区讲解\ndate: 2019-11-09 16:36:13\ncategories:\n    - jvm\n    - java虚拟机，说点不一样的\ntags:\n---\n\n# 最全面的jvm运行时数据区讲解\n\n\n记得有位大佬曾经说过这样一句话：\n> 如欲征服java，必须征服java虚拟机，如欲征服java虚拟机，需先征服java虚拟机内存模型。\n\njava虚拟机内存，是java虚拟机进行对象内存空间分配、垃圾回收的活动室，只有先了解java虚拟机内存才能在此基础上进一步了解对象内存分配、垃圾回收等活动。有别于真实物理机硬盘、主存、缓存、寄存器的存储模型，java虚拟机内存模型按照其存储模块负责的数据类型将其划分为如下图所示的模型：\n\n![java虚拟机内存模型](https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/jvm/post1/jvm_memory_model.png)\n                    \n\n## 堆\n堆是各个线程共享的内存区域，是java对象内存分配和垃圾回收的主战场，几乎所有的对象都是在堆中创建的。根据*Java虚拟机规范（Java Virtual Machine Specification）* 的规则，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。如果在堆中没有内存空间完成Java对象的内存分配时，将会抛出OutOfMemoryError（一下简称OOM）。\n\n关于堆的最常见虚拟机参数：\n+ -Xms ：表示虚拟机堆的最小值，如 -Xms10M 表示堆的最小值为10MB\n+ -Xmx ：表示虚拟机堆的最大值，如果 -Xmx100M 表示堆的最大值为100MB\n\n\n```\n/**\n * 设置虚拟机参数为：-Xms5M -Xmx5M\n */\npublic class HeapOOM {\n    public static void main(String[] args) {\n        ArrayList<Byte[]> bytes = new ArrayList<>();\n        for (; ; ) {\n            Byte[] _1M = new Byte[1024 * 1024];\n            bytes.add(_1M);\n        }\n\n    }\n}\n```\n\n执行结果:\n\n```\nException in thread \"main\" java.lang.OutOfMemoryError: Java heap space\n\tat jvm.post1.HeapOOM.main(HeapOOM.java:15)\n```\n\n“Java heap space”类型的OOM表示堆中没有可用的内存空间，具体到本例子中就是在大小为5M的堆中没有可用空间分配给大小为1M的数组对象。再来看一个例子：\n\n```\n/**\n * @createtime 2019/11/2\n * 虚拟机参数 -Xms5M -Xmx5M \n*/ \npublic class HeapOOM1 {\n    public static void main(String[] args) {\n        ArrayList<Object> heapOOM1s = new ArrayList<>();\n        for (; ; ) {\n            heapOOM1s.add(new Object());\n        }\n    }\n}\n```\n\n执行结果:\n\n```\nException in thread \"main\" java.lang.OutOfMemoryError: GC overhead limit exceeded\n\tat jvm.post1.HeapOOM1.main(HeapOOM1.java:14)\n```\n\n“GC overhead limit exceeded” 类型的OOM是在jdk6后引入的一种新的错误类型。发生错误的原因是虚拟机用了大量的时间进行GC但是只释放了较小的空间，这是虚拟机的一种保护机制。具体到本例子中就是虚拟机在GC时没有能回收内存空间，浪费了时间却没有收获，所以就抛出了这个错误。可以用 *-XX:-UseGCOverheadLimit*参数禁用这个检查，但解决不了内存问题，只是把错误的信息延后，替换成 java.lang.OutOfMemoryError: Java heap space错误。\n\n## 方法区\n方法区和堆一样，也是各个线程共享的内存区域，它用来存储已经被虚拟机加载的类信息、常量池、静态变量等。方法区是jdk5到jdk8变化较大的java虚拟机内存区域。在jdk5和jdk6时，常量池是存在方法区的：\n\n![jdk5和jdk6](https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/jvm/post1/jvm_memory_model_1.5.png)\n\n\n而从jdk7及其以后的版本，常量池被放到了堆里面：\n\n![jdk7](https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/jvm/post1/jvm_memory_model_1.7.png)\n\n常量池就是java语言系统级别的缓存，目的是让程序在运行过程中速度更快，更节省内存空间，java的8种基本数据类型外加String类型，共9种类型都有对应的常量池。这些类型的对象不可能全都放到常量池中存储，因此不同的类型有不同的存储策略，具体到String类型的对象来说，有如下三条规则：\n\n+ 用双引号创建的对象放在常量池中，如 \"Hello\"，\"Jvm\"这种。\n+ 用双引号创建的对象相加产生的对象放在常量池，如 *String s = \"Hello\" + \"Jvm\";*，这里的s对象就是放在常量池中的。\n+ 调用String对象的intern方法会返回一个存放在常量池中的String对象,且两个对象内容相同。\n\n再回到本篇的主题上，因为常量池位置的变化，在不同的jdk版本下，下面代码的执行结果是不一样的：\n\n```\npublic class ConstantsPool {\n    public static void main(String[] args) {\n\n        String s = new String(\"Hello\") + new String(\"Jvm\"); //1\n        String s1 = s.intern();  //2\n        System.out.println(s == s1); //jdk5和jdk6中返回false，jdk7及其以上版本返回true。\n    }\n}\n\n```\n\n\n\n在jdk7之前，程序在执行//2处代码之前常量池中没有\"HelloJvm\"这个字符串常量，//2处代码执行时，程序会在常量池中创建一个\"HelloJvm\"的字符串对象s1并返回，而常量池是在方法区的。那一个在堆中的s对象和方法区中的s1对象比较地址是否相同，当然会得到false。\n在jdk7及其以后的版本，程序在执行//2出代码时，发现常量池中同样没有\"HelloJvm\"这个对象，但因为常量池已经迁移到堆中，常量池不需要存储一个对象了，程序只是简单的把s这个对象的引用在常量池中存储了，此时s和s1指向的是同一个对象，结果当然是true。\n\n上面简单介绍了jdk7中常量池的变化，而在jdk8中方法整个方法区被放到了物理机的本地内存,同时也更名为元空间（MetaSpace）：\n\n![jdk8](https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/jvm/post1/jvm_memory_model_1.8.png)\n\n\njdk8及其以后的版本，元空间直接使用物理机的本地内存，在不加限制的情况下其最大值为本地内存的最大可用值。考虑到物理机上可能部署其它的应用服务，通常会给元空间加一个大小限制。\n\n关于元空间最常见的虚拟机参数是：\n+ -XX:MetaspaceSize : 表示虚拟机元空间发生MetadataGC时的初始阈值,如 -XX:MetaspaceSize=10M 表示元空间在第一次到大10M时，会发生一次MetadataGC。\n+ -XX:MaxMetaspaceSize ： 表示虚拟机元空间的最大值为MaxMetaspaceSize，如 -XX:MaxMetaspaceSize=15M 表示元空间的最大值为15M，再大就会发生OOM异常。\n\n关于元空间的的内存溢出模拟，我们需要借助CGLib来动态的创建类，先引入如下maven依赖：\n\n```\n<dependency>\n    <groupId>cglib</groupId>\n    <artifactId>cglib-nodep</artifactId>\n    <version>3.3.0</version>\n</dependency>\n\n```\n\n具体代码如下：\n\n```\n/**\n * 虚拟机参数 -XX:MaxMetaspaceSize=10M \n * @description 元空间内存溢出\n */\npublic class MetaSpaceOOM {\n    public static void main(String[] args) {\n        BeanGenerator beanGenerator = new BeanGenerator();\n        List<Class> classes = new ArrayList<>();\n        for (int i=0; i<1000000000L;i++ ) {\n\n            beanGenerator.addProperty(\"id\"+i, Integer.class);\n            Object aClass = beanGenerator.createClass();\n            classes.add((Class) aClass);\n\n        }\n    }\n}\n```\n\n 执行结果为：\n\n```aidl\nException in thread \"main\" java.lang.IllegalStateException: Unable to load cache item\n\tat net.sf.cglib.core.internal.LoadingCache.createEntry(LoadingCache.java:79)\n\tat net.sf.cglib.core.internal.LoadingCache.get(LoadingCache.java:34)\n\tat net.sf.cglib.core.AbstractClassGenerator$ClassLoaderData.get(AbstractClassGenerator.java:119)\n\tat net.sf.cglib.core.AbstractClassGenerator.create(AbstractClassGenerator.java:294)\n\tat net.sf.cglib.beans.BeanGenerator.createHelper(BeanGenerator.java:94)\n\tat net.sf.cglib.beans.BeanGenerator.createClass(BeanGenerator.java:85)\n\tat jvm.post1.MetaSpaceOOM.main(MetaSpaceOOM.java:19)\nCaused by: java.lang.OutOfMemoryError: Metaspace\n\tat net.sf.cglib.core.AbstractClassGenerator.generate(AbstractClassGenerator.java:348)\n\tat net.sf.cglib.core.AbstractClassGenerator$ClassLoaderData$3.apply(AbstractClassGenerator.java:96)\n\tat net.sf.cglib.core.AbstractClassGenerator$ClassLoaderData$3.apply(AbstractClassGenerator.java:94)\n\tat net.sf.cglib.core.internal.LoadingCache$2.call(LoadingCache.java:54)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat net.sf.cglib.core.internal.LoadingCache.createEntry(LoadingCache.java:61)\n\t... 6 more\n```\n\n可以看到，引起IllegalStateException异常的正是因为\"Metaspace\"类型的OOM错误。具体原因为BeanGenerator对象通过createClass方法不断创建新的类，导致最大内存为10MB的元空间没办法存储类的信息而抛出异常。\n\n## 虚拟机栈和本地方法栈\n\n虚拟机栈和本地方法栈，都是线程私有的，主要用来存储在线程运行过程中的局部变量、操作数栈、方法出入口等信息，这些信息是以栈帧的形式存储的，虚拟机栈和本地方法栈的区别就是一个存储java方法运行时的栈帧数据一个存储本地方法（native 关键字修饰的方法）运行时的栈帧数据。由于都是存储栈帧数据，两种栈的区别不是很大，甚至在HotSpot虚拟机中，直接把这两个合二为一，所以本小节把这两种栈合起来说。java程序在运行时的栈数据结构如下图：\n\n![运行时栈结构](https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/jvm/post1/stack-model.jpg)  \n\n\n在介绍堆时，我们曾说过几乎所有的对象都是在堆中创建的，这几乎中的特例就来自于栈，对象是可以在栈上创建，我们称为栈上分配。\n\n```\n\n/**\n * 执行栈上分配的虚拟机参数  -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -Xmx10M\n * 不执行栈上分配的虚拟机参数  -XX:-DoEscapeAnalysis -XX:+EliminateAllocations -Xmx10M\n * \n * 参数说明：\n * DoEscapeAnalysis  ： 逃逸分析，对于本例来说逃逸分析可以判断出//1处创建的对象是否会被本方法外的方法获取到。\n * EliminateAllocations ： 标量替换，对于本例来说，在逃逸分析的帮助下发现//1出的User对象不会逃逸出方法allo，那么消除User对象的堆内存分配，把它的字段改为一个个独立的局部变量（本例中是int类型的标量）存储在线程的栈中。\n * 要模拟栈上分配，需要逃逸分析和标量替换两个功能都是开启的。\n * @description 栈上分配\n */\npublic class StackAllocation {\n    static class User{\n        int i;\n    }\n\n    public static void allo() {\n        User user = new User(); //1\n        user.i = 4;\n    }\n\n    public static void main(String[] args) {\n        long startTime = System.currentTimeMillis();\n        for (int i = 0; i < 100000000L; i++) {\n            allo();\n        }\n        long endTime = System.currentTimeMillis();\n        System.out.println(endTime - startTime);\n    }\n}\n\n```\n\n用不同的虚拟机参数执行上面的代码时，会发现同样执行1亿次方法调用，栈上分配的执行时间明显比非栈上分配的执行时间短。简单的解释就是1亿个的User对象不是被分配在堆上，这样就避免了频繁的GC，对性能自然有很大提升。\n\n与栈相关的虚拟机参数主要有：\n+ -Xss : 设置java线程栈的大小，如 -Xss100k 表示每个java线程栈的大小为100k。\n\n线程栈是用来存方法的栈帧的。线程栈越大其能调用的方法深度越大，运行如下代码可以印证此观点：\n\n```\n\n/**\n * 虚拟机参数 -Xss1000K\n * @description 模拟栈内存溢出\n */\npublic class StackOverFlowOOM {\n    private static int num = 0;\n\n    public static void loop(){\n        num++;\n        loop();\n    }\n\n    public static void main(String[] args) {\n        try {\n            loop();\n        } catch (Throwable e) {\n            e.printStackTrace();\n            System.out.println(num);\n        }\n    }\n}\n\n```\n\n当Xss的值越大时，程序中的num变量在栈溢出异常时的值越大。jdk8中如果不指定Xss参数的大小，那么其默认值为1MB，这也从内存角度印证线程是一种昂贵的资源，即使简单的创建一个线程而不分配给其处理任务，其也要占用一些内存空间。\n\n\n## 程序计数器\n\n程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器，因为操作系统会分配给各个线程一些时间片来运行，当时间片用完后，就需要有程序计数器记录线程执行的位置，用来在线程重新获得时间片时能恢复到原来的执行位置。从程序计数器的用途得知，程序程序计数器也是线程私有的，而且也是唯一一个不会有OOM异常的虚拟机内存区域。\n\n\n\n## 篇尾小节\n\n本篇主要简绍了java虚拟机在运行时的各个内存区域，简单介绍了它们的作用和内存溢出的方式。\n\n\n\n\n> 有任何不懂或者质疑的地方，都欢迎大家积极留言讨论，留言必回，一起学习进步。\n\n\n\n<!--\n参考文献 ：\nhttp://lovestblog.cn/blog/2016/10/29/metaspace/ \n-->","slug":"java/jvm/post1/post1","published":1,"updated":"2020-01-30T09:04:16.389Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9xz686g000n2kie114ec6ou","content":"<h1 id=\"最全面的jvm运行时数据区讲解\"><a href=\"#最全面的jvm运行时数据区讲解\" class=\"headerlink\" title=\"最全面的jvm运行时数据区讲解\"></a>最全面的jvm运行时数据区讲解</h1><p>记得有位大佬曾经说过这样一句话：</p>\n<blockquote>\n<p>如欲征服java，必须征服java虚拟机，如欲征服java虚拟机，需先征服java虚拟机内存模型。</p>\n</blockquote>\n<p>java虚拟机内存，是java虚拟机进行对象内存空间分配、垃圾回收的活动室，只有先了解java虚拟机内存才能在此基础上进一步了解对象内存分配、垃圾回收等活动。有别于真实物理机硬盘、主存、缓存、寄存器的存储模型，java虚拟机内存模型按照其存储模块负责的数据类型将其划分为如下图所示的模型：</p>\n<p><img src=\"https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/jvm/post1/jvm_memory_model.png\" alt=\"java虚拟机内存模型\"></p>\n<h2 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h2><p>堆是各个线程共享的内存区域，是java对象内存分配和垃圾回收的主战场，几乎所有的对象都是在堆中创建的。根据<em>Java虚拟机规范（Java Virtual Machine Specification）</em> 的规则，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。如果在堆中没有内存空间完成Java对象的内存分配时，将会抛出OutOfMemoryError（一下简称OOM）。</p>\n<p>关于堆的最常见虚拟机参数：</p>\n<ul>\n<li>-Xms ：表示虚拟机堆的最小值，如 -Xms10M 表示堆的最小值为10MB</li>\n<li>-Xmx ：表示虚拟机堆的最大值，如果 -Xmx100M 表示堆的最大值为100MB</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 设置虚拟机参数为：-Xms5M -Xmx5M</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class HeapOOM &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        ArrayList&lt;Byte[]&gt; bytes = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        for (; ; ) &#123;</span><br><span class=\"line\">            Byte[] _1M = new Byte[1024 * 1024];</span><br><span class=\"line\">            bytes.add(_1M);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>执行结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br><span class=\"line\">\tat jvm.post1.HeapOOM.main(HeapOOM.java:15)</span><br></pre></td></tr></table></figure>\n\n<p>“Java heap space”类型的OOM表示堆中没有可用的内存空间，具体到本例子中就是在大小为5M的堆中没有可用空间分配给大小为1M的数组对象。再来看一个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * @createtime 2019/11/2</span><br><span class=\"line\"> * 虚拟机参数 -Xms5M -Xmx5M </span><br><span class=\"line\">*/ </span><br><span class=\"line\">public class HeapOOM1 &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        ArrayList&lt;Object&gt; heapOOM1s = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        for (; ; ) &#123;</span><br><span class=\"line\">            heapOOM1s.add(new Object());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>执行结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: GC overhead limit exceeded</span><br><span class=\"line\">\tat jvm.post1.HeapOOM1.main(HeapOOM1.java:14)</span><br></pre></td></tr></table></figure>\n\n<p>“GC overhead limit exceeded” 类型的OOM是在jdk6后引入的一种新的错误类型。发生错误的原因是虚拟机用了大量的时间进行GC但是只释放了较小的空间，这是虚拟机的一种保护机制。具体到本例子中就是虚拟机在GC时没有能回收内存空间，浪费了时间却没有收获，所以就抛出了这个错误。可以用 <em>-XX:-UseGCOverheadLimit</em>参数禁用这个检查，但解决不了内存问题，只是把错误的信息延后，替换成 java.lang.OutOfMemoryError: Java heap space错误。</p>\n<h2 id=\"方法区\"><a href=\"#方法区\" class=\"headerlink\" title=\"方法区\"></a>方法区</h2><p>方法区和堆一样，也是各个线程共享的内存区域，它用来存储已经被虚拟机加载的类信息、常量池、静态变量等。方法区是jdk5到jdk8变化较大的java虚拟机内存区域。在jdk5和jdk6时，常量池是存在方法区的：</p>\n<p><img src=\"https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/jvm/post1/jvm_memory_model_1.5.png\" alt=\"jdk5和jdk6\"></p>\n<p>而从jdk7及其以后的版本，常量池被放到了堆里面：</p>\n<p><img src=\"https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/jvm/post1/jvm_memory_model_1.7.png\" alt=\"jdk7\"></p>\n<p>常量池就是java语言系统级别的缓存，目的是让程序在运行过程中速度更快，更节省内存空间，java的8种基本数据类型外加String类型，共9种类型都有对应的常量池。这些类型的对象不可能全都放到常量池中存储，因此不同的类型有不同的存储策略，具体到String类型的对象来说，有如下三条规则：</p>\n<ul>\n<li>用双引号创建的对象放在常量池中，如 “Hello”，”Jvm”这种。</li>\n<li>用双引号创建的对象相加产生的对象放在常量池，如 <em>String s = “Hello” + “Jvm”;</em>，这里的s对象就是放在常量池中的。</li>\n<li>调用String对象的intern方法会返回一个存放在常量池中的String对象,且两个对象内容相同。</li>\n</ul>\n<p>再回到本篇的主题上，因为常量池位置的变化，在不同的jdk版本下，下面代码的执行结果是不一样的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ConstantsPool &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        String s = new String(&quot;Hello&quot;) + new String(&quot;Jvm&quot;); //1</span><br><span class=\"line\">        String s1 = s.intern();  //2</span><br><span class=\"line\">        System.out.println(s == s1); //jdk5和jdk6中返回false，jdk7及其以上版本返回true。</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>在jdk7之前，程序在执行//2处代码之前常量池中没有”HelloJvm”这个字符串常量，//2处代码执行时，程序会在常量池中创建一个”HelloJvm”的字符串对象s1并返回，而常量池是在方法区的。那一个在堆中的s对象和方法区中的s1对象比较地址是否相同，当然会得到false。<br>在jdk7及其以后的版本，程序在执行//2出代码时，发现常量池中同样没有”HelloJvm”这个对象，但因为常量池已经迁移到堆中，常量池不需要存储一个对象了，程序只是简单的把s这个对象的引用在常量池中存储了，此时s和s1指向的是同一个对象，结果当然是true。</p>\n<p>上面简单介绍了jdk7中常量池的变化，而在jdk8中方法整个方法区被放到了物理机的本地内存,同时也更名为元空间（MetaSpace）：</p>\n<p><img src=\"https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/jvm/post1/jvm_memory_model_1.8.png\" alt=\"jdk8\"></p>\n<p>jdk8及其以后的版本，元空间直接使用物理机的本地内存，在不加限制的情况下其最大值为本地内存的最大可用值。考虑到物理机上可能部署其它的应用服务，通常会给元空间加一个大小限制。</p>\n<p>关于元空间最常见的虚拟机参数是：</p>\n<ul>\n<li>-XX:MetaspaceSize : 表示虚拟机元空间发生MetadataGC时的初始阈值,如 -XX:MetaspaceSize=10M 表示元空间在第一次到大10M时，会发生一次MetadataGC。</li>\n<li>-XX:MaxMetaspaceSize ： 表示虚拟机元空间的最大值为MaxMetaspaceSize，如 -XX:MaxMetaspaceSize=15M 表示元空间的最大值为15M，再大就会发生OOM异常。</li>\n</ul>\n<p>关于元空间的的内存溢出模拟，我们需要借助CGLib来动态的创建类，先引入如下maven依赖：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;cglib&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;cglib-nodep&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;3.3.0&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n\n<p>具体代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 虚拟机参数 -XX:MaxMetaspaceSize=10M </span><br><span class=\"line\"> * @description 元空间内存溢出</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class MetaSpaceOOM &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        BeanGenerator beanGenerator = new BeanGenerator();</span><br><span class=\"line\">        List&lt;Class&gt; classes = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        for (int i=0; i&lt;1000000000L;i++ ) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            beanGenerator.addProperty(&quot;id&quot;+i, Integer.class);</span><br><span class=\"line\">            Object aClass = beanGenerator.createClass();</span><br><span class=\"line\">            classes.add((Class) aClass);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> 执行结果为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Exception in thread &quot;main&quot; java.lang.IllegalStateException: Unable to load cache item</span><br><span class=\"line\">\tat net.sf.cglib.core.internal.LoadingCache.createEntry(LoadingCache.java:79)</span><br><span class=\"line\">\tat net.sf.cglib.core.internal.LoadingCache.get(LoadingCache.java:34)</span><br><span class=\"line\">\tat net.sf.cglib.core.AbstractClassGenerator$ClassLoaderData.get(AbstractClassGenerator.java:119)</span><br><span class=\"line\">\tat net.sf.cglib.core.AbstractClassGenerator.create(AbstractClassGenerator.java:294)</span><br><span class=\"line\">\tat net.sf.cglib.beans.BeanGenerator.createHelper(BeanGenerator.java:94)</span><br><span class=\"line\">\tat net.sf.cglib.beans.BeanGenerator.createClass(BeanGenerator.java:85)</span><br><span class=\"line\">\tat jvm.post1.MetaSpaceOOM.main(MetaSpaceOOM.java:19)</span><br><span class=\"line\">Caused by: java.lang.OutOfMemoryError: Metaspace</span><br><span class=\"line\">\tat net.sf.cglib.core.AbstractClassGenerator.generate(AbstractClassGenerator.java:348)</span><br><span class=\"line\">\tat net.sf.cglib.core.AbstractClassGenerator$ClassLoaderData$3.apply(AbstractClassGenerator.java:96)</span><br><span class=\"line\">\tat net.sf.cglib.core.AbstractClassGenerator$ClassLoaderData$3.apply(AbstractClassGenerator.java:94)</span><br><span class=\"line\">\tat net.sf.cglib.core.internal.LoadingCache$2.call(LoadingCache.java:54)</span><br><span class=\"line\">\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)</span><br><span class=\"line\">\tat net.sf.cglib.core.internal.LoadingCache.createEntry(LoadingCache.java:61)</span><br><span class=\"line\">\t... 6 more</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，引起IllegalStateException异常的正是因为”Metaspace”类型的OOM错误。具体原因为BeanGenerator对象通过createClass方法不断创建新的类，导致最大内存为10MB的元空间没办法存储类的信息而抛出异常。</p>\n<h2 id=\"虚拟机栈和本地方法栈\"><a href=\"#虚拟机栈和本地方法栈\" class=\"headerlink\" title=\"虚拟机栈和本地方法栈\"></a>虚拟机栈和本地方法栈</h2><p>虚拟机栈和本地方法栈，都是线程私有的，主要用来存储在线程运行过程中的局部变量、操作数栈、方法出入口等信息，这些信息是以栈帧的形式存储的，虚拟机栈和本地方法栈的区别就是一个存储java方法运行时的栈帧数据一个存储本地方法（native 关键字修饰的方法）运行时的栈帧数据。由于都是存储栈帧数据，两种栈的区别不是很大，甚至在HotSpot虚拟机中，直接把这两个合二为一，所以本小节把这两种栈合起来说。java程序在运行时的栈数据结构如下图：</p>\n<p><img src=\"https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/jvm/post1/stack-model.jpg\" alt=\"运行时栈结构\">  </p>\n<p>在介绍堆时，我们曾说过几乎所有的对象都是在堆中创建的，这几乎中的特例就来自于栈，对象是可以在栈上创建，我们称为栈上分配。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 执行栈上分配的虚拟机参数  -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -Xmx10M</span><br><span class=\"line\"> * 不执行栈上分配的虚拟机参数  -XX:-DoEscapeAnalysis -XX:+EliminateAllocations -Xmx10M</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * 参数说明：</span><br><span class=\"line\"> * DoEscapeAnalysis  ： 逃逸分析，对于本例来说逃逸分析可以判断出//1处创建的对象是否会被本方法外的方法获取到。</span><br><span class=\"line\"> * EliminateAllocations ： 标量替换，对于本例来说，在逃逸分析的帮助下发现//1出的User对象不会逃逸出方法allo，那么消除User对象的堆内存分配，把它的字段改为一个个独立的局部变量（本例中是int类型的标量）存储在线程的栈中。</span><br><span class=\"line\"> * 要模拟栈上分配，需要逃逸分析和标量替换两个功能都是开启的。</span><br><span class=\"line\"> * @description 栈上分配</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class StackAllocation &#123;</span><br><span class=\"line\">    static class User&#123;</span><br><span class=\"line\">        int i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void allo() &#123;</span><br><span class=\"line\">        User user = new User(); //1</span><br><span class=\"line\">        user.i = 4;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        long startTime = System.currentTimeMillis();</span><br><span class=\"line\">        for (int i = 0; i &lt; 100000000L; i++) &#123;</span><br><span class=\"line\">            allo();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        long endTime = System.currentTimeMillis();</span><br><span class=\"line\">        System.out.println(endTime - startTime);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>用不同的虚拟机参数执行上面的代码时，会发现同样执行1亿次方法调用，栈上分配的执行时间明显比非栈上分配的执行时间短。简单的解释就是1亿个的User对象不是被分配在堆上，这样就避免了频繁的GC，对性能自然有很大提升。</p>\n<p>与栈相关的虚拟机参数主要有：</p>\n<ul>\n<li>-Xss : 设置java线程栈的大小，如 -Xss100k 表示每个java线程栈的大小为100k。</li>\n</ul>\n<p>线程栈是用来存方法的栈帧的。线程栈越大其能调用的方法深度越大，运行如下代码可以印证此观点：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 虚拟机参数 -Xss1000K</span><br><span class=\"line\"> * @description 模拟栈内存溢出</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class StackOverFlowOOM &#123;</span><br><span class=\"line\">    private static int num = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void loop()&#123;</span><br><span class=\"line\">        num++;</span><br><span class=\"line\">        loop();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            loop();</span><br><span class=\"line\">        &#125; catch (Throwable e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            System.out.println(num);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当Xss的值越大时，程序中的num变量在栈溢出异常时的值越大。jdk8中如果不指定Xss参数的大小，那么其默认值为1MB，这也从内存角度印证线程是一种昂贵的资源，即使简单的创建一个线程而不分配给其处理任务，其也要占用一些内存空间。</p>\n<h2 id=\"程序计数器\"><a href=\"#程序计数器\" class=\"headerlink\" title=\"程序计数器\"></a>程序计数器</h2><p>程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器，因为操作系统会分配给各个线程一些时间片来运行，当时间片用完后，就需要有程序计数器记录线程执行的位置，用来在线程重新获得时间片时能恢复到原来的执行位置。从程序计数器的用途得知，程序程序计数器也是线程私有的，而且也是唯一一个不会有OOM异常的虚拟机内存区域。</p>\n<h2 id=\"篇尾小节\"><a href=\"#篇尾小节\" class=\"headerlink\" title=\"篇尾小节\"></a>篇尾小节</h2><p>本篇主要简绍了java虚拟机在运行时的各个内存区域，简单介绍了它们的作用和内存溢出的方式。</p>\n<blockquote>\n<p>有任何不懂或者质疑的地方，都欢迎大家积极留言讨论，留言必回，一起学习进步。</p>\n</blockquote>\n<!--\n参考文献 ：\nhttp://lovestblog.cn/blog/2016/10/29/metaspace/ \n-->","site":{"data":{}},"excerpt":"","more":"<h1 id=\"最全面的jvm运行时数据区讲解\"><a href=\"#最全面的jvm运行时数据区讲解\" class=\"headerlink\" title=\"最全面的jvm运行时数据区讲解\"></a>最全面的jvm运行时数据区讲解</h1><p>记得有位大佬曾经说过这样一句话：</p>\n<blockquote>\n<p>如欲征服java，必须征服java虚拟机，如欲征服java虚拟机，需先征服java虚拟机内存模型。</p>\n</blockquote>\n<p>java虚拟机内存，是java虚拟机进行对象内存空间分配、垃圾回收的活动室，只有先了解java虚拟机内存才能在此基础上进一步了解对象内存分配、垃圾回收等活动。有别于真实物理机硬盘、主存、缓存、寄存器的存储模型，java虚拟机内存模型按照其存储模块负责的数据类型将其划分为如下图所示的模型：</p>\n<p><img src=\"https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/jvm/post1/jvm_memory_model.png\" alt=\"java虚拟机内存模型\"></p>\n<h2 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h2><p>堆是各个线程共享的内存区域，是java对象内存分配和垃圾回收的主战场，几乎所有的对象都是在堆中创建的。根据<em>Java虚拟机规范（Java Virtual Machine Specification）</em> 的规则，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。如果在堆中没有内存空间完成Java对象的内存分配时，将会抛出OutOfMemoryError（一下简称OOM）。</p>\n<p>关于堆的最常见虚拟机参数：</p>\n<ul>\n<li>-Xms ：表示虚拟机堆的最小值，如 -Xms10M 表示堆的最小值为10MB</li>\n<li>-Xmx ：表示虚拟机堆的最大值，如果 -Xmx100M 表示堆的最大值为100MB</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 设置虚拟机参数为：-Xms5M -Xmx5M</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class HeapOOM &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        ArrayList&lt;Byte[]&gt; bytes = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        for (; ; ) &#123;</span><br><span class=\"line\">            Byte[] _1M = new Byte[1024 * 1024];</span><br><span class=\"line\">            bytes.add(_1M);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>执行结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br><span class=\"line\">\tat jvm.post1.HeapOOM.main(HeapOOM.java:15)</span><br></pre></td></tr></table></figure>\n\n<p>“Java heap space”类型的OOM表示堆中没有可用的内存空间，具体到本例子中就是在大小为5M的堆中没有可用空间分配给大小为1M的数组对象。再来看一个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * @createtime 2019/11/2</span><br><span class=\"line\"> * 虚拟机参数 -Xms5M -Xmx5M </span><br><span class=\"line\">*/ </span><br><span class=\"line\">public class HeapOOM1 &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        ArrayList&lt;Object&gt; heapOOM1s = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        for (; ; ) &#123;</span><br><span class=\"line\">            heapOOM1s.add(new Object());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>执行结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: GC overhead limit exceeded</span><br><span class=\"line\">\tat jvm.post1.HeapOOM1.main(HeapOOM1.java:14)</span><br></pre></td></tr></table></figure>\n\n<p>“GC overhead limit exceeded” 类型的OOM是在jdk6后引入的一种新的错误类型。发生错误的原因是虚拟机用了大量的时间进行GC但是只释放了较小的空间，这是虚拟机的一种保护机制。具体到本例子中就是虚拟机在GC时没有能回收内存空间，浪费了时间却没有收获，所以就抛出了这个错误。可以用 <em>-XX:-UseGCOverheadLimit</em>参数禁用这个检查，但解决不了内存问题，只是把错误的信息延后，替换成 java.lang.OutOfMemoryError: Java heap space错误。</p>\n<h2 id=\"方法区\"><a href=\"#方法区\" class=\"headerlink\" title=\"方法区\"></a>方法区</h2><p>方法区和堆一样，也是各个线程共享的内存区域，它用来存储已经被虚拟机加载的类信息、常量池、静态变量等。方法区是jdk5到jdk8变化较大的java虚拟机内存区域。在jdk5和jdk6时，常量池是存在方法区的：</p>\n<p><img src=\"https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/jvm/post1/jvm_memory_model_1.5.png\" alt=\"jdk5和jdk6\"></p>\n<p>而从jdk7及其以后的版本，常量池被放到了堆里面：</p>\n<p><img src=\"https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/jvm/post1/jvm_memory_model_1.7.png\" alt=\"jdk7\"></p>\n<p>常量池就是java语言系统级别的缓存，目的是让程序在运行过程中速度更快，更节省内存空间，java的8种基本数据类型外加String类型，共9种类型都有对应的常量池。这些类型的对象不可能全都放到常量池中存储，因此不同的类型有不同的存储策略，具体到String类型的对象来说，有如下三条规则：</p>\n<ul>\n<li>用双引号创建的对象放在常量池中，如 “Hello”，”Jvm”这种。</li>\n<li>用双引号创建的对象相加产生的对象放在常量池，如 <em>String s = “Hello” + “Jvm”;</em>，这里的s对象就是放在常量池中的。</li>\n<li>调用String对象的intern方法会返回一个存放在常量池中的String对象,且两个对象内容相同。</li>\n</ul>\n<p>再回到本篇的主题上，因为常量池位置的变化，在不同的jdk版本下，下面代码的执行结果是不一样的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ConstantsPool &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        String s = new String(&quot;Hello&quot;) + new String(&quot;Jvm&quot;); //1</span><br><span class=\"line\">        String s1 = s.intern();  //2</span><br><span class=\"line\">        System.out.println(s == s1); //jdk5和jdk6中返回false，jdk7及其以上版本返回true。</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>在jdk7之前，程序在执行//2处代码之前常量池中没有”HelloJvm”这个字符串常量，//2处代码执行时，程序会在常量池中创建一个”HelloJvm”的字符串对象s1并返回，而常量池是在方法区的。那一个在堆中的s对象和方法区中的s1对象比较地址是否相同，当然会得到false。<br>在jdk7及其以后的版本，程序在执行//2出代码时，发现常量池中同样没有”HelloJvm”这个对象，但因为常量池已经迁移到堆中，常量池不需要存储一个对象了，程序只是简单的把s这个对象的引用在常量池中存储了，此时s和s1指向的是同一个对象，结果当然是true。</p>\n<p>上面简单介绍了jdk7中常量池的变化，而在jdk8中方法整个方法区被放到了物理机的本地内存,同时也更名为元空间（MetaSpace）：</p>\n<p><img src=\"https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/jvm/post1/jvm_memory_model_1.8.png\" alt=\"jdk8\"></p>\n<p>jdk8及其以后的版本，元空间直接使用物理机的本地内存，在不加限制的情况下其最大值为本地内存的最大可用值。考虑到物理机上可能部署其它的应用服务，通常会给元空间加一个大小限制。</p>\n<p>关于元空间最常见的虚拟机参数是：</p>\n<ul>\n<li>-XX:MetaspaceSize : 表示虚拟机元空间发生MetadataGC时的初始阈值,如 -XX:MetaspaceSize=10M 表示元空间在第一次到大10M时，会发生一次MetadataGC。</li>\n<li>-XX:MaxMetaspaceSize ： 表示虚拟机元空间的最大值为MaxMetaspaceSize，如 -XX:MaxMetaspaceSize=15M 表示元空间的最大值为15M，再大就会发生OOM异常。</li>\n</ul>\n<p>关于元空间的的内存溢出模拟，我们需要借助CGLib来动态的创建类，先引入如下maven依赖：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;cglib&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;cglib-nodep&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;3.3.0&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n\n<p>具体代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 虚拟机参数 -XX:MaxMetaspaceSize=10M </span><br><span class=\"line\"> * @description 元空间内存溢出</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class MetaSpaceOOM &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        BeanGenerator beanGenerator = new BeanGenerator();</span><br><span class=\"line\">        List&lt;Class&gt; classes = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        for (int i=0; i&lt;1000000000L;i++ ) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            beanGenerator.addProperty(&quot;id&quot;+i, Integer.class);</span><br><span class=\"line\">            Object aClass = beanGenerator.createClass();</span><br><span class=\"line\">            classes.add((Class) aClass);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> 执行结果为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Exception in thread &quot;main&quot; java.lang.IllegalStateException: Unable to load cache item</span><br><span class=\"line\">\tat net.sf.cglib.core.internal.LoadingCache.createEntry(LoadingCache.java:79)</span><br><span class=\"line\">\tat net.sf.cglib.core.internal.LoadingCache.get(LoadingCache.java:34)</span><br><span class=\"line\">\tat net.sf.cglib.core.AbstractClassGenerator$ClassLoaderData.get(AbstractClassGenerator.java:119)</span><br><span class=\"line\">\tat net.sf.cglib.core.AbstractClassGenerator.create(AbstractClassGenerator.java:294)</span><br><span class=\"line\">\tat net.sf.cglib.beans.BeanGenerator.createHelper(BeanGenerator.java:94)</span><br><span class=\"line\">\tat net.sf.cglib.beans.BeanGenerator.createClass(BeanGenerator.java:85)</span><br><span class=\"line\">\tat jvm.post1.MetaSpaceOOM.main(MetaSpaceOOM.java:19)</span><br><span class=\"line\">Caused by: java.lang.OutOfMemoryError: Metaspace</span><br><span class=\"line\">\tat net.sf.cglib.core.AbstractClassGenerator.generate(AbstractClassGenerator.java:348)</span><br><span class=\"line\">\tat net.sf.cglib.core.AbstractClassGenerator$ClassLoaderData$3.apply(AbstractClassGenerator.java:96)</span><br><span class=\"line\">\tat net.sf.cglib.core.AbstractClassGenerator$ClassLoaderData$3.apply(AbstractClassGenerator.java:94)</span><br><span class=\"line\">\tat net.sf.cglib.core.internal.LoadingCache$2.call(LoadingCache.java:54)</span><br><span class=\"line\">\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)</span><br><span class=\"line\">\tat net.sf.cglib.core.internal.LoadingCache.createEntry(LoadingCache.java:61)</span><br><span class=\"line\">\t... 6 more</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，引起IllegalStateException异常的正是因为”Metaspace”类型的OOM错误。具体原因为BeanGenerator对象通过createClass方法不断创建新的类，导致最大内存为10MB的元空间没办法存储类的信息而抛出异常。</p>\n<h2 id=\"虚拟机栈和本地方法栈\"><a href=\"#虚拟机栈和本地方法栈\" class=\"headerlink\" title=\"虚拟机栈和本地方法栈\"></a>虚拟机栈和本地方法栈</h2><p>虚拟机栈和本地方法栈，都是线程私有的，主要用来存储在线程运行过程中的局部变量、操作数栈、方法出入口等信息，这些信息是以栈帧的形式存储的，虚拟机栈和本地方法栈的区别就是一个存储java方法运行时的栈帧数据一个存储本地方法（native 关键字修饰的方法）运行时的栈帧数据。由于都是存储栈帧数据，两种栈的区别不是很大，甚至在HotSpot虚拟机中，直接把这两个合二为一，所以本小节把这两种栈合起来说。java程序在运行时的栈数据结构如下图：</p>\n<p><img src=\"https://github.com/aworker/aworker.github.io/raw/hexo/source/_posts/java/jvm/post1/stack-model.jpg\" alt=\"运行时栈结构\">  </p>\n<p>在介绍堆时，我们曾说过几乎所有的对象都是在堆中创建的，这几乎中的特例就来自于栈，对象是可以在栈上创建，我们称为栈上分配。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 执行栈上分配的虚拟机参数  -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -Xmx10M</span><br><span class=\"line\"> * 不执行栈上分配的虚拟机参数  -XX:-DoEscapeAnalysis -XX:+EliminateAllocations -Xmx10M</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * 参数说明：</span><br><span class=\"line\"> * DoEscapeAnalysis  ： 逃逸分析，对于本例来说逃逸分析可以判断出//1处创建的对象是否会被本方法外的方法获取到。</span><br><span class=\"line\"> * EliminateAllocations ： 标量替换，对于本例来说，在逃逸分析的帮助下发现//1出的User对象不会逃逸出方法allo，那么消除User对象的堆内存分配，把它的字段改为一个个独立的局部变量（本例中是int类型的标量）存储在线程的栈中。</span><br><span class=\"line\"> * 要模拟栈上分配，需要逃逸分析和标量替换两个功能都是开启的。</span><br><span class=\"line\"> * @description 栈上分配</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class StackAllocation &#123;</span><br><span class=\"line\">    static class User&#123;</span><br><span class=\"line\">        int i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void allo() &#123;</span><br><span class=\"line\">        User user = new User(); //1</span><br><span class=\"line\">        user.i = 4;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        long startTime = System.currentTimeMillis();</span><br><span class=\"line\">        for (int i = 0; i &lt; 100000000L; i++) &#123;</span><br><span class=\"line\">            allo();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        long endTime = System.currentTimeMillis();</span><br><span class=\"line\">        System.out.println(endTime - startTime);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>用不同的虚拟机参数执行上面的代码时，会发现同样执行1亿次方法调用，栈上分配的执行时间明显比非栈上分配的执行时间短。简单的解释就是1亿个的User对象不是被分配在堆上，这样就避免了频繁的GC，对性能自然有很大提升。</p>\n<p>与栈相关的虚拟机参数主要有：</p>\n<ul>\n<li>-Xss : 设置java线程栈的大小，如 -Xss100k 表示每个java线程栈的大小为100k。</li>\n</ul>\n<p>线程栈是用来存方法的栈帧的。线程栈越大其能调用的方法深度越大，运行如下代码可以印证此观点：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 虚拟机参数 -Xss1000K</span><br><span class=\"line\"> * @description 模拟栈内存溢出</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class StackOverFlowOOM &#123;</span><br><span class=\"line\">    private static int num = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void loop()&#123;</span><br><span class=\"line\">        num++;</span><br><span class=\"line\">        loop();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            loop();</span><br><span class=\"line\">        &#125; catch (Throwable e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            System.out.println(num);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当Xss的值越大时，程序中的num变量在栈溢出异常时的值越大。jdk8中如果不指定Xss参数的大小，那么其默认值为1MB，这也从内存角度印证线程是一种昂贵的资源，即使简单的创建一个线程而不分配给其处理任务，其也要占用一些内存空间。</p>\n<h2 id=\"程序计数器\"><a href=\"#程序计数器\" class=\"headerlink\" title=\"程序计数器\"></a>程序计数器</h2><p>程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器，因为操作系统会分配给各个线程一些时间片来运行，当时间片用完后，就需要有程序计数器记录线程执行的位置，用来在线程重新获得时间片时能恢复到原来的执行位置。从程序计数器的用途得知，程序程序计数器也是线程私有的，而且也是唯一一个不会有OOM异常的虚拟机内存区域。</p>\n<h2 id=\"篇尾小节\"><a href=\"#篇尾小节\" class=\"headerlink\" title=\"篇尾小节\"></a>篇尾小节</h2><p>本篇主要简绍了java虚拟机在运行时的各个内存区域，简单介绍了它们的作用和内存溢出的方式。</p>\n<blockquote>\n<p>有任何不懂或者质疑的地方，都欢迎大家积极留言讨论，留言必回，一起学习进步。</p>\n</blockquote>\n<!--\n参考文献 ：\nhttp://lovestblog.cn/blog/2016/10/29/metaspace/ \n-->"}],"PostAsset":[],"PostCategory":[{"post_id":"ck9xz685y00022kie50159e2x","category_id":"ck9xz686200042kie1awgd3s7","_id":"ck9xz686600062kief08pfmcr"},{"post_id":"ck9xz686000032kie645aeu6z","category_id":"ck9xz686200042kie1awgd3s7","_id":"ck9xz686700072kiecpjc3bhm"},{"post_id":"ck9xz686900082kie5dfm3ciq","category_id":"ck9xz686b000a2kie30002cpw","_id":"ck9xz686e000g2kie38ym47ao"},{"post_id":"ck9xz686900082kie5dfm3ciq","category_id":"ck9xz686d000e2kie64cu3vat","_id":"ck9xz686e000i2kied0gu78vd"},{"post_id":"ck9xz686a00092kieco8xbc9m","category_id":"ck9xz686c000c2kie5p2e1c7m","_id":"ck9xz686f000j2kie5a7s3awa"},{"post_id":"ck9xz686a00092kieco8xbc9m","category_id":"ck9xz686d000f2kie2203934s","_id":"ck9xz686f000k2kiehm71avbi"},{"post_id":"ck9xz686b000b2kie2efldlag","category_id":"ck9xz686b000a2kie30002cpw","_id":"ck9xz686f000l2kiedaux80w9"},{"post_id":"ck9xz686b000b2kie2efldlag","category_id":"ck9xz686d000e2kie64cu3vat","_id":"ck9xz686f000m2kieedsv4mp5"},{"post_id":"ck9xz686g000n2kie114ec6ou","category_id":"ck9xz686c000c2kie5p2e1c7m","_id":"ck9xz686i000o2kie4ypu80m9"},{"post_id":"ck9xz686g000n2kie114ec6ou","category_id":"ck9xz686d000f2kie2203934s","_id":"ck9xz686i000p2kie8ew4g1os"}],"PostTag":[],"Tag":[]}}